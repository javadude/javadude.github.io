[{"body":"","link":"https://javadude.com/","section":"","tags":null,"title":""},{"body":"","link":"https://javadude.com/tags/android/","section":"tags","tags":null,"title":"Android"},{"body":"","link":"https://javadude.com/categories/articles/","section":"categories","tags":null,"title":"Articles"},{"body":"","link":"https://javadude.com/categories/","section":"categories","tags":null,"title":"Categories"},{"body":"","link":"https://javadude.com/tags/gradle/","section":"tags","tags":null,"title":"Gradle"},{"body":"","link":"https://javadude.com/tags/index/","section":"tags","tags":null,"title":"Index"},{"body":"","link":"https://javadude.com/tags/kotlin/","section":"tags","tags":null,"title":"Kotlin"},{"body":"A collection of official Android documentation that I wrote while employed at Google, with editorial tweaks from the amazing tech writers I worked with!\nIncludes build and project structure overviews and details on dependency resolution and maintenance.\nRead on for the links! Good stuff!\nGradle build overview General overview on how Gradle builds work for Android 2024 Android build structure Directory structure and file details for a typical Andrioid project 2024 Gradle build overview General overview on how Gradle builds work for Android 2024 Android build structure Directory structure and file details for a typical Andrioid project 2024 Tool and library interdependencies How library and tool dependencies interact when building an Android application 2024 Gradle dependency resolution Details on how Gradle resolves library dependencies 2024 Upgrade build dependencies Strategies for confidently upgrading library dependencies in your build 2024 Java versions in Android builds Details on the multiple JDK specifications in an Android build 2023 Android icon created by Freepik - Flaticon\n","link":"https://javadude.com/post/20250323-android-docs/","section":"post","tags":["android","gradle","kotlin"],"title":"Official Android Docs (That I've Written)"},{"body":"","link":"https://javadude.com/post/","section":"post","tags":["index"],"title":"Posts"},{"body":"","link":"https://javadude.com/tags/","section":"tags","tags":null,"title":"Tags"},{"body":"","link":"https://javadude.com/categories/class/","section":"categories","tags":null,"title":"Class"},{"body":"","link":"https://javadude.com/tags/class/","section":"tags","tags":null,"title":"Class"},{"body":"I've been teaching an Android class for Johns Hopkins University since 2012. It's gone through many iterations over time, from development environments to languages to UI frameworks.\nMost days I wish I just taught math. Math doesn't change like this every year.\nRead on for the current and legacy content links.\nContentAndroidByExample.com Current course contentText and Videos(updated Spring 2025) SamplesGitLab Current SamplesKotlin and Jetpack Compose(updated Spring 2025) Legacy contentYouTube Playlist Partial legacy \u0026quot;Views\u0026quot; UI contentKotlin and Views Android image reproduced from work created and shared by the Android Open Source Project and used according to terms described in the Creative Commons 2.5 Attribution License.\n","link":"https://javadude.com/post/20250322-android-class/","section":"post","tags":["android","kotlin","class"],"title":"My Android class content for Johns Hopkins University"},{"body":"I taught a single-term Domain-Specific Languages class for Johns Hopkins University in 2018.\nRead on for the video playlist link!\nThe recordings from the sessions are at Domain Specific Languages.\n","link":"https://javadude.com/post/20250322-dsl-class/","section":"post","tags":["kotlin","class"],"title":"My Domain-Specific Languages (DSL) class content for Johns Hopkins University"},{"body":"I've been teaching a live Kotlin class for Johns Hopkins University since 2020.\nRead on for the latest video playlist link!\nHere are the recordings from the Spring 2024 session.\n","link":"https://javadude.com/post/20250322-kotlin-class/","section":"post","tags":["kotlin","class"],"title":"My Kotlin class content"},{"body":"Who is Scott Stanchfield? One part architect; Two parts developer; One part trainer. These were the ingredients chosen to create the ultimate ego. But when the professor accidentally added an extra ingredient to the concoction - Chemical X - a Java Guru was born!\nFrom his beginnings as a developer at IBM slinging air-traffic control system configuration management software, Scott has always loved software development. His twisted love of LL(1) parsing led him to working with Tom McCabe on parsers for reverse-engineering tools and with Frank DeRemer and Tom Penello on C++ compiler development (as well as a brief stint on the ANSI C++ committee -- don't blame him... he voted \u0026quot;no, with comments\u0026quot;!). While working toward his Master's Degree at The Johns Hopkins University, Scott realized that something was missing: teaching.\nAlong came MageLang Institute (now jGuru.com). Scott was dubbed \u0026quot;Software Guru\u0026quot; (ok, so he picked his own title), teaching Java around the world, including Sydney, London, Stuttgart, and Peoria. Excitement abounds at home and abroad!\nSoon, Scott became known as a VisualAge for Java guru. (IBM's VP of marketing for VisualAge often joked that Scott was their best marketing weapon...) From teaching VisualAge and maintaining a tips and tricks web site, to writing Effective VisualAge for Java, Scott helped everyone understand the power of a great IDE. He even converted some who thought IDE meant \u0026quot;I Don't have Emacs\u0026quot;. Little did he know that six months after his book was published, IBM would abandon VisualAge for Java in favor of Eclipse. Excellent move by IBM, but book sales flatlined. Game over, dude.\nAfter nearly five years of Java training, Scott soon knew every question that anyone could possibly ask related to Java, and had seen students make every possible mistake that could be made while working a lab exercise. Weary of the travel required for training, Scott rejoined the development workforce.\nForgetting his vow to never again work on a government contract, Scott joined FGM, Incorporated, a government contractor in Virginia. He worked with an elite architecture team, working out new ways to install light bulbs without making the entire chain of lights black out. As time permits, the team works on discovery and mediation mechanisms for the new Department of Defense Network-Centric architecture, and export/import controls for the State Department.\nBut all long commutes must come to an end. After a cryptic courtship and interview process, Scott joined Hillcrest Communications and finally learned what their product is. \u0026quot;I'd buy that\u0026quot;, he was heard exclaiming.\nFour years later, Scott joined the wacky researchers at the Johns Hopkins University's Applied Physics Laboratory. Very cool place, and he applied research to make our government a more secure and fun place. Most importantly, he joined the APL Drama Club, directing four plays and acting in three.\nThirteen years later, during the pandemic, Scott joined Google as a Developer Relations Engineer for Android. It sounded similar to his VisualAge for Java evangelism, writing, speaking, creating examples and videos. But, alas, the job morphed into more targeted developer assistance and project management, which wasn't as satisfying as he thought it would be.\nSince 2002, Scott has been joining forces with his superfriends at The Johns Hopkins University to teach Graduate students Java, Kotlin and Android.\n","link":"https://javadude.com/about/","section":"","tags":null,"title":"About"},{"body":"","link":"https://javadude.com/tags/android-studio/","section":"tags","tags":null,"title":"Android Studio"},{"body":"Android Studio makes it crazy easy to locate deadlocks! I'll explain how in this video.\nVideos Video License Finding a deadlock in Android Studio by Scott Stanchfield is licensed under a Creative Commons Attribution-Noncommercial-No Derivative Works 3.0 United States License.\nFeel free to watch the videos and point friends to them, but you cannot use them as part of any commercial product nor can you create derivative works. Follow the link above to see the complete license text.\nSample Code Code: Deadlock.zip Software License All code is licensed under Apache 2 http://www.apache.org/licenses/LICENSE-2.0\nCopyright 2019 Scott Stanchfield\nLicensed under the Apache License, Version 2.0 (the \u0026quot;License\u0026quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026quot;AS IS\u0026quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.\n","link":"https://javadude.com/post/20190326-android-studio-deadlocks/","section":"post","tags":["android","android studio"],"title":"Finding a deadlock in Android Studio"},{"body":"","link":"https://javadude.com/categories/videos/","section":"categories","tags":null,"title":"Videos"},{"body":"Let's learn Kotlin from a Java point of view. We'll start by looking at some basics of Variables, Values, Classes, Properties and Constructors.\nIntroduction I remember the way I felt when Java came out. There was this feeling of freedom using Java after using C++ for so long. I feel the same way switching from Java to Kotlin...\nThis series of posts assumes you're fairly familiar with Java. I'll explain some Java concepts more than others (like Anonymous Inner Classes and Lambdas), and in some cases point you to other articles or videos for more detail on how Java does things.\nHopefully, many of the Kotlin concepts will make sense on their own... But don't say I didn't warn you ;)\nThis post starts by taking a look at the very basics of Variables, Values, Classes, Properties and Constructors. In future articles, I'll be going into more detail on these topics. Learning a new programming language often requires a lot of back and forth as the concepts are often highly interconnected...\nA Note on Nulls While you're reading this, you'll likely think \u0026quot;why didn't he use null instead of dummy values?\u0026quot;...\nNullability is a pretty big concept and I knew this article would be pretty long to start with, so I'm punting it down the road a wee bit. But don't worry... I'll get to it... It's quite important!\nMain Functions Kotlin has \u0026quot;main\u0026quot; functions just like Java. You'll most likely use Kotlin in environments like servers or Android applications that don't need a main, but they're useful for examples.\nIf you don't need any command-line arguments:\n1fun main() { 2 println(\u0026#34;Hello, World!\u0026#34;) 3} If you want command-line arguments, you can use an explicit Array (more on that and joinToString() later). I'm passing A B C to Kotlin Playground for this example.\n1fun main(args: Array\u0026lt;String\u0026gt;) { 2 println(\u0026#34;Hello, World!\u0026#34;) 3 println(args.joinToString()) 4} or you can use a varying-length argument list (more on that and joinToString() later). I'm passing A B C to Kotlin Playground for this example.\n1fun main(vararg args: String) { 2 println(\u0026#34;Hello, World!\u0026#34;) 3 println(args.joinToString()) 4} Yay! No Semicolons! Ding, dong, semicolons are dead! Well, not dead, just not as required as in Java. You can still use them to separate statements, but I don't recommend it. Give yourself a little time to get used to it and you'll add 5 more years before you get carpal-tunnel syndrome. At least according to the science I made up in my head.\n(I do find myself forgetting semicolons when I have to write Java code... But I don't do that often any more...)\nVariables and Values In Kotlin, we explicitly state whether a local or member of a class can be modified. We do this by specifying var or val to define a variable or value.\n1fun main() { 2 var x: String = \u0026#34;Hello\u0026#34; // \u0026#34;initializer is redundant\u0026#34; warning! 3 val y: String = \u0026#34;Message\u0026#34; 4 5 x = \u0026#34;aaa\u0026#34; // just fine; can change the variable 6 y = \u0026#34;bbb\u0026#34; // will not compile!!! can\u0026#39;t change a \u0026#34;val\u0026#34; 7 8 println(x) 9 println(y) 10} If you run the above example, you'll get an \u0026quot;initializer is redundant\u0026quot; warning for line 2. Kotlin does a lot of data flow analysis, and here it's telling us that it sees the only path using x assigns it twice before using it, so the initializer isn't needed. We could write\n1fun main() { 2 var x: String 3 val y: String = \u0026#34;Message\u0026#34; 4 5 x = \u0026#34;aaa\u0026#34; // just fine; can change the variable 6 7 println(x) 8 println(y) 9} Type Inferencing But things get even better. Kotlin loves to infer types so you don't have to write as much code. For example:\n1fun main() { 2 val x = \u0026#34;aaa\u0026#34; 3 println(x) 4} The expression \u0026quot;aaa\u0026quot; is of type String, so kotlin knows that the value x can be a String and infers the type.\nEverything is Public and Final First, the good news...\nAll types, functions and properties are public by default. I think this was a great choice, as I'm a big proponent of keeping things accessible unless there's a really strong reason not to (that reason is usually a sensitive algorithm, such as a security feature). public here means the same thing as in Java; any class can access public types, functions and properties.\nHowever...\nAll classes, functions and properties are final by default (unless explicitly marked as open, abstract or sealed), or being functions/properties defined inside an interface). Interfaces are always non-final (as a final interface wouldn't make sense...)\n[Here comes the rant!!!]\nThis was a horrible design choice, IMNSHO. This means you cannot create subclasses, or override functions or properties unless the parent explicitly says so. Unfortunately the designers of the language took advice from \u0026quot;Effective Java\u0026quot; (which says to only make non-final if you intend people to extend) a little too far. I've come across far too many cases where a library doesn't let you extend something that has gotten in the way. I believe in the Open/Closed principal - open for extension, closed for modification of its guts.\n[rant over... you may continue with your lives...]\nClass and Interface Inheritance Classes/Interfaces (and their members) in Kotlin are nowhere near as verbose as in Java.\n1interface Foo 2open class A 3open class B: A(), Foo 4class C: B() 5 6fun main() { 7 val c = C() 8} Let's break this down, line by line\nLine What's Happening 1 Defines an interface named Foo. Nothing in it, but we might just be using it as a Marker to help us classify objects. 2 Defines a class named A- We can extend it because it's marked open 3 Defines a class named B- It is a subclass of class A- It implements interface Foo- It can be extended because it's open 4 Defines a class named C- It is a subclass of B- Note that this means it's indirectly a subclass of A and implements Foo- It cannot be extended because it is not explicitly marked open 7 Create an instance of C and point value c to it. (Yes... Kotlin has pointers, just like Java... See Java is Pass-By-Value, Dammit!) Some interesting things to note\nBoth interfaces and a class can appear after the colon. there can be at most one class, and any number of interfaces, in any order Superclasses must be followed by a call to a constructor (the parentheses in A() and B() on lines 3 and 4) Before we talk about constructors, let's talk about properties, and I'll circle back. I promise...\nProperties I've been waiting for these for a long time... There's a concept used in Java called JavaBeans, part of which is a convention for defining properties. I've got an article on JavaBeans that goes into a ton of detail, but here are the basics.\nProperties in Java A JavaBean property is defined by one or two methods in a Java class:\n1// JAVA CODE 2public String getFirstName() { ... } 3public void setFirstName(String firstName) { ... } Property types\nIf only a get method exists, we're defining a read-only property. For example, if we only had getFirstName() we're defining a read-only property called firstName (note the case.) If only a set method exists, we're defining a write-only property. For example, if we only had setFirstName() we're defining a write-only property called firstName If both methods exist, we're defining a read/write property These conventions could be used by various tools, such as GUI builders, to automatically determine properties that a user could configure when designing an application. These properties would often appear in a little table where the user could set values and see how the GUI changes, then generate code to set that value at runtime.\nBut this is horribly verbose, and nearly all get/set methods look identical in an application.\nProperties in Kotlin Kotlin fixes this by introducing properties as first-class language constructs.\n1class A { 2 var firstName: String = \u0026#34;no first name\u0026#34; 3 var lastName = \u0026#34;no last name\u0026#34; 4} 5 6fun main() { 7 val a = A() 8 println(a.firstName) 9 a.firstName = \u0026#34;Scott\u0026#34; 10 println(a.firstName) 11} Adding var and val definitions inside a class or interface defines a property. var properties are read/write (you can modify them), and val properties are read-only (you cannot modify them).\nLet's look at this example line-by-line\nLine What's Happening 1 Define a new class (not extensible!) 2 Define a read/write property called firstName of type String initialized to \u0026quot;no first name\u0026quot; 3 Define a read/write property called lastName of inferred type String initialized to \u0026quot;no last name\u0026quot; 7 Create an instance of class A and point value a to it. Note that there is no new keyword; we just specify the class name followed by parens and constructor parameters (if any) 8 Follow pointer a to its A instance and print the value of its firstName property 9 Follow pointer a to its A instance and change the value of its firstName property to \u0026quot;Scott\u0026quot; (Note that technically we're setting the value of the property to point to a String with the value \u0026quot;Scott\u0026quot;) 10 Follow pointer a to its A instance and print the value of its firstName property Using Kotlin Properties From Java Code Kotlin has excellent interoperability with Java. If we defined a Kotlin class\n1class A { 2 var firstName: String = \u0026#34;no first name\u0026#34; 3 var lastName = \u0026#34;no last name\u0026#34; 4} we could access it from Java as\n1// JAVA CODE 2A a = new A(); 3a.setFirstName(\u0026#34;Scott\u0026#34;)); 4System.out.println(a.getFirstName()); Behind the scenes, Kotlin creates a class file to run in the Java Virtual Machine, and this class file contains get and set methods for each read/write property, or just get methods for read-only properties.\nBacking Fields To explain \u0026quot;Backing fields\u0026quot; in Kotlin, let's look at a typical property implementation in Java\nRemember that JavaBean properties are defined solely on the presence of get and set methods. The implementation of those methods does not matter. However, we typically need to store a value when set is called and return it when get is called. For example:\n1// JAVA CODE 2class Foo { 3 private String name; 4 public String getName() { 5 return this.name; 6 } 7 public void setName(String name) { 8 this.name = name; 9 } 10} Note the field name in this example. It's a field in the class that's hidden from anything outside of class Foo. The property defined by getName and setName uses the name field to store the property value.\nKotlin properties can automatically create a behind-the-scenes field just like this. For example, when you write\n1class Foo { 2 var name: String = \u0026#34;no name\u0026#34; 3} the Kotlin compiler generates a get and set function for us (note that Kotlin uses the name \u0026quot;function\u0026quot; for what we would call a \u0026quot;method\u0026quot; in Java), and a \u0026quot;backing field\u0026quot; to hold the value of the name property.\nBut that doesn't always happen...\nIn Java, we might define a get method that computes a value (often called a \u0026quot;derived property\u0026quot;) or returns a literal value. For example\n1// JAVA CODE 2class Foo { 3 public String getName() { 4 return \u0026#34;Scott\u0026#34;; 5 } 6} In this case, we don't need a field to store the value.\nIf we do something like the following in Kotlin\n1class Foo { 2 val name: String = \u0026#34;no name\u0026#34; 3 // NOTE: a \u0026#34;val\u0026#34; property, so only defines a getter! 4} It initializes the backing field to \u0026quot;no name\u0026quot; and returns it whenever the property is accessed.\nIf we want the equivalent of that literal-value get method in Java, we need to explicitly define what the get function in Kotlin would look like. We do this as follows:\n1class Foo { 2 val name: String 3 get() { 4 return \u0026#34;no name\u0026#34; 5 } 6} In this case, because we explicitly define the get() function, and do not mention the backing field, no backing field is defined.\nSo how do we explicitly mention the backing field? We use the field keyword. For example:\n1class Foo { 2 val name: String = \u0026#34;no name\u0026#34; 3 get() { 4 return field 5 } 6} This example is pretty silly; we're explicitly defining the default behavior of a read-only property. It's more interesting if we want to modify the behavior. For example, we could print or log a message whenever the field is requested\n1class Foo { 2 val name: String = \u0026#34;no name\u0026#34; 3 get() { 4 println(\u0026#34;name requested!\u0026#34;) 5 return field 6 } 7} Or more usefully, do something when a value is set. For example, suppose we wanted to ensure a Doctor was always called \u0026quot;Dr.\u0026quot;:\n1class Doctor { 2 var name: String = \u0026#34;Dr. Nobody\u0026#34; 3 set(value) { 4 if (!value.startsWith(\u0026#34;Dr. \u0026#34;)) { 5 field = \u0026#34;Dr. \u0026#34; + value 6 } else { 7 field = value 8 } 9 } 10} 11 12fun main() { 13 val doc = Doctor() 14 doc.name = \u0026#34;Scott\u0026#34; 15 println(doc.name) 16} (NOTE: There are some much more \u0026quot;Kotlin-y\u0026quot; ways to write the body of that set function, but I wanted to keep it closer to Java until we get to those concepts and idioms)\n(ALSO NOTE: Before you comment on it, we would have been better off modifying the get instead of the set. I just wanted to demonstrate what the set would look likeâ€¦)\nHere we're explicitly defining a set function for the name property. We look at the value passed in (the type of value is inferred to be String, the same as the type of the property), and if it doesn't call me a \u0026quot;Dr.\u0026quot; (which I am not; you can just call me \u0026quot;Scott\u0026quot;) it prepends \u0026quot;Dr.\u0026quot;\u0026quot; when setting the value in the backing field.\nWe're not defining the get function so we get its default behavior.\nMost of the time, you'll use properties without explicitly defining the get or set functions, but occasionally these are useful.\nThe most-common instance of defining a get is for returning literals. This can be a little more efficient than initializing the property value and having to keep an extra backing field inside the class.\nConstructors NOTE: There is a lot of code in this section that can be significantly reduced; I'm starting the section conceptually similar to how you would write the equivalent Java code, followed by a section on simplifying it after we've finished the basic concepts.\nNow that we've defined the basics of properties (there will be much more cool stuff to come later...), we can talk about how Constructors work.\nKotlin wants to be terse, which is good, because I don't like to type. (He says after typing in everything you've just read...) One of its best tricks is to combine the definition of a constructor directly in the definition of the class.\nLet's take a look at how we can pass in a name to a Person instance when creating it.\n1class Person(name: String) { 2 var name: String = \u0026#34;No Name\u0026#34; 3 init { 4 this.name = name 5 } 6} Let's look at this example line-by-line\nLine What's Happening 1 Define a new class named Person with a primary constructor.This primary constructor takes a name parameter, which is final (in Java terms) and is of type String. 2 Define a read/write property called name of type String initialized to \u0026quot;No name\u0026quot; 3 Define an initializer. This is a block of code that will run as the body of the primary constructor. 4 Assign the property name to the constructor parameter name. The this. qualifies it to distinguish the property from the parameter. Alternatively, we could have just used a unique name for the parameter and not needed the this. qualification. Kotlin separates the concept of primary and secondary constructors. The Primary Constructor is specified directly after the name of the class. Secondary Constructors are specified in the body of the class.\nSecondary Constructors You can define alternative constructors. For example, if we wanted to be able to skip passing in a value for the name we could define the following\n1class Person(name : String) { 2 var name: String = \u0026#34;No Name\u0026#34; 3 constructor(): this(\u0026#34;No Name\u0026#34;) // SECONDARY CONSTRUCTOR 4 init { 5 this.name = name 6 } 7} 8 9fun main() { 10 val person = Person(\u0026#34;Scott\u0026#34;) 11 println(person.name) 12 val person2 = Person() 13 println(person2.name) 14} On line 3 we're defining a secondary constructor that calls the primary constructor passing in \u0026quot;No Name\u0026quot;. You can have any number of secondary constructors.\nIf you have defined a primary constructor, all secondary constructors must directly or indirectly call it by using the constructor(...) : this(...) syntax. For example:\n1class Person(name: String) { 2 var name: String = \u0026#34;No Name\u0026#34; 3 constructor(n: Int): this(\u0026#34;No Name \u0026#34; + n) 4 constructor(): this(42) 5 init { 6 this.name = name 7 } 8} 9 10fun main() { 11 val person = Person(\u0026#34;Scott\u0026#34;) 12 println(person.name) 13 val person2 = Person() 14 println(person2.name) 15 val person3 = Person(10) 16 println(person3.name) 17} This time, line 3 defines a secondary that takes an Int (similar to Java's primitive int behind the scenes, but treated like an object in code) and appends it after \u0026quot;No Name\u0026quot; before passing it to the primary constructor.\nLine 4 defines another secondary constructor that takes no parameters, and passes 42 to the other secondary constructor, which will then append it to \u0026quot;No Name\u0026quot; and pass it to the primary constructor.\nThe init block then runs as the body of the primary constructor to set the name property.\nCalling Superclass Constructors If you only need to call the primary constructor from a subclass, things are pretty simple:\n1open class Person(name: String) { 2 var name: String = \u0026#34;No Name\u0026#34; 3 init { 4 this.name = name 5 } 6} 7 8class Student(name: String): Person(name) 9 10fun main() { 11 val student = Student(\u0026#34;Scott\u0026#34;) 12 println(student.name) 13} Note that Person is defined as open so we can create subclasses, and has a primary constructor. We call that primary constructor on line 8, right after the superclass name, passing in the value passed to the primary constructor of Student. Student can do more than that, of course. For example:\n1open class Person(name: String) { 2 var name: String = \u0026#34;No Name\u0026#34; 3 init { 4 this.name = name 5 } 6} 7 8class Student( 9 name: String, 10 gpa: Float 11): Person(name) { 12 var gpa: Float = 0F 13 init { 14 this.gpa = gpa 15 } 16} 17 18fun main() { 19 val student = Student(\u0026#34;Scott\u0026#34;, 3.99F) // Sooooo close... 20 println(student.name) 21 println(student.gpa) 22} Things get a little trickier if you want to call secondary constructors in a superclass. In that case, you cannot define a primary constructor in the subclass. If you define a primary constructor, all secondary constructors must call it, which doesn't give us the choice of which super constructor to call... Here's an example:\n1open class Person(name: String) { 2 constructor(): this(\u0026#34;No Name\u0026#34;) 3 var name: String = \u0026#34;No Name\u0026#34; 4 init { 5 this.name = name 6 } 7} 8 9class Student: Person { 10 constructor(): super() 11 constructor(name: String): super(name) 12 var gpa: Float = 0F 13} 14 15fun main() { 16 val student = Student(\u0026#34;Scott\u0026#34;) 17 student.gpa = 3.99F 18 val student2 = Student() 19 student2.gpa = 3.50F 20 println(student.name) 21 println(student.gpa) 22 println(student2.name) 23 println(student2.gpa) 24} So we can pick and choose which superclass constructors are called, but this makes it impossible to pass the gpa to a student constructor and assign it! Time to start looking at better ways to write the code we've been seeing...\nSimplifying Constructors Let's introduce some new concepts that can make constructors much simpler...\nDefault Parameter Values First, default values for parameters...\nMost of the time, we define alternate constructors just to provide default values or different subsets of parameters. Let's start by defining a primary constructor for Person that takes the name and gives it a default value.\n1open class Person( 2 name: String = \u0026#34;No Name\u0026#34; 3) { 4 var name: String = \u0026#34;No Name\u0026#34; 5 init { 6 this.name = name 7 } 8} 9 10fun main() { 11 val person1 = Person() 12 val person2 = Person(\u0026#34;Scott\u0026#34;) 13 println(person1.name) 14 println(person2.name) 15} Now we can create a Person with or without a name using the same constructor. Let's add the Student subclass:\n1open class Person( 2 name: String = \u0026#34;No Name\u0026#34; 3) { 4 var name: String = \u0026#34;No Name\u0026#34; 5 init { 6 this.name = name 7 } 8} 9 10class Student( 11 gpa: Float, 12 name: String = \u0026#34;No Name\u0026#34;, 13): Person(name) { 14 var gpa: Float = 0F 15 init { 16 this.gpa = gpa 17 } 18} 19 20fun main() { 21 val person1 = Person() 22 val person2 = Person(\u0026#34;Scott\u0026#34;) 23 println(person1.name) 24 println(person2.name) 25 26 val student = Student(3.99F, \u0026#34;Scott\u0026#34;) 27 val student2 = Student(3.5F) 28 println(student.name) 29 println(student.gpa) 30 println(student2.name) 31 println(student2.gpa) 32} Now we're able to require the GPA in the Student constructor! Note that parameters with default values must appear after any parameters that do not have default values... Unless...\nNaming Parameters in a Call Kotlin allows you to explicitly name your parameters when calling a function or constructor. For example:\n1open class Person( 2 name: String = \u0026#34;No Name\u0026#34; 3) { 4 var name: String = \u0026#34;No Name\u0026#34; 5 init { 6 this.name = name 7 } 8} 9 10class Student( 11 gpa: Float, 12 name: String = \u0026#34;No Name\u0026#34;, 13): Person(name) { 14 var gpa: Float = 0F 15 init { 16 this.gpa = gpa 17 } 18} 19 20fun main() { 21 val person1 = Person() 22 val person2 = Person(name=\u0026#34;Scott\u0026#34;) 23 println(person1.name) 24 println(person2.name) 25 26 val student = Student(3.99F, name=\u0026#34;Scott\u0026#34;) 27 val student2 = Student(3.5F) 28 println(student.name) 29 println(student.gpa) 30 println(student2.name) 31 println(student2.gpa) 32} This also allows us to specify parameters out of order, or even define default-valued parameters before non-default-valued parameters:\n1open class Person( 2 name: String = \u0026#34;No Name\u0026#34; 3) { 4 var name: String = \u0026#34;No Name\u0026#34; 5 init { 6 this.name = name 7 } 8} 9 10// NOTE PARAMETER ORDER CHANGE!!! 11class Student( 12 name: String = \u0026#34;No Name\u0026#34;, 13 gpa: Float, 14): Person(name) 15 var gpa: Float = 0F 16 init { 17 this.gpa = gpa 18 } 19} 20 21fun main() { 22 val person1 = Person() 23 val person2 = Person(\u0026#34;Scott\u0026#34;) 24 println(person1.name) 25 println(person2.name) 26 27 val student = Student(\u0026#34;Scott\u0026#34;, 3.99F) // ordered 28 val student2 = Student(gpa=3.5F) // named 29 val student3 = Student(gpa=3.99F, name=\u0026#34;Scott\u0026#34;) // different order! 30 println(student.name) 31 println(student.gpa) 32 println(student2.name) 33 println(student2.gpa) 34 println(student3.name) 35 println(student3.gpa) 36} Let's look at a few lines in particular\nLine What's Happening 14 we swapped the order of the parameters; the name with a default value, comes first. (NOTE: We can no longer call the constructor without a name specified unless we name the gpa parameter in the call!) 27 We create a Student instance with positional parameters as before, but the parameter order is reversed in the constructor definition (line 9). 28 We create a Student instance without a name passed in. Note that we must name the gpa parameter, as it follows a default-valued parameter in the constructor definition. 29 We create a Student instance with named parameters as before, gpa first. When you name parameters, you can pass them in any order! Note that I do not recommend putting parameters without default values after parameters with default values; this can cause confusion, but I wanted to point out the requirement for naming in this case.\nInitializers Can Access Primary Constructor Parameters A really nice optimization is that property initializers have access to primary constructor parameters. This eliminates the need for many init blocks, as they often just initialize properties.\n1open class Person( 2 name: String = \u0026#34;No Name\u0026#34; 3) { 4 var name: String = name // direct access to primary constructor parameter 5} 6 7// NOTE PARAMETER ORDER CHANGE!!! 8class Student( 9 name: String = \u0026#34;No Name\u0026#34;, 10 gpa: Float, 11): Person(name) { 12 var gpa: Float = gpa // direct access to primary constructor parameter 13} Wow! Code reduction! Love it!\nLooking at lines 4 and 12, we reference the primary constructor parameters in the property initializers. That removes the need for a dummy initializer value, and gets rid of the init blocks. Nifty! But the next step is the biggie... (Side note - my grandmother on my mom's side always hated the word \u0026quot;biggie\u0026quot; for some reason. Trips to Wendy's were always accompanied by her cringing...)\nDefine Properties in the Primary Constructor Here's one of my favorite things about Kotlin. If your constructor is passing in values that are directly used to initialize properties, you can define the properties directly in the constructor. It's easiest to understand this in an example...\n1open class Person( 2 var name: String = \u0026#34;No Name\u0026#34; 3) 4 5class Student( 6 name: String = \u0026#34;No Name\u0026#34;, 7 var gpa: Float, 8): Person(name) Check out the terseness, but still very readable. (I'd say even more readable now, as you no longer have the duplication and required explicit association of the constructor parameters and properties.)\nBy adding var or val in front of a primary constructor parameter, you\nDefine a property for the class Initialize the property to the value passed in (or default value) Line 2 defines the name property of Person and line 8 defines the gpa property of Student.\nBecause Student inherits name from Person, we don't add var or val to name in the Student constructor; it's just a normal constructor parameter that we pass on to the superclass.\nBecause these are var properties, we can modify them the same way we did before. We could also make them val properties, in which case, once the value has been set at creation time, we cannot change it.\nYou may have noticed that we no longer have a body ({ ... }) for these classes. If everything you need to define is in the constructors, you don't need a body and can remove the curly braces!\nProperty Subsets in Constructors One last thought before I pass out or my fingers refuse to keep typing...\nSuppose we have several properties, some of which must be specified together or not at all.\nFor example, let's define a Section class that defines text in a document that may have a header and footer:\n1open class Section( 2 val text: String, 3 val header: String = \u0026#34;\u0026#34;, 4 val footer: String = \u0026#34;\u0026#34;, 5) I'd like to impose a restriction such that if we specify a header or footer, the other must also be specified.\nWe could add a check in the intializer...\n1open class Section( 2 val text: String, 3 val header: String = \u0026#34;\u0026#34;, 4 val footer: String = \u0026#34;\u0026#34;, 5) { 6 7 init { 8 if (header.isEmpty() != footer.isEmpty()) { 9 throw IllegalArgumentException(\u0026#34;Header and Footer must both be specified, or neither specified\u0026#34;) 10 } 11 } 12} 13 14fun main() { 15 val section = Section(\u0026#34;Some text\u0026#34;, \u0026#34;Section 1\u0026#34;) 16} If you run this, you'll get the IllegalArgumentException.\nBut... I really prefer to catch things at compile-time when possible. So I'd really like to have constructors that either require neither header nor footer, or both header and footer. So we add a secondary constructor and tweak the primary:\n1open class Section( 2 val text: String, 3 val header: String, 4 val footer: String, 5) { 6 7 constructor(text: String): this(text, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;) 8} 9 10fun main() { 11 val section1 = Section(\u0026#34;Some text\u0026#34;) 12 val section2 = Section(\u0026#34;Some text\u0026#34;, \u0026#34;Section 1\u0026#34;, \u0026#34;End of Section 1\u0026#34;) 13 val section3 = Section(\u0026#34;Some text\u0026#34;, \u0026#34;Section 1\u0026#34;) // will not compile 14} Our primary constructor now requires both header and footer, and the secondary only requires the text, passing the default values to the primary. Perfect!\nBut what if we have parameters that create more complex groupings?\nLet's create a very-poorly-designed class to represent a location (very-poorly-designed because we should use inheritance [and later, Kotlin's sealed classes!]). Start with\n1open class Location( 2 val lat: Double, 3 val lon: Double, 4 val street: String, 5 val city: String, 6 val state: String, 7 val zip: String, 8) Here we want to have either lat/lon, or street/city/state/zip. (Yes... this is crazy gross, but I'm tired and this demonstrates the concept and my brain won't think of another example right now so there).\nSo we try\n1open class Location( 2 val lat: Double, 3 val lon: Double, 4 val street: String, 5 val city: String, 6 val state: String, 7 val zip: String, 8) { 9 10 constructor( 11 lat : Double, 12 lon : Double, 13 ): this(lat, lon, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;) 14 15 constructor( 16 street: String, 17 city: String, 18 state: String, 19 zip: String, 20 ): this(0.0, 0.0, street, city, state, zip) 21} 22 23fun main() { 24 // good 25 val location1 = Location(39.149810, -76.911257) 26 // (sing it with me... \u0026#34;My Harris Teeter\u0026#34;) 27 28 // good 29 val location2 = Location(\u0026#34;123 Sesame St\u0026#34;, \u0026#34;New York\u0026#34;, \u0026#34;NY\u0026#34;, \u0026#34;10001\u0026#34;) 30 31 // uh oh... 32 val location3 = Location(39.149810, -76.911257, \u0026#34;123 Sesame St\u0026#34;, \u0026#34;New York\u0026#34;, \u0026#34;NY\u0026#34;, \u0026#34;10001\u0026#34;) 33} The primary constructor is public by default. In this case, we really don't want that. So let's make it private.\n1open class Location private constructor( 2 val lat: Double, 3 val lon: Double, 4 val street: String, 5 val city: String, 6 val state: String, 7 val zip: String, 8) { 9 10 constructor( 11 lat: Double, 12 lon: Double, 13 ): this(lat, lon, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;) 14 15 constructor( 16 street: String, 17 city: String, 18 state: String, 19 zip: String, 20 ): this(0.0, 0.0, street, city, state, zip) 21} 22 23fun main() { 24 // good 25 val location1 = Location(39.149810, -76.911257) 26 // (sing it with me... \u0026#34;My Harris Teeter\u0026#34;) 27 28 // good 29 val location2 = Location(\u0026#34;123 Sesame St\u0026#34;, \u0026#34;New York\u0026#34;, \u0026#34;NY\u0026#34;, \u0026#34;10001\u0026#34;) 30 31 // uh oh... 32 val location3 = Location(39.149810, -76.911257, \u0026#34;123 Sesame St\u0026#34;, \u0026#34;New York\u0026#34;, \u0026#34;NY\u0026#34;, \u0026#34;10001\u0026#34;) 33} If you run this you'll get an error compiling location3, as the constructor that takes all of those arguments is private.\nA little ugly, but poof! Private primary constructor. I haven't had to do this too often, but I have had to do it...\nLots more to cover in later articles, but it's after midnight and I need some sleep... More soon!\n","link":"https://javadude.com/post/20190203-kotlin01/","section":"post","tags":["kotlin","language"],"title":"From Java to Kotlin - Episode 1 - You've Gotta Start Somewhere..."},{"body":"","link":"https://javadude.com/tags/language/","section":"tags","tags":null,"title":"Language"},{"body":"A list of my published works, a book, articles, presentations, courses, open-source software.\nLinks are provided for active content.\nOfficial Android Documentation Gradle build overview (2024)\nAndroid build structure (2024)\nTool and library interdependencies (2024)\nGradle dependency resolution (2024)\nUpgrade build dependencies (2024)\nJava versions in Android builds (2023)\nBook Stanchfield, S. and Mauny, I. (2001). Effective VisualAge for Java, version 3. 1st ed. New York: John Wiley. Print Article Stanchfield, Scott A. \u0026quot;A Tune-Up for VisualAge for Java.\u0026quot; The VisualAge Magazine, Jan. 1998, pp. 6-9 Online Articles From Java to Kotlin - Episode 1 (2019)\nEclipse Tips (2000 - obsolete - removed)\nMVC in VisualAge for Java (2000 - obsolete - removed)\nAdvanced MVC in VisualAge for Java (2000 - obsolete - removed)\nAWT Fundamentals (2000 - was hosted at java.sun.com; no longer available)\nParsers, Part IV: A Java Cross Reference Tool (1999)\nEffective Layout Management (1999)\nANTLR Documentation (contributor) (1998)\nLayering Applications (1996)\nImport on Demand is Evil! (1996)\nJava is Pass-by-Value, Dammit! (1996)\nUsing JavaBean Accessors (1996)\nJava - Using the Right Comment (1996)\nConverting a Grammar from LALR to LL (1996)\nANTLR Tutorial (1996)\nJavaBean Property Editors (1996)\nWhy VisualAge for Java (1996 - obsolete - removed)\nPCCTS Tutorial (1996 - obsolete - removed)\nVisualAge for Java Tips and Tricks (1996 - obsolete - removed)\nConference Presentations No Fluff Just Stuff\nIntroduction to Eclipse (NFJS 2004) Eclipse Tips and Tricks (NFJS 2004) Adapter and Decorator: Tweaking Objects for Fun and Profit (NFJS 2003) Effective Interfaces (NFJS 2003) Patterns for Exception Handling (NFJS 2003) JavaOne\nCreating Custom JSP Tags (2002) Effective Layout Management (2001) Hosted VisualAge for Java BoF Session (2001) MVC for You and Me (2000) Actions: Experience and Speculation (2000) Fun with Layout Managers (2000) Courseware The Johns Hopkins University\nAndroid Mobile Development (2012-present) Kotlin (2020-present) Domain-Specific Languages (2018) Design Patterns (2002-2014) Web Development (2002) Distributed Development on the WWW (2002) XML Technologies (2002) Montgomery College, MD\nJava for Non-Programmers (2001-2002) Tier Technology Training\nServlets and Java Server Pages (2000-2001) Enterprise JavaBeans (2000-2001) DPT Consulting\nVisualAge for Java (2000) Advanced VisualAge for Java (2000) Servlets and Java Server Pages (2000) Enterprise JavaBeans (2000) MageLang Institute/jGuru.com\nAWT (1998-2000) Swing (1998-2000) VisualAge for Java (1998-2000) Advanced VisualAge for Java (1998-2000) Servlets and Java Server Pages (1998-2000) Java Users Group Presentations Johns Hopkins University Applied Physics Lab\nAndroid Mobile Development Bootcamp (2018) Kotlin Programming (2018 - 8-weeks) Tech Talk: DSLs and Code Generation (2017) Design Patterns Brown Bag Series (2015 - 7 weeks) Android Intents and Fragments (2014) Java Users Groups (APL / Columbia MD / Montgomery County MD)\nJava 8 - Lambdas and Streams (2014) Code Generation With xText and xTend (2013) Template Method and Strategy (2011) Java Dynamic Proxies (2010) Effective Eclipse (2010) Java Enumerations (2009) Java Annotations: Meta-data and Code Generation (2009) Eclipse Plug-ins 101 (2009) Northern Virginia Java Users Group\nJava Annotations: Meta-data and Code Generation (2009) ANTXR: XML Parsing Using ANTLR (2005) ANTLR: Parsing for Fun and Profit (2004) Open Source Software Bean Annotations (2008)\nEclipse Derived Warning Cleaner (2008)\nEclipse Dynamic Working Sets (2008)\nEclipse Visible Method Reporter (2008)\nEclipse Dependency Visualizer (2006)\nANTXR (XML Parser Generator) (2004)\nANTLR Eclipse Plugin (2000)\nANTLR 2.x (contributor) (1998-2000)\nParseView ANTLR Debugger (1998)\nSplitterLayout (1998)\nSwing BorderEditor (1998)\nSwing BoxBeans (1998)\nTabSplitter Bean (1998)\nVisualAge AutoGut (1998)\nVisualAge Importifier (1998)\nEclipse Jindent Integration (1998)\nSWT Layouts (1998)\n","link":"https://javadude.com/publications/","section":"","tags":null,"title":"Publications"},{"body":"A Tech Talk I gave for Johns Hopkins University June 28, 2017.\nWhat is a Domain-Specific Language? How can we use one for code-generation?\nVideo Video License DSLs and Code Generation by Scott Stanchfield is licensed under a Creative Commons Attribution-Noncommercial-No Derivative Works 3.0 United States License.\nFeel free to watch the videos and point friends to them, but you cannot use them as part of any commercial product nor can you create derivative works. Follow the link above to see the complete license text.\nSlides: DSLs and Code Generation.pdf\nSample Code Adventure Game Code: xtext-adventure-sample.zip Simple Object Model Code: simple-object-sample.zip Software License All sample code is licensed under the Eclipse Public License, version 1.0.\nSee http://www.eclipse.org/legal/epl-v10.html for details.\n","link":"https://javadude.com/post/20170628-dsls-and-codegen/","section":"post","tags":["java","xtext","eclipse","parsing","dsl"],"title":"Domain-Specific Languages (DSLs) and Code Generation"},{"body":"","link":"https://javadude.com/tags/dsl/","section":"tags","tags":null,"title":"Dsl"},{"body":"","link":"https://javadude.com/tags/eclipse/","section":"tags","tags":null,"title":"Eclipse"},{"body":"","link":"https://javadude.com/tags/java/","section":"tags","tags":null,"title":"Java"},{"body":"","link":"https://javadude.com/tags/parsing/","section":"tags","tags":null,"title":"Parsing"},{"body":"","link":"https://javadude.com/tags/xtext/","section":"tags","tags":null,"title":"Xtext"},{"body":"Talks on Gang-of-Four Design Patterns: Mediator, Observer, Javabeans, Model-View-Controller, Command, Template Method, Strategy and Null Object, Composite and Visitor, Factory Method, Abstract Factory and Builder\nThe following are brown-bag lunch talks I gave on Design Patterns at the Johns Hopkins Applied Physics Lab. This is an ongoing series and this page will be updated with new lectures over time\nVideos Session 1 - Introduction, Naive GUI, Mediator Sample Code: https://github.com/javadude/patterns.session1.git\nSession 2 - Observer, Javabeans Sample Code: https://github.com/javadude/patterns.session2.git\nSession 3 - Model-View-Controller Sample Code: https://github.com/javadude/patterns.session3.git\nSession 4 - Command Sample Code: https://github.com/javadude/patterns.session4.git\nSession 5 - Template Method, Strategy and Null Object Sample Code: https://github.com/javadude/patterns.session5.git\nSession 6 - Composite and Visitor Sample Code: https://github.com/javadude/patterns.session6.git\nSession 7 - Factory Method, Abstract Factory and Builder Sample Code: https://github.com/javadude/patterns.session7.git\nVideo License Design Patterns Brown-Bag Series by Scott Stanchfield is licensed under a Creative Commons Attribution-Noncommercial-No Derivative Works 3.0 United States License.\nFeel free to watch the videos and point friends to them, but you cannot use them as part of any commercial product nor can you create derivative works. Follow the link above to see the complete license text.\nNote that all sample code for this series is stored on github as git repositories. Each step in the lectures is tagged with STEP1, STEP2, etc. Code may be browsed on github or cloned.\nSoftware License All code is licensed under Apache 2 http://www.apache.org/licenses/LICENSE-2.0\nCopyright 2015 Scott Stanchfield\nLicensed under the Apache License, Version 2.0 (the \u0026quot;License\u0026quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026quot;AS IS\u0026quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.\n","link":"https://javadude.com/post/20151119-patterns/","section":"post","tags":["java","patterns"],"title":"Design Patterns Brown-Bag Lectures"},{"body":"","link":"https://javadude.com/tags/patterns/","section":"tags","tags":null,"title":"Patterns"},{"body":"A tech talk I gave for Johns Hopkins University on Oct 6, 2014 on Android Intents and Fragments.\n(Note - I had to rush the Fragments section b/c I didn't realize the talk was only supposed to be one hour... Sigh...)\nVideo Video License Java 8 - Lambdas and Streams by Scott Stanchfield is licensed under a Creative Commons Attribution-Noncommercial-No Derivative Works 3.0 United States License.\nFeel free to watch the videos and point friends to them, but you cannot use them as part of any commercial product nor can you create derivative works. Follow the link above to see the complete license text.\nSample Code 20141006-code-jhu-intents-fragments.zip\nSoftware License All sample code is licensed under the Eclipse Public License, version 1.0.\nSee http://www.eclipse.org/legal/epl-v10.html for details.\nAndroid icon created by Freepik - Flaticon\n","link":"https://javadude.com/post/20141006-intents-and-fragments/","section":"post","tags":["android","java"],"title":"Android Intents and Fragments"},{"body":"A Java Users Group talk from September 2014 I presented on new features in Java 8: Lambdas and Streams.\nVideo Java 8 Lambdas and Streams from Scott Stanchfield on Vimeo.\nVideo License Java 8 - Lambdas and Streams by Scott Stanchfield is licensed under a Creative Commons Attribution-Noncommercial-No Derivative Works 3.0 United States License.\nFeel free to watch the videos and point friends to them, but you cannot use them as part of any commercial product nor can you create derivative works. Follow the link above to see the complete license text.\nSample Code Code: java8-lambdas-and-streams.zip Software License All sample code is licensed under the Eclipse Public License, version 1.0.\nSee http://www.eclipse.org/legal/epl-v10.html for details.\nDuke, the Java mascot, provided by Sun Microsystems under the New BSD license.\n","link":"https://javadude.com/post/20140923-lambdas-and-streams/","section":"post","tags":["java","language"],"title":"Java 8 - Lambdas and Streams"},{"body":"","link":"https://javadude.com/tags/code-generation/","section":"tags","tags":null,"title":"Code Generation"},{"body":"A Java Users Group talk from July 2013 I presented on new features in JCode Generation with xText and xTend.\nWe'll use xText to create a custom language by specifying a grammar, read the content into a model, and generate code using xTend!\nVideo Code Generation with xText and xTend - Columbia MD Java Users Group 7/30/2013 from Scott Stanchfield on Vimeo.\nVideo License Code Generation with xText and xTend by Scott Stanchfield is licensed under a Creative Commons Attribution-Noncommercial-No Derivative Works 3.0 United States License.\nFeel free to watch the videos and point friends to them, but you cannot use them as part of any commercial product nor can you create derivative works. Follow the link above to see the complete license text.\nSample Code Code 1: xtext-talk-code.zip Code 2: xtext-talk-Sample.zip Software License All sample code is licensed under the Eclipse Public License, version 1.0.\nSee http://www.eclipse.org/legal/epl-v10.html for details.\n","link":"https://javadude.com/post/20130730-xtext/","section":"post","tags":["java","eclipse","parsing","code generation","dsl","xtext"],"title":"Code Generation with xText and xTend"},{"body":"A Java Users Group talk I presented on enumerations in Java.\nI cover:\nThe old \u0026quot;type-safe enumeration pattern\u0026quot; Using enums for values Adding data and methods to enums Using enums for the Gang-of-Four State Pattern Using enums to emulate function pointers in Java EnumSet and EnumMap Video Java Enumerations from Scott Stanchfield on Vimeo.\nVideo License Android Development in Eclipse by Scott Stanchfield is licensed under a Creative Commons Attribution-Noncommercial-No Derivative Works 3.0 United States License.\nFeel free to watch the videos and point friends to them, but you cannot use them as part of any commercial product nor can you create derivative works. Follow the link above to see the complete license text.\nSample Code jug20090527-code-enumerations.zip\nSoftware License All sample code is licensed under the Eclipse Public License, version 1.0.\nSee http://www.eclipse.org/legal/epl-v10.html for details.\nDuke, the Java mascot, provided by Sun Microsystems under the New BSD license.\n","link":"https://javadude.com/post/20121219-enumerations/","section":"post","tags":["java","language"],"title":"Java Enumerations"},{"body":"I presented a talk on the Template Method and Strategy Patterns to the Columbia, Maryland Java Users Group on 10/13/2011.\nThis page contains links to a video recording of the talk and the source code that I wrote during the talk.\nI hope you find it informative, entertaining and useful!\nVideo Template Method and Strategy Patterns from Scott Stanchfield on Vimeo.\nVideo License Dynamic Proxies by Scott Stanchfield is licensed under a Creative Commons Attribution-Noncommercial-No Derivative Works 3.0 United States License.\nFeel free to watch the videos and point friends to them, but you cannot use them as part of any commercial product nor can you create derivative works. Follow the link above to see the complete license text.\nSample Code Here is the sample code I wrote during the lecture. Note that this code is not intended for production use.\nSoftware License All sample code is licensed under the Eclipse Public License, version 1.0.\nSee http://www.eclipse.org/legal/epl-v10.html for details.\n","link":"https://javadude.com/post/20111013-template-method-and-strategy/","section":"post","tags":["java","patterns"],"title":"Template Method and Strategy"},{"body":"I presented a talk on Dynamic Proxies to the Columbia, Maryland Java Users Group on 12/02/2010.\nThis page contains links to a video recording of the talk and the source code that I wrote during the talk.\nI hope you find it informative, entertaining and useful!\nVideo Dynamic Proxies in Java from Scott Stanchfield on Vimeo.\nVideo License Dynamic Proxies by Scott Stanchfield is licensed under a Creative Commons Attribution-Noncommercial-No Derivative Works 3.0 United States License.\nFeel free to watch the videos and point friends to them, but you cannot use them as part of any commercial product nor can you create derivative works. Follow the link above to see the complete license text.\nSample Code Here is the sample code I wrote during the lecture. Note that this code is not intended for production use.\nSoftware License All sample code is licensed under the Eclipse Public License, version 1.0.\nSee http://www.eclipse.org/legal/epl-v10.html for details.\nDuke, the Java mascot, provided by Sun Microsystems under the New BSD license.\n","link":"https://javadude.com/post/20101202-dynamic-proxies/","section":"post","tags":["java","language"],"title":"Java Dynamic Proxies"},{"body":"A Java Users Group talk from May 2010 I presented on Eclipse tips and tricks.\nVideo Effective Eclipse - Columbia MD Java Users Group from Scott Stanchfield on Vimeo.\nVideo License Effective Eclipse by Scott Stanchfield is licensed under a Creative Commons Attribution-Noncommercial-No Derivative Works 3.0 United States License.\nFeel free to watch the videos and point friends to them, but you cannot use them as part of any commercial product nor can you create derivative works. Follow the link above to see the complete license text.\nThe Eclipse logo is the intellectual property of the Eclipse Foundation and cannot be altered without Eclipseâ€™s permission. They are provided for use under the Eclipse Foundation Trademark Usage Policy.\n","link":"https://javadude.com/post/20100519-effective-eclipse/","section":"post","tags":["eclipse"],"title":"Effective Eclipse"},{"body":"I presented a talk on Java Annotations to the Columbia, Maryland Java Users Group on 1/19/2010.\nThis is a very deep dive into\nAnnotation Concepts Creating annotation processors Using annotations at compile time and runtime Generating code from annotations This page contains links to a video recording of the talk and the source code that I wrote during the talk.\nI hope you find it informative, entertaining and useful!\nVideos Part 1 - Introduction Introduction to Java Annotations (what they are and why you would use them).\nJava Annotations 1 - Introduction from Scott Stanchfield on Vimeo.\n## Part 2 - Classfile Annotations Creating annotations that are kept in the generated class files but not loaded in the VM at runtime.\nJava Annotations 2 - Classfile Annotations from Scott Stanchfield on Vimeo.\n## Part 3 - Runtime Annotations 1\rExample of annotating methods with a custom @Test annotation to run in a test runner similar to junit.\nJava Annotations 3 - Runtime Annotations - Unit Tester from Scott Stanchfield on Vimeo.\nPart 4 - Runtime Annotations 2 Example of annotating methods to be used as actions that are triggered from buttons in a user interface.\nJava Annotations 4 - Runtime Annotations - UI Action Setup from Scott Stanchfield on Vimeo.\nPart 5 - Code Generation 1 Writing an annotation processor that runs at compile time to generate an RMI interface from a standard interface.\nJava Annotations 5 - Code Generation - RMI interface generation from Scott Stanchfield on Vimeo.\nPart 6 - Code Generation 2 Using an annotation processor to generate JavaBean boilerplate code.\nJava Annotations 6 - Code generation - JavaBean boilerplate generation from Scott Stanchfield on Vimeo.\nVideo License Java Annotations by Scott Stanchfield is licensed under a Creative Commons Attribution-Noncommercial-No Derivative Works 3.0 United States License.\nFeel free to watch the videos and point friends to them, but you cannot use them as part of any commercial product nor can you create derivative works. Follow the link above to see the complete license text.\nSample Code Here is the sample code I wrote during the lecture. Note that this code is not intended for production use.\nSoftware License All sample code is licensed under the Eclipse Public License, version 1.0.\nSee http://www.eclipse.org/legal/epl-v10.html for details.\nDuke, the Java mascot, provided by Sun Microsystems under the New BSD license.\n","link":"https://javadude.com/post/20100120-annotations/","section":"post","tags":["java","language"],"title":"Java Annotations"},{"body":"","link":"https://javadude.com/tags/antlr/","section":"tags","tags":null,"title":"Antlr"},{"body":"A video tutorial on ANTLR 3.x\nMany folks have asked me to convert my ANTLR 2.x tutorial to ANTLR 3.x. I started doing it and got reaaaaaaaaaalllly tired of typing. Being a bear of very little patience, I decided to go a different route, one which I think will prove even more effective. Go laziness!\nThis version of the tutorial is video-based. Using Camtasia (the best screen/video capture software in the world!) I've recorded my babbling on while creating a parser for the XL language in ANTLR 3.x in Eclipse.\nVideos I've uploaded the following videos to vimeo. Each is listed below with a short description. I recommend you watch them in order as they assume knowledge of previous videos.\nVimeo video group: http://vimeo.com/groups/29150\nConcepts - What I should have recorded first but forgot until I was 6 steps in... ANTLR 3.x Video Tutorial - Concepts from Scott Stanchfield on Vimeo.\nPrologue - Getting Eclipse set up for ANTLR 3.x development Part A: Setting up ANTLR 3.x in Eclipse 3.5 Setting up ANTLR 3.x in Eclipse 3.5 from Scott Stanchfield on Vimeo.\nPart B: Creating and Executing a Grammar in Eclipse ANTLR 3.x Creating and Executing a Grammar in Eclipse from Scott Stanchfield on Vimeo.\nCreating an XL Recognizer Part 1: Starting to implement XL ANTLR 3.x Tutorial - Part 1 from Scott Stanchfield on Vimeo.\nPart 2: Let's check out the generated code ANTLR 3.x Tutorial - Part 2 from Scott Stanchfield on Vimeo.\nPart 3: Parsing expressions ANTLR 3.x Tutorial - Part 3 from Scott Stanchfield on Vimeo.\nNOTE: I noticed I messed up the expression tree a bit. That's what I get for doing this on the fly ;) The tree for 3+2*6+4 should look like\n+\r/ \\\r+ 4\r/ \\\r3 *\r/ \\\r2 6\rPart 4: Ifs, loops, and comments ANTLR 3.x Tutorial - Part 4 from Scott Stanchfield on Vimeo.\nPart 5: Procedures and Functions ANTLR 3.x Tutorial - Part 5 from Scott Stanchfield on Vimeo.\nPart 6: Type declarations, scanner fragments, cleaning up ANTLR 3.x Tutorial - Part 6 from Scott Stanchfield on Vimeo.\nInterpreting Expressions Part 7: Interpreting expressions while parsing the input ANTLR 3.x Video Tutorial - Part 7 from Scott Stanchfield on Vimeo.\nPart 8: Interpreting expressions using the GoF Interpreter Pattern ANTLR 3.x Video Tutorial - Part 8 from Scott Stanchfield on Vimeo.\nPart 9: Interpreting expressions using an ANTLR Tree Parser ANTLR 3.x Video Tutorial - Part 9 from Scott Stanchfield on Vimeo.\nVideo License ANTLR 3.x Tutorial by Scott Stanchfield is licensed under a Creative Commons Attribution-Noncommercial-No Derivative Works 3.0 United States License.\nFeel free to watch the videos and point friends to them, but you cannot use them as part of any commercial product nor can you create derivative works. Follow the link above to see the complete license text.\nSample Code The following are snapshots of the sample code at various points during the tutorial.\nAfter part 6 (recognizer): antlr3xtut-part6.zip After part 9 (expression interpreters): antlr3xtut-part9.zip Software License All sample code is licensed under the Eclipse Public License, version 1.0.\nSee http://www.eclipse.org/legal/epl-v10.html for details.\nANTLR itself is licensed under a BSD License:\nANTLR 3 License [The BSD License] Copyright (c) 2003-2008, Terence Parr\nAll rights reserved.\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the author nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u0026quot;AS IS\u0026quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n","link":"https://javadude.com/post/20091221-antlr3tut/","section":"post","tags":["java","parsing","antlr","language","dsl"],"title":"ANTLR 3.x Tutorial"},{"body":"ANTXR: Easy XML Parsing, based on the ANTLR parser generator\nNOTE: I haven't updated this tool in many years... I'm keeping it here for historical purposes, and someday might play around with it again... It was very useful in some projects at a previous job...\nANTXR = ANother Tool for Xml Recognition Pronounce it \u0026quot;Ant-zer\u0026quot;...\nThe name is a slight modification to ANTLR (ANother Tool for Language Recognition), because ANTXR is based heavily on ANTLR.\nSource Code The source code is available at https://github.com/javadude/javadude\nLook for sub-directories *\tcom.javadude.antxr.eclipse.core *\tcom.javadude.antxr.eclipse.ui *\tcom.javadude.antxr.eclipse.feature *\tcom.javadude.antxr\nI haven't built this tool in quite a while, so I'm not sure how likely it is to build...\nLicense ANTXR is distributed under the Eclipse Public License (EPL). You can read about the concepts in plain English at Eclipse Public License (EPL) Frequently Asked Questions. This is the same license that Eclipse is currently distributed under, and you can basically use the tool for whatever purpose you would like, commercial or non-commercial, without license fee.\nDownload There are three main download types:\nEclipse: (UPDATE SITE NO LONGER EXISTS) Non-eclipse: The basic ANTXR distribution can be obtained via antxr.zip. Use the build.xml under ant-build to build antxr. To use in your own ant scripts, look at the antxr macro defined in this build.xml.\nSamples: antxr-samples.zip If you're interested in why ANTXR exists and how it got to where it is, read on. If you're only interested in some examples and how you write an ANTXR parser, feel free to jump to Writing Your XML Parser.\nAcknowledgements ANTXR is based on the public domain ANTLR Parser Generator by Terence Parr. See http://antlr.org for details on ANTLR. Many thanks to Terence Parr and all of the other ANTLR contributors (including me ;) for their work on ANTLR that has allowed me to create ANTXR.\nThe ANTXR Eclipse plugin is based on the ANTLR-Eclipse plugin at http://antlreclipse.sourceforge.net by Torsten Juergeleit. Many thanks to Torsten and the others who have contributed to the plugin.\nContents History Introduction and motivation DOM SAX Digester Keeping in synch with the XML schema Enter ANTLR-Based XML Parsing Poof! We Have ANTLR Native XML Support! Hacking ANTLR into submission Forking from ANTLR Writing Your XML Parser Scanning_XML A skeletal XML grammar The Ground Rules A Simple XML Parser A More Complex Parser Any Tags Performance Future History XML Parsing can be quite a pain the butt.\nCurrent XML parsing mechanisms have several problems, from lack of context information, to using too much memory, to requiring unwieldy if-then-else constructs or difficult to maintain reflective modeling.\nRepresenting your XML parsing rules as an ANTXR grammar can solve many of these problems, producing an effective, maintainable XML parser.\nIntroduction and motivation Note: What follows is a bunch of history, motivation, and implementation strategies. If you simply want to jump in and write an XML parser of your own, jump down to Writing Your XML Parser.\nThere are several common mechanisms for XML parsing. Let's concentrate on the \u0026quot;big two\u0026quot;: SAX and DOM. And let's not treat them too nicely. They're nasty to use...\nDOM A DOM parser rips through an XML instance document and creates a lovely little tree of evil DOM nodes. The larger your instance document, the more memory this takes, so it doesn't scale well at all. (Damn... I used a buzzword... sorry!)\nAnyway, memory is a huge issue here, and is the main reason that people report for not using DOM. But there is another significant issue: You can accidentally ignore a subtree. Think about this. You make a change to your XML schema, and change part of your DOM tree walking parser, but forget to add in exploration for part of it. Everything proceeds without a clue that you forgot that part. This can cause errors that are pretty tricky to diagnose.\nAnd don't get me started on the DOM API. Blech! Unfortunately, the DOM API that we all use has been handed down from generation to generation from someone (Al Gore claims it was he), who was either intoxicated or stoned while working on browser HTML parsing.\nSAX A nice little event-based mechanism that tells you when it sees tags and content. It does the dirty work of validation and scanning for you, but you're left to pick up the pieces as it throws you notifications. You write a handler with a single method that receives notification for any start tag. If you want to know the context in which a tag appears, it's up to you to track it. While it's pretty memory-efficient by itself, you still need to track extra information to know to which object \u0026lt;name\u0026gt; belongs.\nAnd then comes the handler...\npublic void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\rif (\u0026quot;tagA\u0026quot;.equals(localName)) {...}\relse if (\u0026quot;tagB\u0026quot;.equals(localName)) {...}\relse if (\u0026quot;tagC\u0026quot;.equals(localName)) {...}\relse if (\u0026quot;tagD\u0026quot;.equals(localName)) {...}\relse if (\u0026quot;tagE\u0026quot;.equals(localName)) {...}\r...\relse {/* error */}\r}\rJinkies! This is an accident just waiting to happen. It's nearly impossible to \u0026quot;see\u0026quot; the XML structure in there. And if you don't add the \u0026quot;anything else is an error\u0026quot; block in there, you fall into one of the same problems as DOM: you can easily forget to handle a tag.\nA variation on this handler can use reflection to call other methods or plug-in tag handlers. I'll give this an \u0026quot;A\u0026quot; for effort, but after maintaining a few parsers like these, my head explodes at the thought.\nDigester When I first saw Jakarta Digester, I was pretty impressed. Very cool little XML handler. It solves a lot of problems, including context. I was in love. But I like to think in terms of a stack when it's appropriate...\nI quickly saw confusion on the faces on others when faced with a digester rule-set. While I eat and breath stacks (I'm a compiler guy at heart), this is not the case with everyone, and digester can be incredibly confusing for many to grok. But it's a step in the right direction:\nDeclaratively specify how to process the XML. Almost like showing what the XML \u0026quot;looks like\u0026quot;. Define what to do when you match certain patterns, including context. Keep track of the context appropriately. But I think its implementation causes more confusion to new users than it's worth, and it can require a bit of work to add in those \u0026quot;special cases\u0026quot; that we all find lurking in our wonderful XML documents.\nKeeping in synch with the XML schema And here's the biggest problem, and it applies to every XML parsing technique that's commonly used. It's often very difficult to update your parser when the XML schema changes. Think about what the code looks like in a SAX, DOM, or Digester based parser. It looks nothing like the XML schema. If we could represent our parser in a form that's parallel to our schema, life would be much simpler when it comes to updating a parser to match a schema change.\nEnter ANTLR-Based XML Parsing I've been thinking about parsing XML with ANTLR for quite some time, and when some folks at my then employer, FGM, Inc, were planning an XML import refactoring, I suggested that we take a look at ANTLR.\nFor starters, I looked at XPA, which is some pretty nice XML parser support for ANTLR. This came pretty darn close to what I envisioned as an ideal XML parser, with a few exceptions:\nIt requires somewhat verbose specification. You need to specify the start and end tags explicitly, making it easy to \u0026quot;typo\u0026quot; the matching end tag. You also had to jump through a few hoops and casts to access the attributes for a tag. It has no support for namespaces. This is not an issue if you're not using namespaces, but if you do use namespaces, it's a non-starter. As a simple example of a grammar in XPA, I could write\n// XPA example grammar rules\rnote {String to, from, subject, body;}\r: noteStart:\u0026quot;\u0026lt;note\u0026gt;\u0026quot;\r{\rAttributes attributes =\r((XMLStartToken) noteStart).getAttributes();\rto = attributes.getValue(\u0026quot;to\u0026quot;);\rfrom = attributes.getValue(\u0026quot;from\u0026quot;);\r}\rsubject=subjectTag\rbody=bodyTag\r\u0026quot;\u0026lt;/note\u0026gt;\u0026quot;\r{\r// you can do whatever you want here with\r// to, from, subject and body\r}\r; subjectTag returns [String subject=null]\r:\t\u0026quot;\u0026lt;subject\u0026gt;\u0026quot;\rvalue:PCDATA {subject=value.getText();}\r\u0026quot;\u0026lt;/subject\u0026gt;\u0026quot;\r;\rbodyTag returns [String body=null]\r:\t\u0026quot;\u0026lt;body\u0026gt;\u0026quot;\rvalue:PCDATA {body=value.getText();}\r\u0026quot;\u0026lt;/body\u0026gt;\u0026quot;\r;\rThe first thing to notice here is that we have context. Rules are called from each other, and parameters can be passed and/or values returned. We could even have separate rules for \u0026quot;\u0026quot; that are referenced from other rules. For example, we could define a bookSubject and noteSubject, both of which reference the \u0026quot;\u0026quot; tag, but can have different actions. Or we could pass a parameter to the subjectTag rule that lets it know who is including it. We'll see some examples of this later.\nThe above parser requires explicit specification of the start and end tags, and a slightly awkward attribute access mechanism.\nI wanted to make things easier for my coworkers, so I downloaded the latest ANTLR source and started hacking...\nPoof! We Have ANTLR Native XML Support! The first thing I wanted was easy optional validation. It must be fast, and robust. It seemed to me that using an existing SAX parser was the best solution for this, as they're being pounded on by thousands of developers, so they'd be pretty robust, and they're pretty quick (some more so than others).\nSo we start with a SAX front-end. You choose the one you want to use and configure it turn on validation, namespace support, whatever.\nNext comes XMLTokenStream, a new class in the ANTLR distribution that acts as a hander for a SAX parser, and a source for an ANTLR parser. Because SAX is a \u0026quot;push\u0026quot; API, and ANTLR is a \u0026quot;pull\u0026quot; API, we need to form a \u0026quot;meet-in-the-middle\u0026quot; strategy. XMLTokenStream does this by supplying a blocking queue. SAX parses the XML, notifying a handler in the XMLTokenStream, and the handler creates ANTLR tokens, enqueueing them on the blocking queue. XMLTokenStream provides a nextToken() method that your ANTLR parser will call to retrieve tokens. This nextToken() method dequeues a token from the blocking queue (waiting if there isn't one available), and returns it to the ANTLR parser. Figure 1 shows this processing.\nYou can also pass a DTDHandler or EntityResolver to the XMLTokenStream, if needed, and its default handler will delegate to them.\nAt this point, we have support for validation (or not), tokenization based on the SAX parse, and feeding those tokens to a hungry ANTLR parser.\nBut what do those tokens look like?\nStart Tokens\nEach time the SAX parser notifies XMLTokenStream that it has seen a start tag, a new XMLToken is created with a type matching the tag name. (This type is defined by your parser.)\nEnd Tokens\nAssuming that we can validate, at least to ensure well-formed-ness, we only need a single type of end token. We call this type of token XML_END_TAG. Anytime the SAX parser notifies XMLTokenStream that an end tag has been seen, a new CommonToken is created of type XML_END_TAG.\nCharacter Data\nCharacter data is collected and returned as a CommonToken of type PCDATA.\nXMLToken is an extension of ANTLR's CommonToken, providing access to a tag's attribute data. The SAX attributes object is placed into this token for easy access.\nCall me a dunce...\nAt this point I should note that silly me didn't look at the source for XPA... I wanted to do a \u0026quot;clean room\u0026quot; implementation. After looking at the XPA code while writing this document, It turns out that XPA handles its processing in almost exactly the same manner as I did. It's really spooky how similar the code I wrote for the XMLTokenStream and the blocking queue is to the XPA source code. However, looking back on this, though I effectively wasted a day working on it, it helps validate that this approach is good, as two separate (and brilliant, mind you ;) ) developers came up with the same approach for parsing. My XMLTokenStream is a bit more flexible, in that you can pass your own SAX handler instance to it, allowing you to configure it for whatever validation you would like.\nHacking ANTLR into submission Next I started modifying ANTLR. I wanted to make XML processing easier. To me, this meant two things:\nDon't require the grammar writer to have to type in the start and end tags. Make attribute access easy in action code. I wanted to be able to write something like the following:\n\u0026lt;note\u0026gt;\r{ String subject, body; }\r:\tsubject=\u0026lt;subject\u0026gt;\rbody=\u0026lt;body\u0026gt;\r{doSomethingWith(@to, @from, subject, body);}\r; I quickly found out this wouldn't be possible unless I made a separate ANTLR tool for parsing XML; \u0026quot;\u0026lt;\u0026quot; and \u0026quot;\u0026gt;\u0026quot; are used for specifying element options (like which AST node to generate), which made the above cause grammar conflicts. So, I tried something a bit different:\nnoteTag options {xmlTag=\u0026quot;note\u0026quot;;}\r:\t{ String subject, body; }\rsubject=subjectTag\rbody=bodyTag\r{doSomethingWith(@to, @from, subject, body);}\r; Almost the same, but a slightly different approach. Now rule references are normal by ANTLR standards, but we've simply added two things:\nThe xmlTag option, which specifies that a rule represents an XML tag, and what the name of that tag is. The @name specification for Java action code, which is translated into the appropriate verbose nonsense to retrieve an attribute from the tag. But where are the tag token references in the above? This was the most interesting part of this ANTLR modification. If you specified xmlTag as an option, ANTLR would generate \u0026quot;ghost\u0026quot; tokens for the start and end tags. The above rule is really the same as:\nnoteTag\r:\tstart:\u0026quot;\u0026lt;note\u0026gt;\u0026quot;\r(\t// extra paren in case there were some alternatives...\r{ String subject, body, to=/*code to get \u0026quot;to\u0026quot;*/, from=/*code to get \u0026quot;from\u0026quot; */; }\rsubject=subjectTag\rbody=bodyTag\r{doSomethingWith(to, from, subject, body);}\r) // extra paren in case there were some alternatives...\rXML_END_TAG\r; These \u0026quot;ghost tokens\u0026quot; make the grammar specification much simpler, and the @name attribute references can hold off carpal tunnel syndrome for at least a few more hours...\nThe next trick was to allow easy namespace usage. I wanted to be able to use\nxmlTag=\u0026quot;foo:someTag\u0026quot;\r@foo:someAttribute\rin the grammar, where \u0026quot;foo\u0026quot; could be a grammar-writer-defined prefix for some namespace, and map that reference to the real namespace used in the XML. This would allow different XML document instances to use different prefixes. To do this, I added an xmlNamespaceMapping option, which can be specified at the grammar level, mapping a prefix to a namespace URI:\nclass NoteParser extends Parser;\roptions {\rxmlMode=true;\rxmlNamespaceMapping=\u0026quot;$DEFAULT=http://www.w3schools.com\u0026quot;;\rxmlNamespaceMapping=\u0026quot;xsi=http://www.w3.org/2001/XMLSchema-instance\u0026quot;;\r}\rThe \u0026quot;xmlMode\u0026quot; option simply sets up a few imports and a place to hold namespace mappings. The xmlNamespaceMapping option defines a prefix-\u0026gt;URI mapping. Note that I used \u0026quot;$DEFAULT\u0026quot; to represent the default namespace. I did this because\nxmlNamespaceMapping=\u0026quot;=http://www.w3schools.com\u0026quot;;\rlooked more like an error than an intentional default namespace specification. If you don't like this, ANTLR is open-source, so feel free to change it....\nWith these few constructs added to ANTLR, my fellow FGMers started to write a parser. I gave them very little overview. Instead, I gave them a simple sample parser and my ANTLR tutorial (they were both new to ANTLR). They asked a few questions, but after a few days they were very comfortable with writing XML grammars in ANTLR. This gave me the warm fuzzies that I achieved my goals...\nForking from ANTLR While the above parsers worked well, I still didn't like the syntax. I really wanted something that felt more like XML, so I decided to fork from ANTLR to create ANTXR (pronounced \u0026quot;ant-zer\u0026quot;). ANTXR has most of the syntax I really want. (I removed the above support from ANTLR itself.)\nThe following is a real (though not terribly useful) ANTXR grammar, demonstrating most of the features of ANTXR:\n01 header {\r02 package com.javadude.antxr.sample;\r03 import java.util.Hashtable;\r04 import java.io.PrintWriter;\r05 import java.io.FileWriter;\r06 }\r07 08 class NoteParser1 extends Parser;\r09 10 options {\r11 xmlns=\u0026quot;http://www.w3schools.com\u0026quot;;\r12 xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;;\r13 }\r14 15 document returns [String text=\u0026quot;\u0026quot;]\r16 :\ttext=\u0026lt;note\u0026gt; EOF\r17 ;\r18\r19 \u0026lt;note\u0026gt; returns [String text=\u0026quot;\u0026quot;]\r20 :\t{\r21 String t=null, f=null, h=null, b=null;\r22 text += \u0026quot;xsi:schemaLocation = \u0026quot; + 23 @xsi:schemaLocation + \u0026quot;\\n\u0026quot;;\r24 }\r25 t=\u0026lt;to\u0026gt;\r26 f=\u0026lt;from\u0026gt;\r27 h=\u0026lt;heading\u0026gt;\r28 b=\u0026lt;body\u0026gt;\r29 {\r30 text += \u0026quot;Note id: \u0026quot; + @id + \u0026quot;\\n\u0026quot;;\r31 text += \u0026quot;To: \u0026quot; + t + \u0026quot;\\n\u0026quot;;\r32 text += \u0026quot;From: \u0026quot; + f + \u0026quot;\\n\u0026quot;;\r33 text += \u0026quot;Subject: \u0026quot; + h + \u0026quot;\\n\u0026quot;;\r34 text += \u0026quot;----\\n\u0026quot;;\r35 text += b;\r36 }\r37 ;\r38 39 40 \u0026lt;to\u0026gt; returns [String value=\u0026quot;\u0026quot;]\r41 :\t{value = @name;}\r42 ;\r43 44 \u0026lt;from\u0026gt; returns [String value=\u0026quot;\u0026quot;]\r45 :\t{value = @name;}\r46 ;\r47 48 \u0026lt;heading\u0026gt; returns [String value=\u0026quot;\u0026quot;]\r49 :\t:PCDATA {value = pcData.getText();}\r50 ;\r51 52 \u0026lt;body\u0026gt; returns [String value=\u0026quot;\u0026quot;]\r53 :\tpcData:PCDATA {value = pcData.getText();}\r54 ;\rLet's walk through some of this example. Most of it is normal ANTLR syntax, with the following modifications:\nlines 11-12: A much more natural namespace specification. (Well, XML namespace specifications are anything but natural, but this is as natural as XML itself...). line 16: XML rules are referenced using syntax. Behind the scenes this becomes a call to __xml_ruleName(). line 19: Declaring the rule does the following: Changes the method name to __xml_note() Automatically adds a reference to the token at the beginning of the rule Automatically adds a reference to the XML_END_TAG token at the end of the rule Assigns a variable to refer to the tag so attribute references can see it. lines 23, 30, 41, 45: Attributes are referenced using @attributeName syntax. Attributes are retrieved from the start tag corresponding to the rule in which they appear. For example, the @name referred to in the rule will retrieve the name attribute of the tag that was matched in the XML input. lines 49, 53: PCDATA is a pre-defined token that represents parsed character data inside a tag. Its position corresponds to which PCDATA chunk you want to read from the tag. (Other tags can appear between PCDATA tags.) Writing Your XML Parser So now we come to the \u0026quot;how to I write an XML parser using ANTLR\u0026quot; stuff; the stuff that you actually care about and are now wondering why you just read all of the above stuff that doesn't get you any closer to having a working XML parser...\nScanning XML The first thing you need to know about writing an ANTXR parser is how the XML file is read and tokenized. There are two basic approaches here:\nSAX-Based: A SAX parser (such as Xerces or Crimson) reads the XML file, and a simple SAX handler creates ANTXR tokens for each tag and PCDATA found. These tokens are pushed into a queue where they wait to be pulled by an ANTXR-generated parser. This is a push-pull parser, requiring two threads to perform the overall parsing and a synchronization point (the blocking queue).\nXMLPULL-Based: An XMLPULL parser (such as kxml or StAX) waits to scan the XML file until the ANTXR-generated parser asks for a token. When a token is asked for, the XMLPULL parser scans for the next tag or PCDATA in the XML file, creates an ANTXR token and returns it. This is a pull parser, requiring only one thread to perform the overall parse. Each of these has benefits and drawbacks.\nThe most obvious difference is performance. The XMLPULL-based parser generally performs slightly better (assuming a reasonable XMLPULL implementation is used for the scanner.) This is due to thread synchronization.\nExecutable size is another difference, and this can depend on the runtime environment. The Java Runtime Environment includes the Crimson XML parser (SAX-based), which means you don't need any jars other than the runtime jar and the ANTXR jar for your parser. However, some XMLPULL parsers like kxml are very small (only a few kilobytes) so this isn't much of an issue.\nValidation is another difference. All of the SAX and XMLPULL based parsers will at least ensure the XML being parsed is well-formed. This allows ANTXR to be a little more efficient with regard to end tags, as all end tags can be represented by a common token type. However, if you want more than well-formedness checking, you need to examine which parser you want to use. For example:\nXerces SAX supports DTD and schema-based validation Crimson SAX (present in the JRE) supports only DTD-based validation kxml XMLPULL supports only DTD-based validation I strongly recommend that you do any desired validation with the SAX or XMLPULL validator, and keep your ANTXR parser simple, just recognizing and performing actions on the XML file.\nA skeletal XML grammar Here's a simple skeleton for an XML parser written in ANTXR.\nheader {\rpackage your.packagename;\r// any necessary import statements\r}\rclass YourParserName extends Parser;\roptions {\rxmlns=\u0026quot;http://your.default.namespace/uri\u0026quot;;\rxmlns:somePrefix=\u0026quot;http://some.namespace/uri\u0026quot;;\r}\rdocument\r:\t\u0026lt;sampleRootTag\u0026gt; EOF\r;\r\u0026lt;sampleRootTag\u0026gt;\r:\t\u0026lt;sampleTagWithAttributes\u0026gt;\r|\t\u0026lt;sampleTagWithPCDATA\u0026gt;\r;\r\u0026lt;sampleTagWithAttributes\u0026gt;\r:\t{ System.out.println(@name); }\r;\r\u0026lt;sampleTagWithPCDATA\u0026gt;\r:\tpcData:PCDATA { System.out.println(pcData.getText()); }\r;\rThis skeleton shows all you need to know to write a simple XML parser in ANTLR.\nThe Ground Rules First, we should establish some ground rules:\nEach tag in your XML file is represented by one rule in the grammar. You can have additional rules to help organize things, but in order to take advantage of the shortcuts, you must define a top-level ANTXR rule for each tag in your grammar file. We assume that if you want to validate the XML, you're using the validation options of the SAX or XMLPULL parser you're using. You could do all the validation yourself in the grammar file, but that would be much more difficult than specifying an XML schema or DTD for the validation. We assume you're familiar with XML, so when we say things like \u0026quot;namespace\u0026quot;, you know what it means. Ok, fair enough. Let's create a real XML parser in ANTXR.\nA Simple XML Parser First, let's look at a chunk of XML that we can parse:\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot;?\u0026gt;\r\u0026lt;people\u0026gt;\r\u0026lt;person ssn=\u0026quot;111-11-1111\u0026quot;\u0026gt;\r\u0026lt;firstName\u0026gt;Terence\u0026lt;/firstName\u0026gt;\r\u0026lt;lastName\u0026gt;Parr\u0026lt;/lastName\u0026gt;\r\u0026lt;/person\u0026gt;\r\u0026lt;person ssn=\u0026quot;222-22-2222\u0026quot;\u0026gt;\r\u0026lt;firstName\u0026gt;Scott\u0026lt;/firstName\u0026gt;\r\u0026lt;lastName\u0026gt;Stanchfield\u0026lt;/lastName\u0026gt;\r\u0026lt;/person\u0026gt;\r\u0026lt;person ssn=\u0026quot;333-33-3333\u0026quot;\u0026gt;\r\u0026lt;firstName\u0026gt;James\u0026lt;/firstName\u0026gt;\r\u0026lt;lastName\u0026gt;Stewart\u0026lt;/lastName\u0026gt;\r\u0026lt;/person\u0026gt;\r\u0026lt;/people\u0026gt;\rThis file defines a set of people we might want to deal with. They're all nice folks, albeit one of them is unfortunately dead, but we like them and want to interact with them. (It's my tutorial, so deal with it...)\nAnyway, we can define some rules for this example. Note that the xml file doesn't use namespaces, so we don't need to define any in the grammar.\nheader {\rpackage com.javadude.antlr.sample.xml;\r}\rclass PeopleParser extends Parser;\rdocument\r:\t\u0026lt;people\u0026gt; EOF\r;\r\u0026lt;people\u0026gt;\r:\t(\u0026lt;person\u0026gt;)*\r;\r\u0026lt;person\u0026gt; :\t(\t\u0026lt;firstName\u0026gt;\r|\t\u0026lt;lastName\u0026gt;\r)*\r;\r\u0026lt;firstName\u0026gt;\r:\tPCDATA\r;\r\u0026lt;lastName\u0026gt;\r:\tPCDATA\r;\rThis is a complete ANTXR grammar to recognize the people example. Note that the (...)* constructs used do not enforce order or cardinality! That's the job of the XML schema or DTD. The easiest way to write these in ANTXR is to simply use ANTLR's (...)* to represent \u0026quot;stuff that can appear inside this tag\u0026quot;. If you're not familiar with ANTLR syntax, please see An Antlr Tutorial (http://javadude.com/articles/antlrtut).\nAs a quick refresher:\n(...)*\nZero or more of the enclosed symbols\n(...)+\nOne or more of the enclosed symbols\n(...)?\nThe enclosed symbol is optional\nx | y\nEither x or y can appear here\n{...}\nAction code, code that gets executed at this spot in the rule\nTo run this grammar, we need some startup code. You can choose between the following scanners (all in package com.javadude.antxr.scanner)\nXMLTokenStream: The basic SAX-based XML scanner. You create and configure a SAX parser for your XML input and feed it to the XMLTokenStream. This is highly configurable, but only really necessary if you need extra flexibility.\nXMLPullTokenStream: The basic XMLPULL-based XML scanner. You create and configure an XMLPULL parser for your XML input and feed it into the XMLPullTokenStream.\nBasicCrimsonXMLTokenStream: An easy to create Crimson-based SAX scanner. You don't need any extra jars (other than antxr.jar). This is useful if you only need to specify: The XML input (as a java.io.Reader) If you want a namespace-aware parse If you want DTD validation\nBasicXercesXMLTokenStream: An easy to create Xerces-based SAX scanner. You will need the Xerces.jar in your classpath to use this option. This is useful if you only need to specify: The XML input (as a java.io.Reader) If you want a namespace-aware parse If you want validation Whether than validation is DTD or XML Schema based Here's an example:\npackage com.javadude.antxr.sample;\rimport java.io.FileReader;\rimport com.javadude.antxr.scanner.BasicCrimsonXMLTokenStream;\rpublic class PeopleTest {\rpublic static void main(String[] args) throws Exception {\r// Create our scanner (using a simple SAX parser setup)\rBasicCrimsonXMLTokenStream stream =\rnew BasicCrimsonXMLTokenStream(new FileReader(\u0026quot;people.xml\u0026quot;),\rPeopleParser.class, false, false);\r// Create our ANTLR parser\rPeopleParser peopleParser = new PeopleParser(stream);\r// parse the document\rpeopleParser.document();\r}\r}\rThis code can be nearly identical for any ANTXR-based XML parser. For this example, I used a BasicCrimsonXMLTokenStream. For it we specify the XML input (as a Reader), the parser class, false for \u0026quot;not namespace-aware\u0026quot; and false for \u0026quot;no validation\u0026quot;. (Note that well-formedness is still checked).\nThe above grammar will recognize a person.xml file, but won't really do anything with it. Suppose we want to collect information about the people into Person objects.\nSuppose I have the following Person class (a simple JavaBean):\npackage com.javadude.antlr.sample.xml;\rpublic class Person {\rprivate String ssn;\rprivate String firstName;\rprivate String lastName;\rpublic String getFirstName() {\rreturn firstName;\r}\rpublic void setFirstName(String firstName) {\rthis.firstName = firstName;\r}\rpublic String getLastName() {\rreturn lastName;\r}\rpublic void setLastName(String lastName) {\rthis.lastName = lastName;\r}\rpublic String getSsn() {\rreturn ssn;\r}\rpublic void setSsn(String ssn) {\rthis.ssn = ssn;\r}\r}\rI can tweak my grammar to collect information. In this example, we collect data and pass it upwards to the caller.\nheader {\rpackage com.javadude.antlr.sample.xml;\rimport java.util.List;\rimport java.util.ArrayList;\r}\rclass PeopleParser extends Parser;\rdocument returns [List results = null]\r:\tresults=\u0026lt;people\u0026gt; EOF\r;\r\u0026lt;people\u0026gt; returns [List results = new ArrayList()]\r{ Person p; }\r:\t(\tp=\u0026lt;person\u0026gt; { results.add(p); } )*\r;\r\u0026lt;person\u0026gt; returns [Person p = new Person()]\r{ String first, last; }\r:\t(\tfirst=\u0026lt;firstName\u0026gt; { p.setFirstName(first); }\r|\tlast=\u0026lt;lastName\u0026gt; { p.setLastName(last); }\r)*\r;\r\u0026lt;firstName\u0026gt; returns [String value = null]\r:\tpcdata:PCDATA { value = pcdata.getText(); }\r;\r\u0026lt;lastName\u0026gt; returns [String value = null]\r:\tpcdata:PCDATA { value = pcdata.getText(); }\r;\rWe now use the grammar to gather information from the XML file, create objects and return them.\nNow we can change our calling code to include\nList people = peopleParser.document();\rfor (Iterator i = people.iterator(); i.hasNext();) {\rPerson p = (Person)i.next();\rSystem.out.println(p.getFirstName() + \u0026quot; \u0026quot; + p.getLastName());\r}\rAnd poof! We have XML data converted to Person objects quite easily!\nA More Complex Parser Here's an example I presented at the Northern Virginia Java Users Group. It's a little more interesting, as it demonstrates a mix of returning values to callers and passing values into called rules. There's no \u0026quot;right way\u0026quot; to do this, but try to think about who needs to know what.\nThis example creates a simple GUI using an XML specification. There are some points where you really need to pass data down vs. up. For example, a container needs to pass itself down to the layout manager so the layout constraint tags can add their components in the right location.\nNote that this is not intended to be a framework for real use; it's a simple example of how powerful ANTXR parsing can be.\nFirst, let's look at the XML we want to parse:\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot;?\u0026gt;\r\u0026lt;frame\u0026gt;\r\u0026lt;borderLayout\u0026gt;\r\u0026lt;north\u0026gt;\r\u0026lt;panel\u0026gt;\r\u0026lt;borderLayout\u0026gt;\r\u0026lt;west\u0026gt;\r\u0026lt;panel\u0026gt;\r\u0026lt;gridLayout rows=\u0026quot;0\u0026quot; cols=\u0026quot;1\u0026quot;\u0026gt;\r\u0026lt;label text=\u0026quot;Name\u0026quot;/\u0026gt;\r\u0026lt;label text=\u0026quot;Address\u0026quot;/\u0026gt;\r\u0026lt;/gridLayout\u0026gt;\r\u0026lt;/panel\u0026gt;\r\u0026lt;/west\u0026gt;\r\u0026lt;center\u0026gt;\r\u0026lt;panel\u0026gt;\r\u0026lt;gridLayout rows=\u0026quot;0\u0026quot; cols=\u0026quot;1\u0026quot;\u0026gt;\r\u0026lt;textField /\u0026gt;\r\u0026lt;textField /\u0026gt;\r\u0026lt;/gridLayout\u0026gt;\r\u0026lt;/panel\u0026gt;\r\u0026lt;/center\u0026gt;\r\u0026lt;/borderLayout\u0026gt;\r\u0026lt;/panel\u0026gt;\r\u0026lt;/north\u0026gt; \u0026lt;south\u0026gt;\r\u0026lt;panel\u0026gt;\r\u0026lt;flowLayout align=\u0026quot;RIGHT\u0026quot;\u0026gt;\r\u0026lt;button text=\u0026quot;Ok\u0026quot;\u0026gt;\r\u0026lt;printAction\u0026gt;Done!\u0026lt;/printAction\u0026gt;\r\u0026lt;/button\u0026gt;\r\u0026lt;button text=\u0026quot;Cancel\u0026quot;\u0026gt;\r\u0026lt;printAction\u0026gt;Canceled!\u0026lt;/printAction\u0026gt;\r\u0026lt;/button\u0026gt;\r\u0026lt;/flowLayout\u0026gt;\r\u0026lt;/panel\u0026gt;\r\u0026lt;/south\u0026gt;\r\u0026lt;/borderLayout\u0026gt;\r\u0026lt;/frame\u0026gt;\rThis is a silly little name \u0026amp; address form, with an Ok and Cancel button. We can parse the above XML file with the following ANTXR grammar:\nheader {\rpackage com.javadude.antxr.sample;\rimport java.awt.*;\rimport java.awt.event.*;\rimport javax.swing.*;\r}\r// A sample parser that generates a Java GUI based on an XML specification\rclass GUIParser extends Parser;\rdocument returns [JFrame f=null] :\tf=\u0026lt;frame\u0026gt; EOF\r;\r/**\r* Create a JFrame based on a frame tag\r* @return the generated JPanel\r*/\r\u0026lt;frame\u0026gt; returns [JFrame f=null] { f = new JFrame(@title); }\r:\tlayout[f.getContentPane()]\r{\rf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\rf.pack();\r}\r;\r/**\r* Create a JPanel based on a panel tag\r* @return the generated JPanel\r*/\r\u0026lt;panel\u0026gt; returns [JPanel p=new JPanel()] :\tlayout[p]\r;\r/**\r* Recognizes layout managers\r* @param container the container to which we add the layout manager\r*/\rlayout [Container container]\r:\t\u0026lt;borderLayout\u0026gt;[container]\r|\t\u0026lt;flowLayout\u0026gt;[container]\r|\t\u0026lt;gridLayout\u0026gt;[container]\r;\r/**\r* Create BorderLayout for the borderLayout tag\r* @param container the container to which we add the layout manager\r*/\r\u0026lt;borderLayout\u0026gt; [Container container]\r{ container.setLayout(new BorderLayout()); }\r:\t( \u0026lt;north\u0026gt;[container]\r|\t\u0026lt;south\u0026gt;[container]\r|\t\u0026lt;east\u0026gt;[container]\r|\t\u0026lt;west\u0026gt;[container]\r|\t\u0026lt;center\u0026gt;[container]\r)*\r;\r/**\r* Add the nested component to the container at the \u0026quot;north\u0026quot; position\r* @param container the container to which we add the nested component\r*/\r\u0026lt;north\u0026gt; [Container container]\r{ Component c; }\r:\tc=component {container.add(c, BorderLayout.NORTH); }\r;\r/**\r* Add the nested component to the container at the \u0026quot;south\u0026quot; position\r* @param container the container to which we add the nested component\r*/\r\u0026lt;south\u0026gt; [Container container]\r{ Component c; }\r:\tc=component {container.add(c, BorderLayout.SOUTH); }\r;\r/**\r* Add the nested component to the container at the \u0026quot;east\u0026quot; position\r* @param container the container to which we add the nested component\r*/\r\u0026lt;east\u0026gt; [Container container]\r{ Component c; }\r:\tc=component {container.add(c, BorderLayout.EAST); }\r;\r/**\r* Add the nested component to the container at the \u0026quot;west\u0026quot; position\r* @param container the container to which we add the nested component\r*/\r\u0026lt;west\u0026gt; [Container container]\r{ Component c; }\r:\tc=component {container.add(c, BorderLayout.WEST); }\r;\r/**\r* Add the nested component to the container at the \u0026quot;center\u0026quot; position\r* @param container the container to which we add the nested component\r*/\r\u0026lt;center\u0026gt; [Container container]\r{ Component c; }\r:\tc=component {container.add(c, BorderLayout.CENTER); }\r;\r/**\r* Create FlowLayout for the flowLayout tag\r* @param container the container to which we add the layout manager\r*/\r\u0026lt;flowLayout\u0026gt; [Container container]\r{\rint alignment = FlowLayout.CENTER;\rString align = @align;\rif (align != null)\rif (\u0026quot;RIGHT\u0026quot;.equals(align))\ralignment = FlowLayout.RIGHT;\relse if (\u0026quot;LEFT\u0026quot;.equals(align))\ralignment = FlowLayout.LEFT;\relse if (\u0026quot;CENTER\u0026quot;.equals(align))\ralignment = FlowLayout.CENTER;\rcontainer.setLayout(new FlowLayout(alignment));\rComponent c;\r}\r:\t( c=component {container.add(c);} )*\r;\r/**\r* Create GridLayout for the gridLayout tag\r* @param container the container to which we add the layout manager\r*/\r\u0026lt;gridLayout\u0026gt; [Container container]\r{\rint rows = Integer.parseInt(@rows);\rint cols = Integer.parseInt(@cols);\rcontainer.setLayout(new GridLayout(rows,cols));\rComponent c;\r}\r:\t(\tc=component {container.add(c);} )*\r;\r/**\r* Recognize a component\r* @return the component created based on an xml spec\r*/\rcomponent returns [Component component=null]\r:\tcomponent=\u0026lt;button\u0026gt;\r|\tcomponent=\u0026lt;label\u0026gt;\r|\tcomponent=\u0026lt;textField\u0026gt;\r|\tcomponent=\u0026lt;panel\u0026gt;\r;\r/**\r* Create a JButton based on a \u0026quot;button\u0026quot; xml tag\r* @return the created JButton\r*/\r\u0026lt;button\u0026gt; returns [JButton b=new JButton()]\r{ b.setText(@text); }\r:\t(\u0026lt;printAction\u0026gt;[b])?\r;\r/**\r* Create a JLabel based on a \u0026quot;label\u0026quot; xml tag\r* @return the created JLabel\r*/\r\u0026lt;label\u0026gt; returns [JLabel l=new JLabel()]\r{ l.setText(@text); }\r: ;\r/**\r* Create a JTextField based on a \u0026quot;textField\u0026quot; xml tag\r* @return the created JTextField\r*/\r\u0026lt;textField\u0026gt; returns [JTextField t=new JTextField()]\r{ t.setText(@text); }\r: ;\r/**\r* Create an ActionListener that prints the data in a \u0026quot;printAction\u0026quot; xml tag\r* @param b the button to which we add the listener\r*/\r\u0026lt;printAction\u0026gt;[JButton b]\r:\tpcData:PCDATA {\rfinal String value = pcData.getText();\rb.addActionListener(\rnew ActionListener() {\rpublic void actionPerformed(ActionEvent e) {\rSystem.out.println(value);\r}});\r}\r; Note that this grammar demonstrates several things:\nPassing data down and up\nThat things like components are passed back to their caller, which is usually a layout constraint. This allows the layout constraint to decide how to add that component. The container is passed down to the layout constraint. This is much simpler than passing back \u0026quot;north\u0026quot; (or some other representation of a constraint) back to the container rule for it to determine how to add the component.\n**Use of rules that do not represent tags\n**Check out the component and layout rules. These rules are simply there to make our lives easier, as we can logically represent the contents of a tag via a single rule, and let that new rule be used in more than one place. (For example, layout is used in both panel and frame, and this prevents us from having to specify all of the possible layouts under both panel and frame.\nConverting some attribute values to numbers\nThis is something I'd like to make easier, but for now, you'll have to live with it. Attributes are strings, and if you want them in another form such as ints, you'll need to do the conversion. \u0026quot;Any\u0026quot; Tags ANTXR allows use of the \u0026quot;any\u0026quot; tag in XML schema. This feature allows your XML to be extensible, but can make parsing a bit trickier. To use the \u0026quot;any\u0026quot; feature, simply use OTHER_TAG as a token in your grammar and match it with an XML_END_TAG token. For example:\notherTag\r:\tOTHER_TAG\r(\totherTag\r|\tfoo\r|\tfee\r|\tPCDATA\r)*\rXML_END_TAG\r;\rAnytime the scanner sees an XML tag that you haven't explicitly defined using xmlTag in your grammar, it checks to see if you used OTHER_TAG. If you used OTHER_TAG in your grammar, it will be returned for any tag you didn't explicitly specify. If you didn't use OTHER_TAG in your grammar, you will get a syntax error. I recommend defining the grammar as expicitly as possible, and avoiding OTHER_TAG unless absolutely necessary.\nI'm working on some lighter syntax for this.\nUsing the ANTXR Plugin for Eclipse (I need to write more on this, but this is a quick start. The ANTXR plugin is nearly identical to the ANTLR plugin for eclipse at http://antlreclipse.sourceforge.net. Please read that page for the basic usage. You can download the ANTXR plugin as noted at the top of this page.)\nThe main differences between the ANTXR plugin and the ANTLR plugin are names:\nYou use the \u0026quot;Toggle ANTXR nature\u0026quot; option instead of \u0026quot;Toggle ANTLR nature\u0026quot;. You must name your grammars foo.antxr instead of foo.g. Performance I'm working with some testers to try and get a few good performance tests set up. Initial tests have shown the ANTXR approach to be comparable to an equivalent SAX-based implementation (sometimes slightly faster, sometimes slightly slower, but so close we cannot be decisive.) When a full comparison has been completed, I'll post the results.\nFuture The next big thing I want to add to this is the ability to generate an ANTXR grammar from an XML Schema or DTD.\nI also want to release a J2ME-friendly version of ANTXR.\n","link":"https://javadude.com/post/20051102-antxr/","section":"post","tags":["java"],"title":"ANTXR"},{"body":"","link":"https://javadude.com/categories/tools/","section":"categories","tags":null,"title":"Tools"},{"body":"There should never exist any language feature such that adding a new type to a referenced package can break your existing code. Import-on-demand (aka \u0026quot;start imports\u0026quot;) is one such feature... And it's evil...\nFor example:\n1import a.b.*; // your package 2import x.y.*; // 3rd-party code 3 4class Foo { 5 Bar bar; 6 ... 7} Suppose that to start with, only a.b.Bar exists. You compile and check-in your code and all's fine.\nThis code has a Bus Number of one...\nA year later, after you've been hit by said bus and there have been some updates to the jars containing a.b or x.y, someone needs to make a mod. They check out the code and start cursing you because you had the nerve to check in code that doesn't compile.\nBut you did check in compiling code! Turns out, the 3rd party lib you were using is now version 2 and includes class x.y.Bar. Worse, maybe Bar is similar to your Bar, making it even more difficult to determine which Bar you actually intended.\nThe Big Bang This is language design at its worst, and Sun made this blow up in everyone's face between JDK 1.1 and 1.2. In 1.1, there existed java.awt.List. Tons of folks wrote code that included\n1import java.util.*; 2import java.awt.*; I can't begin to count the number of code examples that contained those two lines). If you used List in your class, like\n1List choices = new List(); Your code compiled fine in 1.1, but a runtime lib upgrade to Java 1.2 breaks your code!\nBTW: Sun knew and announced this would happen. They should have created java.util.collections.List instead of java.util.List to prevent it. It forced lots of people to change existing code for no gain.\nI've seen and heard of this happening again and again and again. Explicit imports make this all go away.\nWhen I taught Java for MageLang Institute (now jGuru.com), my compromise advice was always \u0026quot;use import-on-demand when developing, then fix it before checking in.\u0026quot; I wrote a tool called \u0026quot;Importifier\u0026quot; for VisualAge for Java that did this expansion automatically. Fortunately, it's in Eclipse, so I didn't have to port it.\nTools can help! With today's tools (like Eclipse and IDEA), there's never an excuse to use import on demand. You can easily expand imports, removing any possibility of this nasty problem. Even better, Eclipse at leastÂ automatically adds the imports if you use code completion. I haven't written \u0026quot;import\u0026quot; when coding in nearly three years! (What I mean by this is that for anything other than simple demos, I let Eclipse generate all of my imports just by using code completion.)\n\u0026quot;Import on demand saves time\u0026quot; is not a valid argument. And if you're one of those \u0026quot;You're not a real programmer if you use an IDE\u0026quot; types, I truly pity your stubbornness and dedication to making life so much harder on yourself...\nBTW: As for performance, there's a minor gain in speed at compile time using explicit imports (the compiler doesn't have to check all \u0026quot;*\u0026quot; imports to check which applies, but it's nearly unnoticeable). However, there is absolutely no difference at runtime. In case you don't know, all class name references are fully-resolved at compile time and hard-coded into the .class file. Of course this doesn't apply to reflection.\nDuke, the Java mascot, provided by Sun Microsystems under the New BSD license.\n","link":"https://javadude.com/post/20040522-import-on-demand-is-evil/","section":"post","tags":["java","language"],"title":"Import on Demand is EVIL!"},{"body":"","link":"https://javadude.com/tags/design/","section":"tags","tags":null,"title":"Design"},{"body":"I'm really tired of hearing folks incorrectly state \u0026quot;primitives are passed by value, objects are passed by reference\u0026quot;.\nSo I'm gonna rant, and you're gonna listen...\nI'm a compiler guy at heart. The terms \u0026quot;pass-by-value\u0026quot; semantics and \u0026quot;pass-by-reference\u0026quot; semantics have very precise definitions, and they're often horribly abused when folks talk about Java. I want to correct that... The following is how I'd describe these\nPass-by-value The actual parameter (or argument expression) is fully evaluated and the resulting value is copied into a location being used to hold the formal parameter's value during method/function execution. That location is typically a chunk of memory on the runtime stack for the application (which is how Java handles it), but other languages could choose parameter storage differently.\nPass-by-reference The formal parameter merely acts as an alias for the actual parameter. Anytime the method/function uses the formal parameter (for reading or writing), it is actually using the actual parameter.\nJava is strictly pass-by-value, exactly as in C. Read the Java Language Specification (JLS). It's spelled out, and it's correct. In https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.1:\nWhen the method or constructor is invoked (Â§15.12), the values of the actual argument expressions initialize newly created parameter variables, each of the declared type, before execution of the body of the method or constructor. The Identifier that appears in the FormalParameter may be used as a simple name in the body of the method or constructor to refer to the formal parameter.\nNote: In the above, values is my emphasis, not theirs\nSection 15.12.4.2 (https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.12.4.2) states:\nThe argument expressions (possibly rewritten as described above) are now evaluated to yield argument values. Each argument value corresponds to exactly one of the method's n formal parameters.\nIn short: Java has pointers and is strictly pass-by-value. There are no special rules. It's simple, clean, and clear. (Well, as clear as the evil C++-like syntax will allow ;)\nNote: See the note at the end of this article, \u0026quot;A Note on Remote Method Invocation\u0026quot;, for the semantics of remote method invocation (RMI). What is typically called \u0026quot;pass by reference\u0026quot; for remote objects is actually incredibly bad semantics.\nThe Litmus Test There's a simple \u0026quot;litmus test\u0026quot; for whether a language supports pass-by-reference semantics:\nCan you write a traditional swap(a,b) method/function in the language?\nA traditional swap method or function takes two arguments and swaps them such that variables passed into the function are changed outside the function. Its basic structure looks like\n1swap(Type arg1, Type arg2) { 2 Type temp = arg1; 3 arg1 = arg2; 4 arg2 = temp; 5} If you can write such a method/function in your language such that calling\n1Type var1 = ...; 2Type var2 = ...; 3swap(var1,var2); actually switches the values of the variables var1 and var2, the language supports pass-by-reference semantics.\nFor example, in Pascal, you can write\n1procedure swap(var arg1, arg2: SomeType); 2var 3 temp : SomeType; 4begin 5 temp := arg1; 6 arg1 := arg2; 7 arg2 := temp; 8end; 9 10... 11 12{ in some other procedure/function/program } 13 14var 15 var1, var2 : SomeType; 16 17begin 18 var1 := ...; { value \u0026#34;A\u0026#34; } 19 var2 := ...; { value \u0026#34;B\u0026#34; } 20 swap(var1, var2); 21 { now var1 has value \u0026#34;B\u0026#34; and var2 has value \u0026#34;A\u0026#34; } 22end; or in C++ you could write\n1void swap(SomeType\u0026amp; arg1, Sometype\u0026amp; arg2) { 2 SomeType temp = arg1; 3 arg1 = arg2; 4 arg2 = temp; 5} 6 7... 8 9SomeType var1 = ...; // value \u0026#34;A\u0026#34; 10SomeType var2 = ...; // value \u0026#34;B\u0026#34; 11swap(var1, var2); // swaps their values! 12// now var1 has value \u0026#34;B\u0026#34; and var2 has value \u0026#34;A\u0026#34; (Please let me know if my Pascal or C++ has lapsed and I've messed up the syntax...)\nBut you cannot do this in Java!\nNow the details The problem we're facing here is statements like\nIn Java, Objects are passed by reference, and primitives are passed by value.\nThis is half incorrect. Everyone can easily agree that primitives are passed by value; there's no such thing in Java as a pointer/reference to a primitive.\nHowever, Objects are not passed by reference. A correct statement would be Object references are passed by value.\nThis may seem like splitting hairs, but it is far from it. There is a world of difference in meaning. The following examples should help make the distinction.\nIn Java, take the case of\n1public void foo(Dog d) { 2 d = new Dog(\u0026#34;Fifi\u0026#34;); // creating the \u0026#34;Fifi\u0026#34; dog 3} 4 5Dog aDog = new Dog(\u0026#34;Max\u0026#34;); // creating the \u0026#34;Max\u0026#34; dog 6 7// at this point, aDog points to the \u0026#34;Max\u0026#34; dog 8 9foo(aDog); 10 11// aDog still points to the \u0026#34;Max\u0026#34; dog the variable passed in, aDog, is not modified! After calling foo(), aDog still points to the Dog with name \u0026quot;Max\u0026quot;!\nMany people mistakenly think/state that something like\n1public void foo(Dog d) { 2 d.setName(\u0026#34;Fifi\u0026#34;); 3} shows that Java does in fact pass objects by reference.\nThe mistake they make is in the definition of\n1Dog d; itself. When you write that definition, you are defining a pointer to a Dog object, not a Dog object itself.\nOn Pointers versus References... The problem here is that the folks at Sun made a naming mistake.\nIn programming language design, a \u0026quot;pointer\u0026quot; is a variable that indirectly tracks the location of some piece of data. The value of a pointer is often the memory address of the data you're interested in. Some languages allow you to manipulate that address; others do not.\nA \u0026quot;reference\u0026quot; is an alias to another variable. Any manipulation done to the reference variable directly changes the original variable.\nCheck out the second sentence of https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.3.1.\nThe reference values (often just references) are pointers to these objects, and a special null reference, which refers to no object.\nThey explicitly say \u0026quot;pointers\u0026quot; in their description... Interesting...\nWhen they were originally creating Java, they had \u0026quot;pointer\u0026quot; in mind (you can see some remnants of this in classes like NullPointerException).\nSun wanted to push Java as a secure language, and one of Java's advantages was that it does not allow pointer arithmetic as C++ does.\nThey went so far as to try a different name for the concept, formally calling them \u0026quot;references\u0026quot;. A huge mistake and it's caused even more confusion in the process.\nThere's an excellent explanation of reference variables at http://www.cprogramming.com/tutorial/references.html. It's C++ specific, but it properly says the concept of a true reference variable.\nThe word \u0026quot;reference\u0026quot; in programming language design originally comes from how you pass data to subroutines/functions/procedures/methods. A reference parameter is an alias to a variable passed as a parameter.\nIn the end, Sun made a naming mistake that's caused confusion. Java has pointers, and once you accept that, it makes the way Java behaves make much more sense.\nCalling Methods Calling\n1foo(d); passes the value of d to foo(); it does not pass the object that d points to!\nThe value of the pointer being passed is similar to a memory address. Under the covers it may be a tad different, but from a programmer's perspective, you can think of it in exactly the same way. The value uniquely identifies some object on the heap.\nHowever, it makes no difference how pointers are implemented under the covers. You program with them exactly the same way in Java as you would in C or C++. The syntax is just slightly different (another poor choice in Java's design; they should have used the same -\u0026gt; syntax for de-referencing as C++).\nIn Java,\n1Dog d; is exactly like C++'s\n1Dog *d; And using\n1d.setName(\u0026#34;Fifi\u0026#34;); is exactly like C++'s\n1d-\u0026gt;setName(\u0026#34;Fifi\u0026#34;); To sum up: Java has pointers, and the value of the pointer is passed in. There's no way to actually pass an object itself as a parameter. You can only pass a pointer to an object.\nKeep in mind, when you call\n1foo(d); you're not passing an object; you're passing a pointer to the object.\nFor a slightly different (but still correct) take on this issue, please see Praxis 1 in Peter Haggar's excellent book, Practical Java: https://books.google.com/books?id=iWPeqljHNcoC\u0026amp;lpg=PP1\u0026amp;pg=PA1.\nA Note on Remote Method Invocation (RMI) When passing parameters to remote methods, things get a bit more complex. First, we're (usually) dealing with passing data between two independent virtual machines, which might be on separate physical machines as well. Passing the value of a pointer wouldn't do any good, as the target virtual machine doesn't have access to the caller's heap.\nYou'll often hear \u0026quot;pass by value\u0026quot; and \u0026quot;pass by reference\u0026quot; used with respect to RMI. These terms have more of a \u0026quot;logical\u0026quot; meaning, and really aren't correct for the intended use.\nHere's what is usually meant by these phrases with regard to RMI. Note that this is not proper usage of \u0026quot;pass by value\u0026quot; and \u0026quot;pass by reference\u0026quot; semantics:\nRMI \u0026quot;Pass-by-value\u0026quot; The actual parameter is serialized and passed using a network protocol to the target remote object. Serialization essentially \u0026quot;squeezes\u0026quot; the data out of an object/primitive. On the receiving end, that data is used to build a \u0026quot;clone\u0026quot; of the original object or primitive. Note that this process can be rather expensive if the actual parameters point to large objects (or large graphs of objects).\nThis isn't quite the right use of \u0026quot;pass-by-value\u0026quot;; I think it should really be called something like \u0026quot;pass-by-memento\u0026quot;. (See \u0026quot;Design Patterns\u0026quot; by Gamma et al for a description of the Memento pattern).\nRMI \u0026quot;Pass-by-reference\u0026quot; The actual parameter, which is itself a remote object, is represented by a proxy. The proxy keeps track of where the actual parameter lives, and anytime the target method uses the formal parameter, another remote method invocation occurs to \u0026quot;call back\u0026quot; to the actual parameter. This can be useful if the actual parameter points to a large object (or graph of objects) and there are few call backs.\nThis isn't quite the right use of \u0026quot;pass-by-reference\u0026quot; (again, you cannot change the actual parameter itself). I think it should be called something like \u0026quot;pass-by-proxy\u0026quot;. (Again, see \u0026quot;Design Patterns\u0026quot; for descriptions of the Proxy pattern).\nFollow up from stackoverflow.com I posted the following as some clarification when a discussion on this article arose on https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value/73021#73021.\nThe Java Spec says that everything in java is pass-by-value. There is no such thing as \u0026quot;pass-by-reference\u0026quot; in java.\nThe key to understanding this is that something like\n1Dog myDog; is not a Dog; it's actually a pointer to a Dog.\nWhat that means, is when you have\n1Dog myDog = new Dog(\u0026#34;Rover\u0026#34;); 2foo(myDog); you're essentially passing the address of the created Dog object to the foo method. (I say essentially b/c java pointers aren't direct addresses, but it's easiest to think of them that way)\nSuppose the Dog object resides at memory address 42. This means we pass 42 to the method.\nIf the Method were defined as\n1public void foo(Dog someDog) { // AAA 2 someDog.setName(\u0026#34;Max\u0026#34;); // BBB 3 someDog = new Dog(\u0026#34;Fifi\u0026#34;); // CCC 4 someDog.setName(\u0026#34;Rowlf\u0026#34;); // DDD 5} Let's look at what's happening.\nline AAA\nthe parameter someDog is set to the value 42 line BBB\nsomeDog is followed to the Dog it points to (the Dog object at address 42)\nthat Dog (the one at address 42) is asked to change his name to \u0026quot;Max\u0026quot;\nline CCC\na new Dog is created. Let's say he's at address 74. we assign the parameter someDog to that address, 74 line DDD\nsomeDog is followed to the Dog it points to (the Dog object at address 74) that Dog (the one at address 74) is asked to change his name to \u0026quot;Rowlf\u0026quot; Now let's think about what happens outside the method:\nDid myDog change?\nThere's the key.\nKeeping in mind that myDog is a pointer, and not an actual Dog, the answer is NO. myDog still has the value 42; it's still pointing to the original Dog.\nIt's perfectly valid to follow an address and change what's at the end of it; that does not change the variable, however.\nJava works exactly like C. You can assign a pointer, pass the pointer to a method, follow the pointer in the method and change the data that was pointed to. However, you cannot change where that pointer points.\nIn C++, Ada, Pascal and other languages that support pass-by-reference, you can actually change the variable that was passed.\nIf Java had pass-by-reference semantics, the foo method we defined above would have changed where myDog was pointing when it assigned someDog on line CCC.\nThink of reference parameters as being aliases for the variable passed in. When that alias is assigned, so is the variable that was passed in.\nDuke, the Java mascot, provided by Sun Microsystems under the New BSD license.\n","link":"https://javadude.com/post/20010516-pass-by-value/","section":"post","tags":["java","language"],"title":"Java is Pass-by-Value, Dammit!"},{"body":"Maintainable applications can be quite tricky to develop. One of the keys to creating such a beast, is to properly layer your application.\nSeparation is the key to maintainability. The more separate the parts of your application are, the lower the coupling between them, and changes to the guts of one part have less (or optimally no) effect on the rest of the application.\nYour biggest enemy in the quest for a maintainable application is direct communication.\nLet's get one thing out of the way right up front. Never talk directly to an EJB. I don't care what Sun or IBM says.\nReason? Simple. EJB is a technology, not a component in your application.\nWhat are application components? Think of your application as having components, similar to a stereo. We're not talking GUI Widgets here (AWT Components), we're talking about sizeable chunks of your application.\nThere are several benefits to a component stereo system:\nYou can build it up starting with a few pieces and add more pieces over time. If a piece breaks, you can replace it or repair it without affecting the rest of the system. You can choose any receiver, any CD player, any equalizer, or even any record player, mixing and matching to create your system. If a better component comes along, you can replace just that component without affecting the rest of the system. Brilliant idea, eh?\nWe can apply this concept to software with some amazing results:\nYou can build it up starting with a few pieces and add more pieces over time.\nCan you say \u0026quot;lower startup cost, faster time to delivery?\u0026quot; If you only need part of the application, you can just concentrate on that part if you think in terms of components.\nIf a piece breaks, you can replace it or repair it without affecting the rest of the system.\nFace it, when you fix a bug, there's a good chance that you'll break something else. The more isolated/standalong your components are, the better chance that impacts remain local to the place you changed, making them easier to notice beforehand and fix if found later.\nYou can choose any receiver, any CD player, any equalizer, or even any record player, mixing and matching to create your system.\nThink \u0026quot;technologies\u0026quot; here. We can use any presentation technology, like an AWT GUI or a JavaServer Page (JSP). We can use any data management technology (EJB Entity beans, direct database access with JDBC.)\nIf a better component comes along, you can replace just that component without affecting the rest of the system.\nSuppose tomorrow \u0026quot;Schmoo\u0026quot; becomes available. \u0026quot;Schmoo\u0026quot; is the newest, bestest, fastest, coolest, data management technology ever. (Kinda like folks are pushing EJB right now.) Wouldn't it be great to just replace the data management component with one that uses Schmoo instead of EJB?\nThe key here is isolation. The more isolated your components, the more real the benefits become.\nAnd what makes this possible?\nInterfaces are the key Think about what makes a component stereo work so well, or how we can use the same spark plugs in a Pacer (forgot about that, eh?) and a Rolls Royce.\nThe interface between the components is what makes it possible!\nComponents in a stereo use a common interface: RCA jacks and obfuscated setup manuals. Cars use common interfaces for their components as well, such as the threading and contacts for a spark plug.\nIn the same manner, interfaces are the key to separation in your application. If you have two components that need to talk with one another, define one or more interfaces to lock down that communication. Once you have the interfaces in place, it doesn't matter what the components actually are or do, as long as they respect that communication!\nThink about this for a moment. Suppose we define:\n1public interface Customer { 2 public String getName(); 3 public void setName(String name); 4 ... 5} 6 7public interface CustomerManager { 8 public Customer load(int id); 9 public Customer store(Customer customer); 10 public Customer[] findByName(String namePattern); 11 public Customer createCustomer(String name, float creditLimit); 12 public void deleteCustomer(Customer customer); 13} Notice how this does not say anything about how or where the customer is stored. All we're doing here is specifying the basic CRUD (Create, Read, Update, Delete) operations that you need for a piece of data.\nWow, I can reuse things! Sorry, bud, you missed the point...\nI've often heard phrases like \u0026quot;software is like cars; you can reuse spark plugs, pistons, even the whole engine.\u0026quot;\nCan you say \u0026quot;apples and oranges\u0026quot;?\nSure, if all I wrote were personal information manager applications, I could reuse the notepad, address book and email components constantly. But do I really write the same type of application more than once??? Of course not!\n(Note: Reusing things like MS Excel inside Word isn't a new type of app... they are both \u0026quot;office apps\u0026quot;)\nSo why are components good, if not for reuse? Think about stereos, refrigerators, and cars.\nIf you examine them at a microscopic level, they all reuse molecules. Go up a bit farther, and they all share transistors, but as your components grow bigger, they become more domain specific. Domain-specific components can really only be used in one type of application. You can't take your car's engine and use it to build a fridge.\nSmall enough components, like GUI Widgets, and data structures like Java's Vector and Hashtable, are incredibly reusable. But that's really low level.\nThinking of application components, the real benefit is in the upgrade and repair department, not the cross-application reuse department.\nIf you had separated your application into components, and one of those components is a CustomerManager (defined as the interface above), you're in great shape. Suppose your initial CustomerManager implementation uses JDBC calls to store and retrieve data. If you want to upgrade to EJB, all you'd need to do is change the implementation of the CustomerManager. (There's a few gotchas we'll hit later, such as generic exception handling, though. The simple definition of CustomerManager above isn't quite enough, but it's presented here to get the basic idea across.)\nApplication layering Components fall into layers in your application. Each layer has a specific set of responsibilities, and defined communication with other layers.\nThe current ideal way to design your application is to provide nice, clean interfaces between layers:\nPresentation Layer (aka User Interface Layer)\nDisplays data to user and accepts i/p -- no business logic at all!\nDomain Layer (aka Business Logic Layer)\nThe \u0026quot;smarts\u0026quot; of your application\nStorage Layer (aka Data Management Layer)\nThe code that fetches and saves data for you Note that I said \u0026quot;current ideal\u0026quot;. Architecture evolves over time, and this is a current best practice. Newer and better techniques will come along, but they should grow from this approach.\nEach of the three layers has specific responsibilities, and can be composed of one or more components in your application. The dotted lines between the layers in Figure 1 represent the separation between the layers, and are written using one or more interfaces.\nAny number of presentation components (GUIs, JSPs, Servlets, Consoles) can present data to the user and accept user input. They communicate with the business logic of the application to request data to display and ask for modifications to the data. The business logic asks the data managers for data, and may modify that data before returning it to the presentations.\nSkipping layers is a no-no Communication should never skip layers! This is incredibly important, though it may not seem obvious at first.\nOne of the key sins committed by application developers is having their user interface talk directly to the data managers. The business logic is there for a reason, folks! If you skip past the business logic, the \u0026quot;smarts\u0026quot; of the application doesn't have the opportunity to do anything with the request. At first, you may not see a need for passing through, but you should.\nFor example, suppose you're implementing a simple online store application. You may at first think it's ok for the presentation to directly ask the data managers for the list of items to display. Hey, it's just a list, after all...\nBut what happens when you want to put those items on sale? Ok, so you go and modify the presentations to list a 20% off price. But there could be a bazillion pages that display the item, and all it takes is one missed page to give an inconsistent presentation to the user.\nSo, you could change the data manager. But now all business logic sees the change.\nIf you had the presentation call the business logic, instead of directly calling the data managers, all you would need to do is change the business logic and all pages that use the business logic see the change! You could even implement filters that decorate the business logic (see Design Patterns, by Gamma et al) to transform the data.\nGeneric exception handling The hardest part of making your application nice and generic is dealing with exceptions.\nLet's just think about our CustomerManager:\n1public interface CustomerManager { 2 public Customer load(int id); 3 public Customer store(Customer customer); 4 public Customer[] findByName(String namePattern); 5 public Customer createCustomer(String name, float creditLimit); 6 public void deleteCustomer(Customer customer); 7} This definition has some serious problems. If anything goes wrong, the caller needs to know about it. So we'll need to declare some thrown exceptions for error cases.\nBut what exceptions should we throw?\nLet's start by thinking about and implementation using JDBC. JDBC throws SQLExceptions (btw: SQL is properly pronounced \u0026quot;squeal\u0026quot;, no Ned Beatty references, please.)\nSo we could write a class that looks like:\n1public class CustomerManagerUsingJDBC implements CustomerManager { 2 public Customer load(int id) throws SQLException { 3 ... 4 } 5 6 public Customer store(Customer customer) throws SQLException { 7 ... 8 } 9 ... 10} and then modify the interface to also throw those exceptions. Ok so far, and we set up the business logic to catch SQLExceptions as necessary.\nUhhhh, but what about EJB? But things get nasty if we try to change the implementation to use Enterprise JavaBeans:\n1public class CustomerManagerUsingEJB implements CustomerManager { 2 3 public Customer load(int id) throws EJBException, RemoteException { 4 ... 5 } 6 7 public Customer store(Customer customer) throws EJBException, RemoteException { 8 ... 9 } 10 ... 11} Accessing EJBs could throw EJBException or RemoteException. Ok, so we'll modify the interface to use EJB, then change the code in the business logic.\nWrongo!!!\nThe whole point of this article is easier maintenance. Easier maintenance relies on one commandment: thou shalt not change thy interface!\nThink about what this does. Anytime you change the data manager, you'd need to change the business logic to \u0026quot;match\u0026quot; its exceptions.\nSo, uhhhh, how do we deal with exceptions? Ever hear of application-defined exceptions?\nWhat is the actual problem from the point of view of the business logic?\n\u0026quot;Can't get the data\u0026quot; \u0026quot;Can't store the data\u0026quot; \u0026quot;Data not found\u0026quot; Those are a few simple cases. Ok, let's define custom exceptions to deal with this.\n1public class MyApplicationException extends Exception { 2 private Throwable nestedException; 3 public MyApplicationException (String message, Throwable nestedException) { 4 super(message); 5 this.nestedException = nestedException; 6 } 7 public Throwable getNestedException() { 8 return nestedException; 9 } 10} 11 12public class CustomerException extends MyApplicationException { 13 public CustomerException(String message, Throwable nestedException) { 14 super(message, nestedException); 15 } 16} 17 18public class NotFoundException extends MyApplicationException { 19 public NotFoundException(String message, Throwable nestedException) { 20 super(message, nestedException); 21 } 22} Now we define the interface as follows. Note that this is how we should have defined it in the first place, so it won't require changes.\n1public interface CustomerManager { 2 public Customer load(int id) throws CustomerException, NotFoundException { 3 ... 4 } 5 6 public Customer store(Customer customer) throws CustomerException { 7 ... 8 } 9 ... 10} Now the interface is totally generic, with respect to how we store the data! A sample JDBC implementation might look like:\n1public class CustomerManagerUsingJDBC implements CustomerManager { 2 public Customer load(int id) throws CustomerException, NotFoundException { 3 try { 4 // JDBC to try to fetch data 5 if (resultSetIsEmpty) 6 throw new NotFoundException(\u0026#34;Customer \u0026#34; + id + \u0026#34; not found\u0026#34;, null); 7 8 } catch(NotFoundException e) { 9 throw e; 10 } catch(SQLException e) { 11 throw new CustomerException(\u0026#34;oops!\u0026#34;, e); 12 } 13 ... 14 } 15 ... 16} The idea is to catch the specific exception and wrap it in an application exception. This allows the business logic to worry about the concept of the problem, without knowing anything about the details of how the data manager was implemented.\n2018 Note: Of course this gets much simpler with Kotlin, as it does not use checked exceptions, so you don't have to pollute callers with framework-specific exceptions of things they call...\nEnterprise JavaBeans and layering The \u0026quot;trick\u0026quot; to using Enterprise JavaBeans is hiding them in the data management layer and business logic layer.\nGenerally:\nEntity beans represent data Session beans represent business logic Your application should never directly use the home or remote interfaces of EJBs. It should use your application interfaces!\nEntity Beans Entity beans are really just another way to store data.\nStart with our interfaces again:\n1public interface Customer { 2 public String getName() throws CustomerException; 3 public void setName(String name) throws CustomerException; 4 ... 5} 6 7public interface CustomerManager { 8 public Customer load(int id) 9 throws CustomerException, NotFoundException; 10 public Customer store(Customer customer) 11 throws CustomerException; 12 public Customer[] findByName(String namePattern) 13 throws CustomerException, NotFoundException; 14 public Customer createCustomer(String name, float creditLimit) 15 throws CustomerException; 16 public void deleteCustomer(Customer customer) 17 throws CustomerException; 18} The key here is the cooperation between the implementations of Customer and CustomerManager. First, our Customer implementation might look like:\n1public class CustomerAsEntityBean implements Customer { 2 private EntityCustomer entityCustomer; 3 public CustomerAsEntityBean(EntityCustomer entityCustomer) { 4 this.entityCustomer = entityCustomer; 5 } 6 public String getName() throws CustomerException { 7 try { 8 return entityCustomer.getName(); 9 } catch(Exception e) { // EJBException, RemoteException 10 throw new CustomerException(e); 11 } 12 } 13 ... 14} This customer is a proxy for our Entity Bean. Note that all requests are merely passed through to the entity bean.\nThere are several approaches to using entity beans like this:\nDirect proxy - just forward all calls to the entity bean. Incredibly easy to implement, always up to date with remote bean, but can provide poor performance. There is no separate \u0026quot;store\u0026quot; implementation; all \u0026quot;set\u0026quot; calls are performed immediately in the remote server. This is the implementation shown above.\nCopy bean - take a snapshot of the entity bean's remote data and store it locally. More difficult to properly implement, faster access overall, but not always up to date with remote bean. Care must be taken when storing.\nCache as we go - set up all calls to ask the remote bean for data, then cache that piece of data for later use. If some pieces of data aren't used, they won't affect performance on obtaining them as in a copy bean. Requires much more care, as if part of the data in the entity changes, we could get out of sync! Whatever implementation you choose makes no difference to the rest of your application (other than the data manager). All the rest of your application cares about is that it can ask a Customer for pieces of information and deal with problems accessing that data.\nThe final piece necessary to make this work is a data manager:\n1public class CustomerManagerUsingEJB interface CustomerManager { 2 public Customer load(int id) 3 throws CustomerException, NotFoundException { 4 5 try { 6 // set up naming context 7 // grab home interface for entity 8 // find entity (store as entityCustomer) 9 return new CustomerAsEntityBean(entityCustomer); 10 } catch(FinderException e) { 11 throw new NotFoundException(\u0026#34;Customer \u0026#34; + id + \u0026#34; not found\u0026#34;, e); 12 } catch(Exception e) { //EJBException, RemoteException 13 } 14 } 15 ... 16} Now all your business logic cares about is that it can ask some CustomerManager for some Customer. It doesn't need to even know that EJB was involved!\nSession Beans (Similar to entity beans, but replaces a business logic component -- remember -- HIDE the EJB access)\nTying it all together We need something to tie all of the pieces together. That something is a Factory class. We'll use the Factory Method pattern (see Design Patterns by Gamma et al) to implement this.\nA simple factory might look as follows:\n1public class MyApplicationFactory { 2 private static CustomerManager customerManager = 3 new CustomerManagerUsingEJB(); 4 private static ApplicationLogic applicationLogic = 5 new ApplicationLogicAsSessionBean(); 6 public static CustomerManager getCustomerManager() { 7 return customerManager; 8 } 9 10 public static ApplicationLogic getLogic() { 11 return applicationLogic; 12 } 13} (Note that this type of object is also called a Service Locator, giving centralized access to common resources. The same function can be accomplished using Dependency Injection, but I generally find it much simpler to debug a Service Locator)\nYou could even make things more flexible, keeping the names of the actual classes to use in a property file:\n1public class MyApplicationFactory { 2 private static CustomerManager customerManager; 3 private static ApplicationLogic applicationLogic; 4 // note: needs **much** better error handling... 5 // this is just to give the idea... 6 static { 7 try { 8 InputStream in = 9 MyApplicationFactory.getResourceAsStream( 10 \u0026#34;application.properties\u0026#34;); 11 Properties p = new Properties(); 12 p.load(in); 13 in.close(); 14 customerManager = 15 Class.forName(p.getProperty(\u0026#34;manager.customer\u0026#34;)).newInstance(); 16 applicationLogic = 17 Class.forName(p.getProperty(\u0026#34;logic.application\u0026#34;)).newInstance(); 18 } catch(Exception e) { 19 // report error 20 } 21 } 22 23 public static CustomerManager getCustomerManager() { 24 return customerManager; 25 } 26 27 public static ApplicationLogic getLogic() { 28 return applicationLogic; 29 } 30} ","link":"https://javadude.com/post/20010516-layering-applications/","section":"post","tags":["java","design"],"title":"Layering Applications"},{"body":"A tutorial on ANTLR 2.x\nNote: This is the ANTLR 2.x Tutorial. If you're looking for an ANTLR 3.x Tutorial, please see my new ANTLR 3.x Video Tutorial Introduction (the part you'll never read...) Note: I've had several requests over the years to make this a single page. Well, here it is. Enjoy!\nI need to warn you up front that I can be a bit long-winded, so bear with me while I try to describe a bit about what ANTLR is, how you can write parsers and compilers using it, what type of code it will produce, the color of the moon on an October evening and why \u0026quot;42\u0026quot; is such an important number (or so says Douglas Adams.)\nOk. Call me nuts. I just sick of all the whining about how hard it is to learn ANTLR. (So the whining is valid -- it's a bit hard to learn. I only had the cat to whine to.) I remembered learning PCCTS (the old C/C++ version of ANTLR) a few years ago using the \u0026quot;Advanced Tutorial\u0026quot; but things have changed significantly since then. Back then, I used PCCTS for a compiler course. I loved it and have loved it ever since. I figured, \u0026quot;Hey, I've got a simple compiler written in PCCTS, so why not revise it and write it as a tutorial?\u0026quot; So here it is.\nI want this tutorial to really help people, so I'm asking for input. Email me atÂ scott@javadude.com with any suggestions or comments you may have, and I just might do some more work on this.\nA Simple Language The compiler course I took at Johns Hopkins featured a small language called \u0026quot;XL.\u0026quot; I'm not sure who came up with this language, but the course was taught by Dr. John Moore, and he presented XL to us. I wanted to at least give him some credit for getting me really interested in compilers and such. If anyone knows a reason why I shouldn't be presenting this language, please let me know and I'll remove this from the net. I'll be presenting the language almost verbatim from Dr. Moore's writeup of the language.\nNote that in this tutorial I will not be implementing the entire XL language. I will only be implementing the features I selected when writing the compiler for the class. Eventually I will try to implement all the features in this document, if I have lots of extra time between reading to the kids and changing their diapers. I will try to mention when features are not implemented.\nXL is a small but complete programming language based primarily on Ada and, to a lesser extent on C, C++ and Pascal. XL was designed to be suitable for use as a project language in a course on compiler design and construction. Its features illustrate many of the techniques and problems associated with language translation.\nGeneral XL is case sensitive. Upper-case letters and lower-case letters are considered to be distinct in all tokens, including reserved words.\nWhite space (space character, tab character and end-of-line) serves to separate tokens; otherwise, it is ignored. No token can extend past end-of-line. Spaces may not appear inside any token except character and string literals.\nA comment begins with two forward slashes and extends to end of line, as in C++.\nIdentifiers Identifiers start with a letter and contain letters and digits. An identifier must fit on a single line and its first 100 characters are significant.\nReserved Words The following keywords are reserved in XL:\nkeyword keyword keyword keyword and array Boolean begin Char constant else elsif and exit function if Integer loop mod not of or out procedure program record return String then type var when while Literals An integer literal consists of a sequence of one or more digits\nA character literal is a single character enclosed by a pair of apostrophes (sometimes called \u0026quot;single quotes\u0026quot;.) Examples include 'A', 'x', and '''. A character literal is distinct from a string literal of length one.\nA string literal is a sequence of zero or more printable characters enclosed by a pair of quotation marks (\u0026quot;double quotes.\u0026quot;) The double quote character itself can be represented in a string as two adjacent double quotes. In XL, string literals are only used as arguments to the predefined I/O procedure \u0026quot;put\u0026quot; (see below)\nOther Tokens (delimiters and operators) operators note : ; , . ( ) [ ] | one character + - * / \u0026lt; = \u0026gt; ' | one character .. := /= \u0026gt;= \u0026lt;= | two characters (end-of-file) | actual EOF, not words\nStandard (Predefined) Scalar Types The type Boolean is treated as a predefined enumeration type with elements FALSE and TRUE\nThe type Integer is a predefined type as in Pascal and FORTRAN (equivalent to type int in C)\nThe type Char is a predefined type which is equivalent to Pascal's CHAR. The predecessor and successor functions are invoked as attributes Char'pred and Char'succ. Thus, Char'pred('D') is 'C' and Char'succ('A') is 'B'. (At this point, these attributes are not implemented. I may add them later.)\nType Generators An enumeration type is defined by listing the identifiers which are the actual values of the type. As with type Char, the predecessor and successor functions of an enumeration type T as invoked as attributes T'pred and T'succ. For example:\ntype CardSuit = \u0026lt;CLUB, DIAMOND, HEART, SPADE\u0026gt;; Then CardSuit'pred(HEART) is DIAMOND and CardSuit'succ(HEART) is SPADE.\nAn array type (one dimensional only) is defined by giving a range of indices and the component type. Only integer indices are allowed in XL. For example\ntype Table = array[1..10] of Integer; A record type is defined by listing the individual component names (fields) and their types. For example:\ntype Date =\rrecord\rday : Integer;\rmonth: Integer;\ryear: Integer;\rend record;\rNamed Constants Named constants are introduced by declarations of the form\nconstant ID, ID, . . ., ID: typeName := expression; typeName must be an identifier representing a scalar type (Integer, Boolean, Char or a user-defined enumeration type.) The phrase \u0026quot;:= expression\u0026quot; is required. For example:\nconstant maxIndex : Integer := 100; Variables Variables are introduced by declarations of the form\nvar ID, ID, ..., ID : typeName := expression; typeName must be an identifier, not a type constructor such as an array or record. The phrase \u0026quot;:= expression\u0026quot; is optional and can only involve literals and named constants. For example:\nvar I : Integer := 1;\rvar b1, b2 : Boolean; Operators and Expressions Operators The operators, in order of precedence, are\ncategory operators precedence Boolean negation not highest Unary adding operators + - Multiplying operators * / mod Binary adding operators + - Relational operators = /= \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= Logical operators and or lowest Expressions For binary operators, both operands must be the same type. Similarly, for assignment compatibility, both the left and right sides must have the same type. Objects are considered to have the same type only if they both have the same type name. Thus, two distinct type definitions are considered different even if they may be structurally identical. This is known as \u0026quot;name equivalence\u0026quot; of types.\nShort Circuiting Logical operators and and or use short-circuit evaluation.\n(If you are not familiar with short-circuiting, this means that as soon as the truth value can be determined, evaluation stops. For example, if the first operand of an and evaluates false, the expression will evaluate false no matter what the second operand is, so the second operand is not even evaluated. If the first operand of an or evaluates true, the second isn't evaluated either.)\nStatements All statements are terminated with a semicolon.\nAssignment statement (\u0026quot;:=\u0026quot; is the assignment operator). For example\ni := 2*I + 5; If statement if x \u0026gt; MAX then if x \u0026lt; 10 then\rMAX := x; x := x + 1;\relsif x \u0026lt; MIN then y := 2*x;\rMIN := x; end if;\rend if;\rLoop and exit statements loop while I \u0026lt; n loop\rget(x);\tsum := sum + a[I];\rexit when x = SIGNAL;\ti := i + 1;\rprocess(x);\tend loop;\rend loop;\rI/O Statements (for text I/O only) XL defines only sequential I/O for two basic character streams, standard input and standard output. All I/O is provided by the following procedures:\nprocedure put(item : String); // for string literals\rprocedure put(item : Char);\rprocedure put(item : Integer);\rprocedure newLine;\rprocedure get(var item : Char);\rprocedure get(var item : Integer);\rprocedure skipLine; Subprograms Procedures Procedures are similar to those in Pascal except that an explicit return is allowed. The program is essentially the outermost procedure (with no parameters) and serves as a starting point for the program.\nFunctions Functions can return scalar types only, not arrays or records. Only value parameters are allowed. A function returns a value by executing a statement of the form\nreturn expression; Parameters There are two parameter modes in XL: value parameters and variable parameters. Value parameters (passed by copy) are the default. Variable parameters (passed by reference) must be explicitly declared as in\nprocedure p(var x : Integer) ... Subprogram end The name of the procedure must be repeated at the end of its declaration. For example\nprocedure proc1;\r...\rend proc1;\rSpecification Conclusion OK, so it's sketchy. I know, I know. But that's what I got. Maybe I'll improve it someday, but I think if you're a programmer you'll probably understand it pretty well anyway...\nNext we'll discuss...Â Our Strategy Structure of Our Compiler So, now that we have a so-so idea of the language we are compiling, let's design our compiler and think about how we want to implement it.\nA basic compiler consists of several pieces. These pieces can be very independent, or very intertwined. I'll try an independent approach here...\nThe compiler will take an input source file, and output some sort of executable. Let's break it down into tasks:\nLexical Analysis (scanning) Semantic Analysis (parsing) Tree Generation Code Generation Interpretation The approach I'll take is to generate a pseudo-machine code, and we'll write a simple interpreter at the end. This approach is similar to the Pascal P-Code machines and the current Java Virtual Machine approach...\nLexical Analysis First, the compiler will read the input file and lump the characters together into tokens. Using ANTLR 2.x, this job is done using a scanner definition.Â One of the big differences between ANTLR 2.x and PCCTS 1.33 is how you specify your scanner.Â ANTLR 2.x uses a syntax that is nearly identical to the parser syntax.Â You create a recursive-descent scanner as well as a recursive-descent parser.\nSemantic Analysis Next, we write grammar rules to pump into ANTLR. These rules will have action code (Java code) attached to them to specify what to do when we see certain patterns of tokens in the input file.\nTree Generation This actually occurs along with the semantic analysis. We'll generate an Abstract Syntax Tree (AST) using ANTLR's built-in tree generation routines. This tree will act as the communication device between the parser and the code generator.\nCode Generation Once we have a tree, we'll walk it and write out code.Â More on this if I ever finish this tutorial...\nInterpretation The interpreter for XL is really simple, and will allow us to test our compiled output without needing to learn specific machine code.\nStructure of this Tutorial Now how will we build this compiler? Should we try to do everything at once so you get good and confused? Of course not!\nWe'll break the work up into steps:\nBuild a Recognizer Add a symbol table Add type checking Build an AST Write a Tree Walker to generate code Write an Interpreter Test the output code Let's start our recognizer!\nThe Scanner Introduction We'll look at each language element and put together some scanner rules for it. In some cases, I may look at how the same construct would be implemented for other languages, showing some difficulties and how to overcome them. At least that's my plan. We'll see where I end up...\nYou can download the code for the tutorial or type along. I recommend typing along as it seems to help folks \u0026quot;get\u0026quot; what's going on...\nSource code: antlrtut.zip\nThis zip file is also an Eclipse project. If you have the ANTLR-Eclipse plugin installed, you can edit and test the code within eclipse. Simply unzip the antlrtut.zip and use Import-\u0026gt;Existing Project Into Workspace from within Eclipse.\nLexical Elements of XL Whitespace XL declares that blank spaces, tabs, and end-of-line constitute whitespace. Oh, and don't forget the ever (un)popular carriage-return/line-feeds that DOS is so fond of. You should always handle this, especially if you will be running on UNIX and there is even a chance that someone will run a file that has been touched by DOS through your parser. And just to make things more interesting, let's consider the Macintosh as well; it uses a lonely carriage-return to specify a new line.\nMost scanner-generation tools force you to specify regular expressions for scanner rules.Â ANTLR 2.x simplifies this significantly.Â Not only is the ANTLR tool itself significantly simpler, but it makes the job of a grammar writer much easier as well: you only need to learn one format of specification.\nIn ANTLR 2.x, you specify the scanner grammar in the same manner in which you specify the parser grammar.Â We'll discuss some minor differences a bit later, but overall, they are virtually identical.\nFor our whitespace rule, we specify the following:\n1WS 2\t:\t(\t\u0026#39; \u0026#39; 3\t|\t\u0026#39;\\t\u0026#39; 4\t|\t\u0026#39;\\f\u0026#39; 5 6\t// handle newlines 7\t|\t(\t\u0026#34;\\r\\n\u0026#34; // DOS/Windows 8\t|\t\u0026#39;\\r\u0026#39; // Macintosh 9\t|\t\u0026#39;\\n\u0026#39; // Unix 10\t) 11 12\t// increment the line count in the scanner 13\t{ newline(); } 14\t) 15\t{ $setType(Token.SKIP); } 16; The WS rule defines what will happen when the scanner sees space (' '), tab ('\\t'), formfeed ('\\f') or one of the platform-specific manners of indicating \u0026quot;end of line.\u0026quot;Â First, we match the character(s) that we see.Â If those characters represent \u0026quot;end of line\u0026quot;, we call the built-in newline() method, which tells the parser to increase its current line number.Â (The line number will be used in error messages, so it's very important that you call the newline() method.)\nAfter we match the whitepace (whatever it ends up being) we set the token type to Token.SKIP.Â $setType is a special syntax for setting the type and will be translated by ANTLR into a Java statement.Â This is a special token indicator that tells the scanner not to return a token, but to proceed on to the next token it might encounter.\nRules in an ANTLR 2.x scanner may be prefixed by the keyword protected, or by no keyword at all.Â If a rule is prefixed by protected, it means that the rule will only be used as a helper rule.Â Perhaps it is the definition of a \u0026quot;decimal digit\u0026quot; which could be used in other rules to help build a number.\nAny scanner rules that are not prefixed with the protected keyword will be candidates for being called to match \u0026quot;the next token.\u0026quot;Â ANTLR will create a nextToken() method that will pick the appropriate non-protected scanner rule to match the next token.Â nextToken(), in turn, is called by a parser to fetch the next token it will try to match.\nNote that ANTLR's syntax allows you to specify subrules. You can nest decisions within other decisions by enclosing the lower-level decision in another set of parenthesis.Â Think of it as follows:\n1someRuleName 2\t:\t\u0026#39;A\u0026#39; \u0026#39;B\u0026#39; \u0026#39;C\u0026#39;\t// a top-level alternative 3\t|\t\u0026#39;D\u0026#39; \u0026#39;E\u0026#39; \u0026#39;F\u0026#39;\t// a top-level alternative 4\t|\t\u0026#39;Q\u0026#39; (\t// starting a subrule! 5\t\u0026#39;R\u0026#39; \u0026#39;S\u0026#39; // a subrule alternative 6\t|\t\u0026#39;W\u0026#39; \u0026#39;X\u0026#39;\t// a subrule alternative 7\t)\t// end the subrule 8\t;\t// end the rule The above rule could match the following \u0026quot;words\u0026quot;\nABC DEF QRS QWX Comments We got lucky in XL (it uses C++-style comments), but I'll bore you with C-style comments in a minute...\nXL defines comments as \u0026quot;all text from // to the end of the current line.\u0026quot; So, we get a rule like\n1COMMENT 2\t:\t\u0026#34;//\u0026#34; (~(\u0026#39;\\n\u0026#39;|\u0026#39;\\r\u0026#39;))* 3\t{ $setType(Token.SKIP); } 4\t; A few things to notice about this rule:\nNote that we didn't match the end-of-line character.Â This will be matched by our WS rule that we have already defined.Â What we do need to do is specify which characters are ok to keep in the comment.Â As soon as we see '\\n' or '\\r', both of which start an end-of-line sequence, we stop. Those of you familiar with lex will notice that we can't just say \u0026quot;.*\u0026quot; to represent all non-newline characters. (~('\\n'|'\\r'))* is needed to explicitly state \u0026quot;any character except end-of-line\u0026quot;. I threatened to do C-style comments, so I will.\nLet's assume we are using a C compiler that does not keep track of nested comments -- \u0026quot;/*\u0026quot; starts a comment, and \u0026quot;*/\u0026quot; ends a comment. It doesn't matter if it supports the C++ style comments or not -- they'll get gobbled just as well as the rest of a comment.\nOne of the advantages to the new scanner definition in ANTLR 2.x is that a full EBNF grammar is much stronger at representing a language description than regular expressions.Â If you take a look at the old PCCTS tutorial, you can see what a mess defining C-style comments can be.Â In contrast, a C-style comment in ANTLR 2.0 is a bit simpler:\n1// multiple-line comments 2ML_COMMENT 3\t:\t\u0026#34;/*\u0026#34; 4\t(\t/*\t\u0026#39;\\r\u0026#39; \u0026#39;\\n\u0026#39; can be matched in one alternative or by matching 5\t\u0026#39;\\r\u0026#39; in one iteration and \u0026#39;\\n\u0026#39; in another. I am trying to 6\thandle any flavor of newline that comes in, but the language 7\tthat allows both \u0026#34;\\r\\n\u0026#34; and \u0026#34;\\r\u0026#34; and \u0026#34;\\n\u0026#34; to all be valid 8\tnewline is ambiguous. Consequently, the resulting grammar 9\tmust be ambiguous. I am shutting this warning off. 10\t*/ 11 12\toptions { 13\tgenerateAmbigWarnings=false; 14\t} 15\t:\t{ LA(2)!=\u0026#39;/\u0026#39; }? \u0026#39;*\u0026#39; 16\t|\t\u0026#39;\\r\u0026#39; \u0026#39;\\n\u0026#39; {newline();} 17\t|\t\u0026#39;\\r\u0026#39; {newline();} 18\t|\t\u0026#39;\\n\u0026#39; {newline();} 19\t|\t~(\u0026#39;*\u0026#39;|\u0026#39;\\n\u0026#39;|\u0026#39;\\r\u0026#39;) 20\t)* 21\t\u0026#34;*/\u0026#34; 22 23\t{$setType(Token.SKIP);} 24\t; This rule says the following:\nMatch /* to start a comment Keep looping through stuff inside a comment: match '*' as long as it's not followed by '/'\nNOTE: This subrule uses a semantic predicate. We'll talk about these more later on, so don't worry too much about what the {LA(2) != '/'}? means.Â For now, just read it as \u0026quot;if the second character down the input stream is not a '/', the following alternative ('*') is eligible to match.)\nmatch any of the end-of-line indicators.Â Note that we must perform the same action we would when we see end-of-line in any other context.Â In our recognizer, that action is to simply call the newline() method.\nmatch anything other than a newline() or \\*.Â This may seem redundant, but if you don't specify this explicitly, ANTLR will compare it to the previous two rules and report an ambiguity.Â This is necessary because based on looking at the next character in the input stream, the scanner wouldn't be able to decide whether to match an end-of-line sequence in the second or third alternative.\nMatch */ to end the comment Note the use of the ( )* construct.Â This is called a star closure, and is used to perform looping in a grammar rule.Â The star closure will match zero or more of whatever is contained within its parenthesis.\nLiterals In XL, there are three types of literals: Integer, Character and String.\nInteger literals are simple -- they are just a series of digits.Â Just so we can demonstrate a protected scanner rule, we'll start out by defining what a DIGIT is:\n1protected DIGIT 2\t:\t\u0026#39;0\u0026#39;..\u0026#39;9\u0026#39; 3\t; Because this rule is marked protected, we will not get a DIGIT token returned to the parser;Â DIGIT is never directly called from the nextToken() method.\nNow that we have a helper method that defines what an integer digit is, we'll define an INTLIT (integer literal):\n1INTLIT 2\t:\t(DIGIT)+ 3\t; This rule means \u0026quot;an INTLIT is composed of one or more DIGITs\u0026quot;.Â Note that we do not set the token type to Token.SKIP this time. This means that is an INTLIT scanner rule is matched while looking at the characters in the input, an INTLIT token will be returned to the parser, via the nextToken() method.\nNote that this will result in the generated INTLIT scanner rule calling the generated DIGIT scanner rule.Â A slightly more efficient approach would be to define the INTLIT rule as follows:\n1INTLIT 2\t:\t0\u0026#39;..\u0026#39;9\u0026#39;)+ 3\t; Our final code will use the first, less-efficient method, just to show use of the protected keyword.\nCharacter literals as fairly simple as well:\n1CHARLIT 2\t:\t\u0026#39;\\\u0026#39;\u0026#39;! . \u0026#39;\\\u0026#39;\u0026#39;! 3\t; Basically, an apostrophe followed by any character, followed by another apostrophe. In the grammar, we will use CHARLIT to refer to a character literal.Â The \u0026quot;any character\u0026quot; is represented by an unquoted period/dot in the rule.\nBut notice the exclamation marks (!) after the single quotes?Â This means, toss these characters away when building the token's string value.Â When a CHARLIT token is returned to the parser, its text will only be the single character that was contained within the single-quotes.\nString literals are very similar.Â The trick is to decide what ends a string literal.Â We defined string literals as being all text within double-quotes, but the entire literal must be on one line in the source file.Â This results in the following scanner rule:\n1STRING_LITERAL 2\t:\t\u0026#39;\u0026#34;\u0026#39;! 3\t(\t\u0026#39;\u0026#34;\u0026#39; \u0026#39;\u0026#34;\u0026#39;! 4\t|\t~(\u0026#39;\u0026#34;\u0026#39;|\u0026#39;\\n\u0026#39;|\u0026#39;\\r\u0026#39;) 5\t)* 6 7\t(\t\u0026#39;\u0026#34;\u0026#39;! 8\t|\t// nothing -- write error message 9\t) 10\t; First, we enter a string when we see a double quote.\nWhat can we see inside a string? Remember, from the spec, two double-quotes is a literal double quote. So we match them.Â However, we only want one of them in the resulting string literal.Â So we suffix on of the two double-quote characters with another exclamation mark (!). This says \u0026quot;match, but toss out the second double-quote\u0026quot;.)\nBut what if we see an end-of-line inside a string? This is illegal, so we'll assume it ends the string.Â It will not be matched as part of the contained characters, and will cause an exit of the ( )* subrule.\nAfter we get out of the ( )* string body, we have a subrule that checks to see if we can match a closing double-quote or not.Â If we match it, we have a value string.Â If we don't match it, it can only be because we found end-of-line within the string.Â We'll allow this (the empty alternative commented \u0026quot;nothing\u0026quot;) but we'll probably want to write an error message saying \u0026quot;String termninated by end-of-line\u0026quot;.\nFinally, note that we use exclamation marks after the opening and closing quotes of the string.Â This removes them from the string literal text represented by the token.\nKeywords XL reserves all keywords -- I may add later what to do with unreserved keywords (for evil languages like PL/1 -- hey! I like to program in PL/1, but I'd hate to write that compiler!)\nThere are several ways to implement keywords. The simplest is to just directly specify them in the parser grammar.Â ANTLR 2.x provides better support for string literals in a grammar than PCCTS 1.33 did.Â If you specified a string literal in a PCCTS 1.33 grammar, there was no way to refer to that token when walking through a generated AST (Abstract Syntax Tree).Â ANTLR 2.x solves that problem by defining a special token name for each literal in the parser grammar.Â For example, a string literal \u0026quot;end\u0026quot; specified in the grammar will be represented by a token named LITERAL_end.Â You can use the name LITERAL_end in a tree-walker grammar to refer to that matched literal \u0026quot;end\u0026quot;.\nAny literals you specify in the parser will be inserted into a nifty little hash table.Â You'll need to make the scanner aware that the hash table is being used so it can perform lookups in that table for keyword matches.Â We'll discuss this when we talk about indentifiers.\nOperators XL defines several operators, and we'll define them as well... These definitions are very straightforward.Â Just assign a scanner rule name to match the text.\n1DOT : \u0026#39;.\u0026#39; ; 2BECOMES : \u0026#34;:=\u0026#34; ; 3COLON : \u0026#39;:\u0026#39; ; 4SEMI : \u0026#39;;\u0026#39; ; 5COMMA : \u0026#39;,\u0026#39; ; 6EQUALS : \u0026#39;=\u0026#39; ; 7LBRACKET : \u0026#39;[\u0026#39; ; 8RBRACKET : \u0026#39;]\u0026#39; ; 9DOTDOT : \u0026#34;..\u0026#34; ; 10LPAREN : \u0026#39;(\u0026#39; ; 11RPAREN : \u0026#39;)\u0026#39; ; 12NOT\\_EQUALS : \u0026#34;/=\u0026#34; ; 13LT : \u0026#39;\u0026lt;\u0026#39; ; 14LTE : \u0026#34;\u0026lt;=\u0026#34; ; 15GT : \u0026#39;\u0026gt;\u0026#39; ; 16GTE : \u0026#34;\u0026gt;=\u0026#34; ; 17PLUS : \u0026#39;+\u0026#39; ; 18MINUS : \u0026#39;-\u0026#39; ; 19TIMES : \u0026#39;*\u0026#39; ; 20DIV : \u0026#39;/\u0026#39; ; Note that some of these tokens have common prefixes.Â For example, GT and GTE both start with character '\u0026gt;'.Â In a Deterministic Finite Automata (DFA)-based scanner, this would not be an issue, as it would try to match the longest possible token.\nIn a recursive-descent scanner, this is a big issue.Â There are two ways to handle this situation:\nLeft-factor the rules in question. Increase the lookahead characters. Taking the first approach, left factoring, would require that we define a rule to deal with GT and GTE as follows:\n1GT 2\t:\t\u0026#39;\u0026gt;\u0026#39; (\u0026#39;=\u0026#39; {$setType(GTE);})? 3\t; This rule says \u0026quot;match the '\u0026gt;' character.Â Then, if I see '=' as the next character. match it.\u0026quot;Â The \u0026quot;trick\u0026quot; here is that the \u0026quot;normal\u0026quot; completion of the rule defines the resulting token as the name of the rule, which is GT in this case.Â If we match the optional subrule ('=')?, where the ( )? defines its contents as optional, we execute the $setType(GTE); statement, which changes the type of the token to GTE.\nTaking the second approach only involves setting the lookahead amount to a higher number.Â This means that we can have the scanner check the next two characters to make a decision, instead of just the first character.Â Checking the next two characters in the input stream allows the scanner to correct decide if it should choose to match the GT rule or the GTE rule.Â You can specify a higher lookahead value in the scanner as follows:\n1options { 2\tk=2; // two characters of lookahead 3} immediately after defining the scanner.Â We'll see how the scanner is defined in a moment.Â It is important to think carefully whether you want to increase the lookahead amount.Â While it may make the grammar simpler, it could also slow it down.Â In addition, if you do not carefully study the conflicts and understand them, and simply raise the lookahead amount, you may be masking a real problem.Â Try to keep lookahead as low as possible, and always try generating your compiler with k=1 first.Â Make sure you understand what is causing the conflicts, and if you feel certain, and the conflicts are all similar to the GT/GTE conflict above, raise the lookahead value.\nIdentifiers Finally, we talk about identifiers. Basically, they are any sequence of letters and digits that's left. So we get a regular expression like:\n1IDENT 2\t:\t(\u0026#39;a\u0026#39;..\u0026#39;z\u0026#39;|\u0026#39;A\u0026#39;..\u0026#39;Z\u0026#39;) (\u0026#39;a\u0026#39;..\u0026#39;z\u0026#39;|\u0026#39;A\u0026#39;..\u0026#39;Z\u0026#39;|\u0026#39;0\u0026#39;..\u0026#39;9\u0026#39;)* 3\t; Very simple. Note that there is no action code here, especially not any that would perform symbol table lookup. I'm very adamant in pushing my view that scanner to parser communication should be a one-way street. This is especially important in multiple-lookahead parsers. If your parser decides when to push and pop scope (a likely scenario), and your scanner is reading two or more tokens ahead, you may be looking at a token in the scanner before its proper scope was pushed or popped. In addition, things like semantic predicates let you make more pointed decisions about how to parse identifiers in the grammar, rather than changing the token type in the scanner.\nThink about the set of tokens that can be returned by the scanner we've defined.Â Where would keywords like begin and end be matched?Â In our IDENT rule!\nWe will be defining keywords within our parser, which will end up generating tokens called LITERAL_begin and LITERAL_end, for example.Â Recall that these literals will be inserted in a special hash table.Â To utililize this hash table, modify the IDENT rule as follows:\n1IDENT 2\toptions {testLiterals=true;} 3\t:\t(\u0026#39;a\u0026#39;..\u0026#39;z\u0026#39;|\u0026#39;A\u0026#39;..\u0026#39;Z\u0026#39;) (\u0026#39;a\u0026#39;..\u0026#39;z\u0026#39;|\u0026#39;A\u0026#39;..\u0026#39;Z\u0026#39;|\u0026#39;0\u0026#39;..\u0026#39;9\u0026#39;)* 4\t; Note the testLiterals=true option.Â This generates code that will lookup a name in the literals hash table if the IDENT rule matches a word.Â This implies that every literal you specify in the parser grammar must be matchable by the IDENT rule.\nIf a word such as \u0026quot;end\u0026quot; is found in the literals table, the token type will be changed to be something like LITERAL_end before being returned to the parser.\nPutting the Lexical Elements Together What do we have so far? Let's look at it in one lump, shall we?\nBut first, we need to tell ANTLR that we're creating a scanner and specify a new options (such as lookahead):\n1//--------------- 2// The XL scanner 3//--------------- 4 5class XLLexer extends Lexer; 6 7options { 8\tcharVocabulary = \u0026#39;\\0\u0026#39;..\u0026#39;\\377\u0026#39;; 9\ttestLiterals=false; // don\u0026#39;t automatically test for literals 10\tk=2; // two characters of lookahead 11} First, we specify that we are creating a scanner called XLLexer, subclassing the Lexer class.Â Lexer is an abstract class that defines the basis for an ANTLR-generated scanner.Â (You can define scanners that subclass other scanners that you have defined, but that is outside the scope of this tutorial.Â Please see the ANTLR documentation at http://www.antlr.org/ for details.)\nNext we specify four options.Â These are:\ncharVocabulary = '\\0'..'\\377';\nThis defines the valid set of characters than can be recognized by the ANTLR scanner.Â This is necessary to match expresions like ~'a' in a scanner rule.Â We need to know what the other possible characters are...\nAlso - the characters mentioned in the charVocabulary are the only characters that will be allowed in the source input.Â Any character encountered that is not in the charVocabulary will be flagged as invalid.Â The range we specify above is the entire UNICODE character set.\ntestLiterals=false;\nSpecifies that by default we do not want all rules to check the literals table for possible matches.Â Only rules that have their own testLiterals option will perform that lookup.\nk=2;\nThis specifies that the scanner will look at the next two characters of the input stream to determine which alternative to choose.Â The extra lookahead is only used when actually necessary to disambiguate.\nAfter specifying the name and options for the scanner, we specify the rules.Â The following is our entire scanner:\n1//---------------------------------------------------------------------------- 2// The XL scanner 3//---------------------------------------------------------------------------- 4 5class XLLexer extends Lexer; 6 7options { 8\tcharVocabulary = \u0026#39;\\0\u0026#39;..\u0026#39;\\377\u0026#39;; 9\ttestLiterals=false; // don\u0026#39;t automatically test for literals 10\tk=2; // two characters of lookahead 11} 12 13// Single-line comments 14COMMENT 15\t:\t\u0026#34;//\u0026#34; (~(\u0026#39;\\n\u0026#39;|\u0026#39;\\r\u0026#39;))* 16\t{ $setType(Token.SKIP); } 17\t; 18 19// Literals 20protected DIGIT 21\t:\t\u0026#39;0\u0026#39;..\u0026#39;9\u0026#39; 22\t; 23 24INTLIT 25\t:\t(DIGIT)+ 26\t; 27 28CHARLIT 29\t:\t\u0026#39;\\\u0026#39;\u0026#39;! . \u0026#39;\\\u0026#39;\u0026#39;! 30\t; 31 32// string literals 33STRING_LITERAL 34\t:\t\u0026#39;\u0026#34;\u0026#39;! 35\t(\t\u0026#39;\u0026#34;\u0026#39; \u0026#39;\u0026#34;\u0026#39;! 36\t|\t~(\u0026#39;\u0026#34;\u0026#39;|\u0026#39;\\n\u0026#39;|\u0026#39;\\r\u0026#39;) 37\t)* 38 39\t(\t\u0026#39;\u0026#34;\u0026#39;! 40\t|\t// nothing -- write error message 41\t) 42\t; 43 44// Whitespace -- ignored 45WS 46\t:\t(\t\u0026#39; \u0026#39; 47\t|\t\u0026#39;\\t\u0026#39; 48\t|\t\u0026#39;\\f\u0026#39; 49 50\t// handle newlines 51\t|\t(\t\u0026#34;\\r\\n\u0026#34; // DOS/Windows 52\t|\t\u0026#39;\\r\u0026#39; // Macintosh 53\t|\t\u0026#39;\\n\u0026#39; // Unix 54\t) 55 56\t// increment the line count in the scanner 57\t{ newline(); } 58\t) 59 60\t{ $setType(Token.SKIP); } 61\t; 62 63// an identifier. Note that testLiterals is set to true! This means 64// that after we match the rule, we look in the literals table to see 65// if it\u0026#39;s a literal or really an identifer 66 67IDENT 68\toptions {testLiterals=true;} 69\t:\t(\u0026#39;a\u0026#39;..\u0026#39;z\u0026#39;|\u0026#39;A\u0026#39;..\u0026#39;Z\u0026#39;) (\u0026#39;a\u0026#39;..\u0026#39;z\u0026#39;|\u0026#39;A\u0026#39;..\u0026#39;Z\u0026#39;|\u0026#39;0\u0026#39;..\u0026#39;9\u0026#39;)* 70\t; 71 72// Operators 73DOT : \u0026#39;.\u0026#39; ; 74BECOMES : \u0026#34;:=\u0026#34; ; 75COLON : \u0026#39;:\u0026#39; ; 76SEMI : \u0026#39;;\u0026#39; ; 77COMMA : \u0026#39;,\u0026#39; ; 78EQUALS : \u0026#39;=\u0026#39; ; 79LBRACKET : \u0026#39;[\u0026#39; ; 80RBRACKET : \u0026#39;]\u0026#39; ; 81DOTDOT : \u0026#34;..\u0026#34; ; 82LPAREN : \u0026#39;(\u0026#39; ; 83RPAREN : \u0026#39;)\u0026#39; ; 84NOT_EQUALS : \u0026#34;/=\u0026#34; ; 85LT : \u0026#39;\u0026lt;\u0026#39; ; 86LTE : \u0026#34;\u0026lt;=\u0026#34; ; 87GT : \u0026#39;\u0026gt;\u0026#39; ; 88GTE : \u0026#34;\u0026gt;=\u0026#34; ; 89PLUS : \u0026#39;+\u0026#39; ; 90MINUS : \u0026#39;-\u0026#39; ; 91TIMES : \u0026#39;*\u0026#39; ; 92DIV : \u0026#39;/\u0026#39; ; Let's move on to the parser grammar.\nThe Parser Now we'll look at a parser grammar for XL. Note that we are building just a recognizer at this state, and the grammar may (and will!) change.\nLet's start at the top, shall we?\nProgram Specification XL has one program per file, so this is really our starting rule.\n1program 2\t:\t\u0026#34;program\u0026#34; IDENT EQUALS 3\tsubprogramBody 4\tDOT 5\t// end-of-file 6\t; Pretty straightforward. Note that so far, we don't care that we are definitely declaring that IDENT here. We will later, though...\nSubprogram Bodies A subprogram body is a little (or big) block of code that makes up the \u0026quot;what I do\u0026quot; part of a program, procedure, or function. It's not bad to define, but it will get a bit tricker later. Well, not too much so.\nsubprogramBody\r:\t(basicDecl)*\r(procedureDecl)*\r\u0026quot;begin\u0026quot;\r(statement)*\r\u0026quot;end\u0026quot; IDENT\r;\rSo what is it? Basically, define your local variables, types and constants (basicDecls). There can be zero or more of these, hence the use of the ( )* closure. Then, define any nested procedures or functions. Again, zero or more of these. Finally, we get to the definition of what the current program/procedure/function does. This starts with a \u0026quot;begin\u0026quot;, has zero or more statements in it, and is ended by \u0026quot;end\u0026quot; IDENT. Note that the XL spec stated that the identifer that ends a subroutine must match the beginning one. Right now, we have no way of doing that, as the name for the subroutine is outside the scope of this rule. We'll handle this later, though, and in a pretty neat way I must say. Yacc can't hold a candle to it, you'll see!\nNote that the XL spec said nothing about \u0026quot;procedures must be declared after vars, consts and types.\u0026quot; This was one of the many things that the language designer told us during midnight interrogation... Similar to Pascal's definition order (CONST TYPE VAR FUNCTION/PROCEDURE) but not quite that rigid.\nBasic Declarations XL has three main declarations: variables, constants, and types:\n1basicDecl 2\t:\tvarDecl 3\t|\tconstDecl 4\t|\ttypeDecl 5\t; Just so this section isn't so short, I'll define varDecl and constDecl here.\nA variable declaration looks like:\n1varDecl 2\t:\t\u0026#34;var\u0026#34; identList COLON typeName 3\t(BECOMES constantValue)? 4\tSEMI 5\t; Unlike Pascal, each declaration must start with \u0026quot;var\u0026quot;; there is no \u0026quot;VAR section\u0026quot; that starts with the keyword VAR. The varDecl states that you can defined any number of idents at once, and you can optionally initialize the variable(s).\nA constant declaration is similar to a variable declaration, except that you use the keyword \u0026quot;constant\u0026quot; and must assign a value:\n1constDecl 2\t:\t\u0026#34;constant\u0026#34; identList COLON typeName 3\tBECOMES constantValue SEMI 4\t; In the above rules, subrules identList and constantValue are mentioned. These are:\n1identList 2\t:\tIDENT (COMMA IDENT)* 3\t; which says \u0026quot;one or more IDENTs separated by COMMAs\u0026quot;, and\n1constantValue 2\t:\tINTLIT 3\t|\tSTRING_LITERAL 4\t|\tIDENT 5\t; which is pretty self-explanatory. One thing to note, though, there there is nothing right now that prevents us from using a variable IDENT instead of a constant IDENT. That's handled later...\nType Declarations XL defines three user-defined types: arrays, records and enumeration types. In my project, I only defined arrays and records, so for now, I'll skip enumeration types. I may add them at another time.\nA type declaration is either an array declaration or a record declaration:\n1typeDecl 2\t:\t\u0026#34;type\u0026#34; IDENT EQUALS 3\t(\tarrayDecl 4\t|\trecordDecl 5\t) 6\tSEMI 7\t; I got a bit fancier here by using a subrule to say \u0026quot;array or record\u0026quot; instead of defining a new rule for it. This is also a bit more efficient than the extra function call created by another rule there. Basic rule of thumb -- if a subrule is clear, and not deeply nested, feel free to use it. However, watch out for using several nested subrules, as the meaning can get hidden quickly.\nArrays are defined as ARRAY [x..y] OF type. Only one-dimensional, pretty simple:\n1arrayDecl 2\t:\t\u0026#34;array\u0026#34; LBRACKET integerConstant DOTDOT integerConstant RBRACKET 3\t\u0026#34;of\u0026#34; typeName 4\t; 5 6integerConstant 7\t:\tINTLIT 8\t|\tIDENT // again, a constant... 9\t; Records are defined as RECORD x,y,z:typename; END RECORD. Again, simple until we have to know what it means:\n1recordDecl 2\t:\t\u0026#34;record\u0026#34; (identList COLON typeName SEMI)+ \u0026#34;end\u0026#34; \u0026#34;record\u0026#34; 3\t; So what is this typeName I keep bringing up? Well, it's either one of the predefined types, Integer or Boolean, or it's a user-defined type (which means its an IDENT), so:\n1typeName 2\t:\tIDENT 3\t|\t\u0026#34;Integer\u0026#34; 4\t|\t\u0026#34;Boolean\u0026#34; 5\t; Enough about types, now, on to\nProcedure Declarations A procedure in XL is similar to a program, so basically, it's a small heading followed by a subprogramBody:\n1procedureDecl 2\t:\t\u0026#34;procedure\u0026#34; IDENT (formalParameters)? EQUALS 3\tsubprogramBody 4\tSEMI 5\t; At the time I originally did this project, I only did procedures, not functions. Perhaps I'll add them later... (You may think \u0026quot;boy he left a lot out,\u0026quot; but Dr. Moore made a large subset of the project required, and I did a few extra point things, but not the whole thing. I was working full-time you know...)\nNotice that the formalParameters are optional... Let's define what they look like:\n1formalParameters 2\t:\tLPAREN parameterSpec (SEMI parameterSpec)* RPAREN 3\t; Again we see the familiar x (COMMA x) notation -- the ()* closure is very handy and efficient for matching lists of things...\n1parameterSpec 2\t:\t(\u0026#34;var\u0026#34;)? identList COLON typeName 3\t; You'll notice that this is quite a bit like a variable declaration, except that VAR is optional, and there's no semicolon after it. We'll handle it a bit differently as well, once we add action code.\nNext, we'll look at...\nStatements There are seven statements in XL (I told you it was a small language): assignment, exit, procedure call, return, if-then, loop and I/O.\n1statement 2\t:\texitStatement 3\t|\treturnStatement 4\t|\tifStatement 5\t|\tloopStatement 6\t|\tioStatement 7\t|\tprocedureCallStatement 8\t|\tassignmentStatement 9\t|\tendStatement 10\t; Assignment Statement The assignment statement is pretty much like Pascal's assignment statement, except that there are no type conversions allowed.\n1assignmentStatement 2\t:\tvariableReference BECOMES expression SEMI 3\t; Very simple, but the pieces (variable and expression) are somewhat complex -- we'll look at them after all the statements are done. We'll look at variableReference later...\nExit Statement The exit statement tells a loop it's done. It looks like\n1exitStatement 2\t:\t\u0026#34;exit\u0026#34; \u0026#34;when\u0026#34; expression 3\t; Procedure Call Statement A procedure call takes the form\n1procedureCallStatement 2\t:\tIDENT (actualParameters)? SEMI 3\t; 4 5actualParameters 6\t:\tLPAREN (expression (COMMA expression)*)? RPAREN 7\t; I extended XL just a bit for this. The original XL compiler I wrote had\n1actualParameters 2\t:\tLPAREN expression (COMMA expression)* RPAREN 3\t; which basically means that if you have parens, you must have at least one expression in them. I thought it would be nice to allow myfunc() as a valid procedure call.\nReturn Statement The XL return statement tells a procedure or function to return immediately. Keeping in mind that I did not implement functions (yet, at least), return cannot take an expression argument. Therefore, it's just\n1returnStatement 2\t:\t\u0026#34;return\u0026#34; SEMI 3\t; If Statement The XL \u0026quot;if-then-elsif-else-end if\u0026quot; statement is a fairly simple if type statement. This is because it is defined as a closed if statement; that is, there is a definite \u0026quot;I'm done\u0026quot; part to the if statement. Those of you who are familiar with the \u0026quot;dangling else\u0026quot; conflict present in the C language may realize that if you close the if statement, the conflict disappears. First, I'll present the rule for XL, then I'll talk a bit about how to do the if statement for C.\nXL's if statement looks like:\n1ifStatement 2\t:\t\u0026#34;if\u0026#34; expression \u0026#34;then\u0026#34; 3\t( statement )* 4\t(\t\u0026#34;elsif\u0026#34; expression \u0026#34;then\u0026#34; 5\t( statement )* 6\t)* 7\t( \u0026#34;else\u0026#34; ( statement )* )? 8\t\u0026#34;end\u0026#34; \u0026#34;if\u0026#34; SEMI 9\t; Which is the most straightforward way to write the rule. However, you may notice some redundancy in the rule -- there are two separate places where we'll need to deal with expression evaluation. Not a big deal now, but we'd need to duplicate code later. After staring at the rule for a bit, we might try splitting out the \u0026quot;expression THEN possible ELSE\u0026quot; stuff into a separate rule, and call it recursively if we get an ELSIF. In other words:\n1ifStatement 2\t:\t\u0026#34;if\u0026#34; ifPart \u0026#34;end\u0026#34; \u0026#34;if\u0026#34; SEMI 3\t; 4 5ifPart 6\t:\texpression \u0026#34;then\u0026#34; 7\t(statement)* 8\t(\t\u0026#34;elsif\u0026#34; ifPart 9\t|\t\u0026#34;else\u0026#34; (statement)* 10\t)? 11\t; Which is much less redundant.\nEarlier, I threatened to look at the \u0026quot;dangling else\u0026quot; problem. In ANTLR, this is an easy problem to solve. Basically, the problem is that in a statement like\nif (x)\rif (y)\rmyfunc();\relse\ryourfunc();\rIt isn't terribly apparent (to the compiler at least) which if-condition owns the \u0026quot;else\u0026quot; clause. The compiler can't tell if the inner if is an \u0026quot;if-without-an-else\u0026quot; inside an \u0026quot;if-with-an-else,\u0026quot; or vice-versa.\nOn the other hand, the language designers decided that the else will be owned by its most recent if that can possibly own it. In this case, the else would clearly belong to the (y) condition. However, the compiler doesn't know this.\nIn a yacc grammar, an if-statement for C might be written\n1ifStatement 2\t:\tIF LPAREN expression RPAREN statementList 3\t|\tIF LPAREN expression RPAREN statementList 4\tELSE statementList 5\t; which causes yacc to report a \u0026quot;shift/reduce\u0026quot; conflict -- yacc can't tell if you intended to have an \u0026quot;if-without-else\u0026quot; (the first alternative) be nested inside an \u0026quot;if-with-else\u0026quot; (the second alternative.) It doesn't know if it should reduce the first alternative when it sees the ELSE, or whether it should keep looking (shift the ELSE.) Fortunately, yacc's default is to shift the else, basically grouping the ELSE with its closest IF, which is exactly what we want.\nTo get yacc to stop reporting this (and explicitly specify which alternative we intend) requires the use of either some very messy (and hard-to-follow) rules, or explicit precedence assignment. Neither is pretty, or very readable for someone else.\nIn ANTLR, the C if statement would look like\n1ifStatement 2\t:\t\u0026#34;if\u0026#34; LPAREN expression RPAREN (statement)* 3\t( \u0026#34;else\u0026#34; (statement)* )? 4\t; which, of course, causes ANTLR to report a conflict. To get rid of this conflict, we can use a syntactic predicate (aka \u0026quot;guess\u0026quot; mode) which basically says \u0026quot;try this -- if it works, use it. Otherwise, try the next alt.\u0026quot;\nApplying a nice syntactic predicate to the ifStatement rule above yields\n1ifStatement 2\t:\t\u0026#34;if\u0026#34; LPAREN expression RPAREN (statement)* 3\t(\t(\u0026#34;else\u0026#34;)=\u0026gt; \u0026#34;else\u0026#34; (statement)* )? 4\t; which can a bit easier to read if you break the ( )? subrule into a \u0026quot;this-or-nothing\u0026quot; subrule.\n1ifStatement 2\t:\t\u0026#34;if\u0026#34; LPAREN expression RPAREN (statement)* 3\t(\t(\u0026#34;else\u0026#34;)=\u0026gt; \u0026#34;else\u0026#34; (statement)* 4\t|\t( ) // nothing 5\t) 6\t; The predicate says \u0026quot;try matching an ELSE. If you can, then use the first alt. Otherwise, use the second alt (the \u0026quot;nothing\u0026quot; alternative.) Note that we will be using the more compact ( )? form for our compiler.\nLoop Statement The loop statement in XL is pretty simple. (Anyone sick of the word \u0026quot;simple\u0026quot; yet? But it's true, really it is.) It's a set of statements enclosed by loop and end loop, with an optional while clause in front of it. It looks like\n1loopStatement 2\t:\t(\u0026#34;while\u0026#34; expression)? \u0026#34;loop\u0026#34; 3\t( statement )* 4\t\u0026#34;end\u0026#34; \u0026#34;loop\u0026#34; SEMI 5\t; Not too bad, eh? Well, just to confuse matters a bit, what would happen if XL allowed an END statement, like in BASIC? (BASIC's END statement exits the program immediately.) Come to think of it, what the heck, let's add one!\n1endStatement 2\t:\t\u0026#34;end\u0026#34; SEMI 3\t; Now why would I be mentioning this here? Let's look at some XL sample code:\nprogram sponge =\rvar x : integer := 1;\rbegin\rwhile x \u0026lt; 10 loop\rx := x + 1;\rend;\rend loop\rend sponge.\rKind of contrived (and useless, I know), and simple, until you look closer...\nWhat happens when the parser sees the end inside the loop? Let's look at the loopStatement rule again (repeated here 'cause you're a programmer which means you're too lazy to turn back a page):\n1loopStatement 2\t:\t(\u0026#34;while\u0026#34; expression)? \u0026#34;loop\u0026#34; 3\t( statement )* 4\t\u0026#34;end\u0026#34; \u0026#34;loop\u0026#34; SEMI 5\t; Assuming k=1 lookahead, we have a problem: how does the parser determine that the end in loop is an endStatement and not the end that is the first part of end loop? The answer is simple: with k=1 lookahead, it can't. It will always try to make it an endStatement, and will get a syntax error on loop. (Try this in the final recognizer, just for kicks.) You'll also get a conflict warning in ANTLR. (Note that you'll have the same conflict with end if in ifStatement -- our solution should, and will, handle both situations.)\nSo how do we solve this? Two possibilities: use k=2 lookahead, or use a syntactic predicate.\nTo use k=2 lookahead, you'd just need to specify k=2 as a parser option. This will make the ANTLR run take a bit more time, but should only affect checks that require two-token lookahead.\nIn our grammar, we only have one place (this one) that causes a conflict. (Remember that our ifStatement is closed with an end if, so there's no dangling else conflict.) So let's fix the problem in that spot using syntactic predicates. (I also want to cover syntactic predicates a bit, so I won't go with the easier k=2 fix... In real life, I think it might make a slightly faster parser to use k=2 for this case. Syntactic predicates should probably be reserved for cases when you don't know how much lookahead you'll really need, or the known lookahead is lengthy.)\nWe can tell ANTLR exactly how to distinguish an endStatement from the end of a loop. How? Simple (for me at least, 'cause I already know...):\n1statement 2\t:\t(\u0026#34;end\u0026#34; SEMI)=\u0026gt; endStatement 3\tassignmentStatement 4\t. . . 5\t; Now what the heck does that mean? Basically, it says \u0026quot;try to match END, then SEMI.\u0026quot; If it works, then we really want the endStatement. If we didn't get a match, try the next alternative, and so on...\nThere's one problem that I have with the above statement. I don't like spelling out END SEMI in a rule other than endStatement. It just seems like bad isolation of rules. I'm a bit picky at times, though. What I'd rather do is say to myself, hmmm, END SEMI is an endStatement, so why not put that inside the ( )=\u0026gt; -- like this:\n1statement 2\t:\t(endStatement)=\u0026gt; endStatement 3\t| assignmentStatement 4\t. . . 5\t; (Note: This will be a bit less efficient than spelling it out -- the \u0026quot;guess\u0026quot; that ANTLR will make will need to make a function call to endStatement to check for END SEMI rather than just directly check for END SEMI in the statement rule. However, as long as you don't do this too much, the penalty for a function call is minimal on most machines nowadays. Just keep it to a minimum!)\nWhat if endStatement were a bit more involved, such as\n1endStatement 2\t:\t\u0026#34;end\u0026#34; SEMI expression SEMI 3\t; (Kinda useless, but so are most examples.) All we need to predict it are the END and SEMI. If we keep the predicate as it is, (endStatement)?, the \u0026quot;guess\u0026quot; would keep going through expression (which could be pretty long) and the next SEMI. That would be mighty wasteful. So, in a case where we want to limit the lookahead, it's probably better to sacrifice readability a bit and limit the lookahead to just END SEMI:\n1statement 2\t:\t(\u0026#34;end\u0026#34; SEMI)=\u0026gt; endStatement 3\t|\tassignmentStatement 4\t. . . 5\t; (Look familiar?) You may ask \u0026quot;why not just put the (END SEMI)? in the endStatement rule itself?\u0026quot; Unfortunately, ANTLR complains about a rule like\n1endStatement 2\t:\t(\u0026#34;end\u0026#34; SEMI)=\u0026gt; \u0026#34;end\u0026#34; SEMI expression SEMI 3\t; basically telling you \u0026quot;why bother with a predicate -- there's only one alternative!\u0026quot; I think I'd prefer to be able to specify it like this, and have ANTLR hoist the predicate up into the statement rule (and possibly optimize it out of the endStatement rule altogether.) But let's work with the great tool we currently have, shall we?\nSo, we end up with two new rules:\n1loopStatement 2\t:\t(\u0026#34;while\u0026#34; expression)? \u0026#34;loop\u0026#34; 3\t(statement)* 4\t\u0026#34;end\u0026#34; \u0026#34;loop\u0026#34; SEMI 5\t; 6 7endStatement 8\t:\t\u0026#34;end\u0026#34; SEMI 9\t;\tand we modify the statement rule to look like\n1statement 2\t:\t(endStatement)=\u0026gt; endStatement 3\t|\tassignmentStatement 4\t|\texitStatement 5\t|\tprocedureCallStatement 6\t|\treturnStatement 7\t|\tifStatement 8\t|\tloopStatement 9\t|\tioStatement 10\t; But is the order important in the statement rule? Of course, but it's not so obvious until you look at what the generated code will say. The following isn't actual generated code, but pseudocode that will show what happens in the statement rule:\nstatement {\rif next token is \u0026quot;end\u0026quot; and guess(endStatement) worked\rdo endStatement\relse if next token is IDENT\rdo assignmentStatement\relse if next token is \u0026quot;exit\u0026quot;\rdo exitStatement\relse if next token is IDENT\rdo procedureCallStatement\relse if next token is \u0026quot;return\u0026quot;\rdo returnStatement\relse if next token is \u0026quot;if\u0026quot;\rdo ifStatement\relse if next token is (\u0026quot;while\u0026quot; or \u0026quot;loop\u0026quot;)\rdo loopStatement\relse if next token is (\u0026quot;put\u0026quot; or \u0026quot;get\u0026quot;)\rdo ioStatement (defined later)\r}\rA few things to notice here:\nMost of the conditions in this code are simple, one-test comparisons The condition for endStatement is much more complex Oooops! I see a conflict between assignmentStatement and procedureCallStatement -- hold this thought for a minute... Notice that loopStatement's lookup condition had two parts to it: WHILE or LOOP -- this is because the WHILE section is optional, making the FIRST set for loopStatement be {WHILE, LOOP} (ioStatement will be defined in a bit as a GET or PUT call...) All of the conditions are evaluated in the order that the rules are specified All of the conditions except assignmentStatement and procedureCallStatement have a unique test condition; their FIRST sets are disjoint Our goal when parsing is to make things as fast as possible. Therefore, based on the above information, we should\nOrder the rules such that the most likely/most used rules come first -- that means less conditions to test Order the rules such that rules with nasty conditions come later. Note that if the nasty condition is required to disambiguate two alternatives, it needs to be in the first of the two alternatives If possible, determine which statements are more likely to be used. Do some statistical sampling of user code (if possible) and order the rules accordingly. In this case, I think it's less likely that the user would use an END statement, and on top of that, it's more complex, so let's put it at the bottom of the list.\nWe also need to disambiguate assigmentStatement and procedureCallStatement. Recall that they look like:\n1assignmentStatement 2\t:\tvariableReference BECOMES expression SEMI 3\t; 4 5procedureCallStatement 6\t:\tIDENT (actualParameters)? SEMI 7\t; So, how do we tell them apart? First, let's look at the FIRST sets of each (the sets that contain all tokens that can be the first terminal in a rule.) Impossible until we define variableReference, so let's do that now (sorry about the jumping around here..)\n1variableReference 2\t:\tIDENT 3\t(\tLBRACKET expression RBRACKET 4\t|\tDOT IDENT 5\t)* 6\t; which says a variable reference is an IDENT followed by any number of array or field dereferences.\nWithout going into a long discussion about FIRST sets, what is the FIRST set of assignmentStatement? By inspection, it's whatever the FIRST set is of variableReference, which is {IDENT}. Again, by inspection, the FIRST set of procedureCallStatement is also {IDENT}. There, the conflict becomes very clear. On one token alone, IDENT, the parser cannot determine which rule is proper. Looking at the pseudocode above, it becomes obvious that the parser will, in fact, always choose whichever rule is specified first with a FIRST set of {IDENT}, which is bad. So, we need to add a predicate to one of the rules. But which one? Lets look at what would be needed for each. What makes each unique? assignmentStatement could start out with\nIDENT BECOMES . . . // just ident := expression\rIDENT LBRACKET . . . // starting with array reference\rIDENT DOT . . . // starting with field reference\rand procedureCallStatement could start out with (after looking at actualParameters)\nIDENT SEMI // No parameters (or parens)\rIDENT LPAREN . . . // parameters (or just parens)\rObviously, they are unique with two tokens of lookahead. So, we're back to the decision of \u0026quot;do we bump lookahead to k=2, or use predicates.\u0026quot; k=2 would resolve the conflict, but my gut says we should use a syntactic predicate here. But which one?\nThe predicates would look like:\n1statement 2\t:\t. . . 3\t|\t(IDENT (BECOMES|LBRACKET|DOT))=\u0026gt; assignmentStatement 4\t|\t(IDENT (SEMI|LPAREN))=\u0026gt; procedureCallStatement Well, the predicate for procedureCallStatement is actually a bit simpler. We probably should use it and put its alternative ahead of the one for assignmentStatement.\\ If your research proves that assignmentStatements are found in code more often than procedureCallStatements, you may want to reconsider, though.\nSo what do we end up with? Using our basic rule of \u0026quot;keep the simple stuff near the top\u0026quot; and adding syntactic predicates for endStatement and procedureCallStatement, we get (without taking into account statistical frequency of each statement):\n1statement 2\t:\texitStatement 3\t|\treturnStatement 4\t|\tifStatement 5\t|\tloopStatement 6\t|\tioStatement 7\t|\t(IDENT (LPAREN|SEMI))=\u0026gt; procedureCallStatement 8\t|\tassignmentStatement 9\t|\t(endStatement)=\u0026gt; endStatement 10\t; Now, on to our final statement...\nI/O Statement The I/O statement is really a procedure call to four predefined functions, get, put, skipLine and newLine. These really should be handled just like any other procedure call, but I'm putting them here just because that's how I did it the first time around, and because I don't want to mess with special pre-defined identifiers in the symbol table later...\n1ioStatement 2\t:\t\u0026#34;put\u0026#34; LPAREN expression RPAREN SEMI 3\t|\t\u0026#34;get\u0026#34; LPAREN variableReference RPAREN SEMI 4\t|\t\u0026#34;newLine\u0026#34; (LPAREN RPAREN)? SEMI 5\t|\t\u0026#34;skipLine\u0026#34; (LPAREN RPAREN)? SEMI 6\t; Note that I was nice and allow the user to put \u0026quot;()\u0026quot; after skipLine and newLine, just like we did for procedure calls in general.\nEasy enough. Now onto the sticky stuff...\nExpressions XL expressions are pretty similar to any old expressions you'd find in any old language (or in any new language, for that matter.) The stuff we do here will be pretty much the same in any parser or compiler you write in ANTLR, so pay attention! I know you're falling asleep after reading thirty-odd pages of drivel, but hang with me for a little longer!\nThere are a few things to notice about using ANTLR when you write expressions. The big one is that ANTLR is an LL(k) parser-generator. That means several things, but the biggest (with regard to expressions) is that left recursion is not allowed. See some compiler books for the details; in a nutshell\n1a : a PLUS a ; would generate code like\na() {\ra();\rmatch(PLUS);\ra();\r} which would obviously recursively call itself until you run out of stack space. There are several ways around this. You have probably seen the following type of code used to describe parts of expressions:\n1a 2\t:\ta PLUS a 3\t|\tt 4\t; To get rid of the left-recursion that renders LL(k) grammars helpless, you can use some wonderfully-mechanical algorithms to turn it into\n1a 2\t:\ta1 a_tail 3\t; 4a1 5\t:\tt 6\t; 7a_tail 8\t:\tPLUS t a\\_tail 9\t|\t// nothing 10\t; Yuck! It works, but how long did you have to think about it to understand what it means?\nNotice that the mechanically-generated code utilizes tail-recursion (recursion as the last element of a rule, also known as right-recursion) to keep adding (PLUS t) to the end of the \u0026quot;a\u0026quot; thing we are creating. Eventually, it ends with the empty (epsilon) production in place of a_tail\nThinking about right-recursion, recall that right recursion can always be replaced very easily by a loop. (From where do you recall this? I dunno. Some programming class.) In ANTLR, we have the advantage of being able to use ()* and ()+ closures using EBNF notation. In other words, we can easily represent loops. So, a rule like\n1a_tail 2\t:\tPLUS t a_tail 3\t|\t// nothing 4\t; can be re-written as\n1a_tail 2\t: (PLUS t)* 3\t; which is much better so far. Now look what we have:\n1a 2\t:\ta1 a_tail 3\t; 4a1 5\t:\tt 6\t; 7a_tail 8\t:\t(PLUS t)* 9\t; Notice something about a_tail now? Without the tail recursion, it's only used in one place, so we can substitute it. And while we're at it, let's substitute a1 in place as well, yielding\n1a 2\t:\tt (PLUS t)* 3\t; When we look at that, we see that that's exactly what we wanted. Basically, PLUS is associative, so the order in which you add things really doesn't matter. You can keep saying \u0026quot;PLUS something else\u0026quot; at the end of our PLUS expression. The above notation is actually very good, because it matches what your brain does as it adds new parts to the expression as it reads left-to-right.\nThe moral of the above nonsense is that an expression-like rule such as\n1a 2\t:\ta OPERATOR a 3\t|\tt 4\t; can be re-written\n1a 2\t:\tt (OPERATOR t)* 3\t; Now that we're armed, lets start organizing for our attack on XL's expression rules!\nPrecedence In the description of XL above, we defined that the operators have the following precedences:\ncategory operators precedence Boolean negation not highest Unary adding operators + - Multiplying operators * / mod Binary adding operators + - Relational operators = /= \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= Logical operators and or lowest What exactly does this mean? Well, it means that if we see a not somewhere in an expression, we should resolve it before we resolve any other operators (unless, of course, there are specific precedences specified by using parentheses.) So if we had an expression like\na and x or not y and 2 + -q * s \u0026lt; 10 we would first evaluate the \u0026quot;not\u0026quot; (let's use parentheses to specify evaluation grouping)\na and x or (not y) and 2 + -q * s \u0026lt; 10 then take care of the unary -\na and x or (not y) and 2 + (-q) * s \u0026lt; 10 then the *\na and x or (not y) and 2 + ((-q) * s) \u0026lt; 10 then the binary +\na and x or (not y) and (2 + ((-q) * s)) \u0026lt; 10 then the relational \u0026lt;\na and x or (not y) and ((2 + ((-q) * s)) \u0026lt; 10) then the boolean `and` and `or`\r(((a and x) or (not y)) and ((2 + ((-q) * s)) \u0026lt; 10)) Whoa! Is that right? In most languages, and has a higher precedence than or. But in our precedence chart for XL, and and or have the same precedence. So while we might expect to see the evaluation proceed like\n((a and x) or ((not y) and ((2 + ((-q) * s)) \u0026lt; 10))) that's not how it goes, because and and or have the same precedence, we have to just read them left to right. (In this situation, XL's design is less intuitive because of the preponderance of other languages that give and a higher precedence than or. But that was the language designer's choice, and we'll live with it.)\nSo what do we do with these precedences? Basically\neach level of precedence represents a rule in the grammar Each operator in that precedence level is one alternative in that rule The rules will nest with the highest precedence operators being the most-deeply nested rules Each precedence level will only imbed the next higher precedence level. The highest precedence level will only use \u0026quot;primitive\u0026quot; expression elements, such as variable references and literals. So lets start at the top of the precedence chart. I'm going to go out on a limb and avoid the terms term, factor, simple expression. I could never remember which was supposed to be which from a mathematics point of view. Instead, I'll follow Sun's lead in their Java grammar, and use more descriptive names.\nWe need to start with our primitive expression elements. In XL, these are constant values, variable references, and parenthesized expressions. Remember, parenthesizing an expression basically makes it the most important thing that is currently being evaluated.\n1primitiveElement 2\t:\tconstantValue 3\t|\tvariableReference 4\t|\tLPAREN expression RPAREN 5\t; So far so good. Now, let's just walk down the precedence chart. First, boolean negation:\n1booleanNegationExpression 2\t:\t(\u0026#34;not\u0026#34;)* primitiveElement 3\t; Notice that the NOT is optional here, and you can have as many of them as you like. That is because we want to be able to just pass any expression element through a rule without modifying it, enabling us to have an expression just be a primitiveElement if that's what the user wants. Next, we have unary PLUS and MINUS:\n1signExpression 2\t:\t(PLUS|MINUS)* booleanNegationExpression 3\t; Notice that the ( )* can evaluate to \u0026quot;no operators,\u0026quot; meaning that booleanNegationExpression can be passed straight through this precedence level without any modification.\nLet us have as many plusses or minuses in front of our expression so far. Next, we have our multiplying operators, *, / and mod:\n1multiplyingExpression 2\t:\tsignExpression ((TIMES|DIV|\u0026#34;mod\u0026#34;) signExpression)* 3\t; Which lets us keep tacking on multiplying operators ad nauseum.\nNotice that this precedence rule imbedded the previous rule, and again, can let it just pass signExpression right on through without modifying it. By now, things should be seeming a bit more clear. Next, we move onto the binary adding operations:\n1addingExpression 2\t:\tmultiplyingExpression ((PLUS|MINUS) multiplyingExpression)* 3\t; Will we have a conflict between an (PLUS|MINUS) acting as a binary add operator and one acting as a unary operator? No. The reason is that if we see one in between two partial expressions, it must be a binary operator. If we see another right after it (and any number of them after that) they must be working (covertly) as unary operators. Next we have the relational operators:\n1relationalExpression 2\t:\taddingExpression ((EQUALS|NOT_EQUALS|GT|GTE|LT|LTE) addingExpression)* 3\t; Finally, we get to the operators with the lowest precedence. At this level, we can call the result a full expression. This level encompasses and and or operators:\n1expression 2\t:\trelationalExpression ((\u0026#34;and\u0026#34;|\u0026#34;or\u0026#34;) relationalExpression)* 3\t; Tack on as many and/or partial expressions as you like...\nNow that we've gotten through expressions, it really doesn't seem so bad. The precedence table actually made it easier, rather than more confusing.\nAt this point, we have specified the entire grammar for an XL parser. You've already seen the entire scanner. The following is our parser:\n1//----------------------------------------------------------------------------- 2// Define a Parser, calling it XLRecognizer 3//----------------------------------------------------------------------------- 4class XLRecognizer extends Parser; 5 6options { 7\tdefaultErrorHandler = true; // Don\u0026#39;t generate parser error handlers 8} 9 10// Define some methods and variables to use in the generated parser. 11{ 12\t// Define a main 13\tpublic static void main(String[] args) { 14\t// Use a try/catch block for parser exceptions 15\ttry { 16\t// if we have at least one command-line argument 17\tif (args.length \u0026gt; 0 ) { 18\tSystem.err.println(\u0026#34;Parsing...\u0026#34;); 19 20\t// for each directory/file specified on the command line 21\tfor(int i=0; i\u0026lt; args.length;i++) 22\tdoFile(new File(args[i])); // parse it 23 24\t} else { 25\tSystem.err.println(\u0026#34;Usage: java XLRecogizer \u0026lt;directory name\u0026gt;\u0026#34;); 26\t} 27 28\t} catch(Exception e) { 29\tSystem.err.println(\u0026#34;exception: \u0026#34;+e); 30\te.printStackTrace(System.err); // so we can get stack trace 31\t} 32\t} 33 34\t// This method decides what action to take based on the type of 35\t// file we are looking at 36 37\tpublic static void doFile(File f) throws Exception { 38\t// If this is a directory, walk each file/dir in that directory 39\tif (f.isDirectory()) { 40\tString files[] = f.list(); 41\tfor(int i=0; i \u0026lt; files.length; i++) { 42\tdoFile(new File(f, files[i])); 43\t} 44 45\t// otherwise, if this is a java file, parse it! 46\t} else if ((f.getName().length()\u0026gt;5) \u0026amp;\u0026amp; 47\tf.getName().substring(f.getName().length()-3).equals(\u0026#34;.xl\u0026#34;)) { 48\tSystem.err.println(\u0026#34;-------------------------------------------\u0026#34;); 49\tSystem.err.println(f.getAbsolutePath()); 50\tparseFile(new FileInputStream(f)); 51\t} 52\t} 53 54\t// Here\u0026#39;s where we do the real work... 55\tpublic static void parseFile(InputStream s) throws Exception { 56\ttry { 57\t// Create a scanner that reads from the input stream passed to us 58\tXLLexer lexer = new XLLexer(s); 59 60\t// Create a parser that reads from the scanner 61\tXLRecognizer parser = new XLRecognizer(lexer); 62 63\t// start parsing at the compilationUnit rule 64\tparser.program(); 65 66\t} catch (Exception e) { 67\tSystem.err.println(\u0026#34;parser exception: \u0026#34;+e); 68\te.printStackTrace(); // so we can get stack trace 69\t} 70\t} 71} 72 73// the following tag is used to find the start of the rules section for 74// automated chunk-grabbing when displaying the page 75 76program 77\t:\t\u0026#34;program\u0026#34; IDENT EQUALS 78\tsubprogramBody 79\tDOT 80\t// end-of-file 81\t; 82 83subprogramBody 84\t:\t(basicDecl)* 85\t(procedureDecl)* 86\t\u0026#34;begin\u0026#34; 87\t(statement)* 88\t\u0026#34;end\u0026#34; IDENT 89\t; 90 91basicDecl 92\t:\tvarDecl 93\t|\tconstDecl 94\t|\ttypeDecl 95\t; 96 97varDecl 98\t:\t\u0026#34;var\u0026#34; identList COLON typeName 99\t(BECOMES constantValue)? 100\tSEMI 101\t; 102 103constDecl 104\t:\u0026#34;constant\u0026#34; identList COLON typeName 105\tBECOMES constantValue SEMI 106\t; 107 108identList 109\t:\tIDENT (COMMA IDENT)* 110\t; 111 112constantValue 113\t:\tINTLIT 114\t|\tSTRING_LITERAL 115\t|\tIDENT 116\t; 117 118typeDecl 119\t:\t\u0026#34;type\u0026#34; IDENT EQUALS 120\t(\tarrayDecl 121\t|\trecordDecl 122\t) 123\tSEMI 124\t; 125 126arrayDecl 127\t:\t\u0026#34;array\u0026#34; LBRACKET integerConstant DOTDOT integerConstant RBRACKET 128\t\u0026#34;of\u0026#34; typeName 129\t; 130 131integerConstant 132\t:\tINTLIT 133\t|\tIDENT // again, a constant... 134\t; 135 136recordDecl 137\t:\t\u0026#34;record\u0026#34; (identList COLON typeName SEMI)+ \u0026#34;end\u0026#34; \u0026#34;record\u0026#34; 138\t; 139 140typeName 141\t:\tIDENT 142\t|\t\u0026#34;Integer\u0026#34; 143\t|\t\u0026#34;Boolean\u0026#34; 144\t; 145 146procedureDecl 147\t:\t\u0026#34;procedure\u0026#34; IDENT (formalParameters)? EQUALS 148\tsubprogramBody 149\tSEMI 150\t; 151 152formalParameters 153\t:\tLPAREN parameterSpec (SEMI parameterSpec)* RPAREN 154\t; 155 156parameterSpec 157\t:\t(\u0026#34;var\u0026#34;)? identList COLON typeName 158; 159 160statement 161\t:\texitStatement 162\t|\treturnStatement 163\t|\tifStatement 164\t|\tloopStatement 165\t|\tioStatement 166\t|\t(IDENT (LPAREN|SEMI))=\u0026gt; procedureCallStatement 167\t|\tassignmentStatement 168\t|\t(endStatement)=\u0026gt; endStatement 169\t; 170 171assignmentStatement 172\t:\tvariableReference BECOMES expression SEMI 173\t; 174 175exitStatement 176\t:\t\u0026#34;exit\u0026#34; \u0026#34;when\u0026#34; expression 177\t; 178 179procedureCallStatement 180\t:\tIDENT (actualParameters)? SEMI 181\t; 182 183actualParameters 184\t:\tLPAREN (expression (COMMA expression)*)? RPAREN 185\t; 186 187returnStatement 188\t:\t\u0026#34;return\u0026#34; SEMI 189\t; 190 191ifStatement 192\t:\t\u0026#34;if\u0026#34; ifPart \u0026#34;end\u0026#34; \u0026#34;if\u0026#34; SEMI 193\t; 194 195ifPart 196\t:\texpression \u0026#34;then\u0026#34; 197\t(statement)* 198\t(\t\u0026#34;elsif\u0026#34; ifPart 199\t|\t\u0026#34;else\u0026#34; (statement)* 200\t)? 201\t; 202 203loopStatement 204\t:\t(\u0026#34;while\u0026#34; expression)? \u0026#34;loop\u0026#34; 205\t(statement)* 206\t\u0026#34;end\u0026#34; \u0026#34;loop\u0026#34; SEMI 207\t; 208 209endStatement 210\t:\t\u0026#34;end\u0026#34; SEMI 211\t; 212 213variableReference 214\t:\tIDENT 215\t(\tLBRACKET expression RBRACKET 216\t|\tDOT IDENT 217\t)* 218\t; 219 220ioStatement 221\t:\t\u0026#34;put\u0026#34; LPAREN expression RPAREN SEMI 222\t|\t\u0026#34;get\u0026#34; LPAREN variableReference RPAREN SEMI 223\t|\t\u0026#34;newLine\u0026#34; (LPAREN RPAREN)? SEMI 224\t|\t\u0026#34;skipLine\u0026#34; (LPAREN RPAREN)? SEMI 225\t; 226 227primitiveElement 228\t:\tconstantValue 229\t|\tvariableReference 230\t|\tLPAREN expression RPAREN 231\t; 232 233booleanNegationExpression 234\t:\t(\u0026#34;not\u0026#34;)* primitiveElement 235\t; 236 237signExpression 238\t:\t(PLUS|MINUS)* booleanNegationExpression 239\t; 240 241multiplyingExpression 242\t:\tsignExpression ((TIMES|DIV|\u0026#34;mod\u0026#34;) signExpression)* 243\t; 244 245addingExpression 246\t:\tmultiplyingExpression ((PLUS|MINUS) multiplyingExpression)* 247\t; 248 249relationalExpression 250\t:\taddingExpression ((EQUALS|NOT\\_EQUALS|GT|GTE|LT|LTE) addingExpression)* 251\t; 252 253expression 254\t:\trelationalExpression ((\u0026#34;and\u0026#34;|\u0026#34;or\u0026#34;) relationalExpression)* 255\t; Now we need to discuss...\nANTLR Glue I like to call the code that wraps the scanner specification and grammar specification together into an ANTLR \u0026quot;grammar\u0026quot; file the \u0026quot;ANTLR glue.\u0026quot; It's a bit messy at first, but if we really think about what it does, step-by-step, at least some of the mystery should disappear.\nFirst, let's look at the overall design of a ANTLR-based parser.\nLet's consider what information we already have. We have already defined how we want to group input characters into tokens in our scanner definition. We have defined the syntax of our language in our grammar definition. But what gets generated when these definitions are processed by ANTLR?\nWe need the startup code (a \u0026quot;main\u0026quot; function), a shell class to hold the parser definition, and references to all the fun definitions that ANTLR needs to create an executable. Without saying much more (I may later), we have the following. Note that we'll be changing some of it later when we add trees, symbols and other compiler goodies...\n1header { 2\t...definitions that need to go at top of all generated files... 3} 4 5{ 6\t...Stuff at the top of generated files based on this file... 7\t...Note that stuff in these { } will appear after anything 8\t...in the header { } code... 9} 10 11class **_ParserNameGoesHere_** extends Parser; 12options { 13\t...parser options... 14} 15 16{ 17\t...your parser method/variable definitions... 18 19\t// a sample main 20 21\tpublic static void main(String[] args) { 22\t// Use a try/catch block for parser exceptions 23\ttry { 24\tInputStream input = new FileInputStream(args[0]); 25\tXLLexer lexer = new XLLexer(s); 26\tXLRecognizer parser = new XLRecognizer(lexer); 27\tparser.program(); 28\t29\t} catch (Exception e) { 30\tSystem.err.println(\u0026#34;parser exception: \u0026#34;+e); 31\te.printStackTrace(); // so we can get stack trace\t32\t} 33\t} 34} 35 36...parser rules go here... 37 38class _**ScannerNameGoesHere**_ extends Lexer; 39 40options { 41\t...scanner options... 42} 43 44{ 45\t...your scanner method/variable definitions... 46} 47 48...scanner rules go here... Now we know everything that needs to go into our recognizer. Understanding the ANTLR Compilation Process The Files Involved At some point I will expand on this a bit more to help understand how all the pieces fit together. For now, it may be a bit sketchy...\nThe following parts are involved when building your ANTLR parser. (Assume that you save your parser as xl.g):\nfile description xl.g Your grammar source file XLParser.java generated by ANTLR -- contains the class definition for the generated parser XLLexer.java generated by ANTLR -- contains the class definition for the generated scanner XLTokenTypes.java generated by ANTLR -- contains an interface definition that lists constant values for the token vocabulary.Â Note that the name of this interafce is determined by the name of the tokenVocabulary option. Generating and Compiling your Parser To build this tutorial, you can use Apache Ant. You can download Ant from http://ant.apache.org/. Ant provides an optional task that runs ANTLR. To build a grammar with this task, you add\n1\u0026lt;antlr target=\u0026#34;src/com/javadude/xl1/xl1.g\u0026#34;\u0026gt; 2\t\u0026lt;classpath path=\u0026#34;lib/antlr.jar\u0026#34; /\u0026gt; 3\u0026lt;/antlr\u0026gt; The tutorial download includes an ANTLR.jar in its lib directory. You can choose a different ANTLR.jar by specifying it in the classpath tag.\nIf you've been editing your own grammar, you can tweak the \u0026quot;xl1\u0026quot; rule in build.xml to specify your grammar name. Otherwise, you can build the provided grammar, xl1.g.\nTo run the first build, open a command prompt, navigate to the tutorial directory, and enter\nant xl1\rWhat happened? It looks like we have a few grammar problems. Let's look at them.\nRemember our discussion about adding END as a statement. Looks like it came back and bit us on the butt. But why?\nThe rules that are giving us trouble are rules like\n1subprogramBody 2\t:\t(basicDecl)* 3\t(procedureDecl)* 4\t\u0026#34;begin\u0026#34; 5\t(statement)* 6\t\u0026#34;end\u0026#34; IDENT 7\t; The problem is that the ( )* closure needs to determine when to exit. ANTLR checks to see if the \u0026quot;next\u0026quot; thing in the closure is also the first thing after the closure.Â This makes the closure ambiguous.Â Did you really mean to stay in the loop when it sees \u0026quot;end\u0026quot; as the next token, or jump out of the loop?\nRemember that we disambiguated the \u0026quot;end\u0026quot; in the statement rule.Â This was intended to force us to use endStatement when we saw an end statement.Â However, it is the wrong place to do it.Â The conflict is being caused at the level of the (statement)* loop.\nIf we just move the predicates up to the (statement)* closures, it may work, but now we have extra predicates all over the grammar. Our goal was to fix the lookahead problem in a single place. So let's create a single place. Instead of using (statement)* to represent a statement list, we'll create a rule called statementList:\n1statementList 2\t:\tstatementList statement 3\t|\t// nothing 4\t; Some of you may be saying \u0026quot;but...\u0026quot; but I'll cut you off because I've spent too much time in yacc-land recently. Silly me coded the rule this way. Yup, left-recursion, an LL no-no, but I'm not too proud to admit I make these mistakes sometimes. ANTLR is very nice about it and reports\nerror: line 197: infinite recursion to rule statementList from\rrule statementList So I shake my head in disbelief that I typed it (10 minutes before writing this) and change it to\n1statementList 2\t:\tstatement statementList 3\t|\t// nothing 4\t; and compile again...\nBetter; we're still getting the message about the END statement. But now the conflict is isolated to one spot. The conflict is that we can choose statement when we see \u0026quot;END\u0026quot; in the input stream, or say \u0026quot;we're done with the statementList\u0026quot; because it can be followed by \u0026quot;END.\u0026quot; It is in this rule that we need to make the decision. So...\n...we could put a syntactic predicate around the call to statement. But that would be incrediby wasteful. A \u0026quot;guess\u0026quot; parse would take place for every statement. Not good. But we still need to make a guess at this point. So what do we do?\nWe move the endStatement out of the statement rule and into statementList:\n1statementList 2\t:\tstatement statementList 3\t|\t(endStatement)=\u0026gt; endStatement statementList 4\t|\t// nothing 5\t; And now, the conflict disappears. We have applied the syntactic predicate to the point of the conflict.\nAfter we compile this, we have one last conflict.\nwarning: line 265: nondeterminism upon\rk==1:IDENT\rbetween alts 1 and 2 of block In primitiveElement we have a choice between constantValue and variableReference which could both be an IDENT! Why do we have IDENT in both places? Because the semantics, (the meanings) of the references are different. This should be a hint that we will need a semantic predicate to properly resolve this (without mangling the grammar.) The semantic predicate we will be using will say \u0026quot;if the IDENT is a constant, match constantValue; if it's not, match variableReference.\u0026quot; That type of check requires a symbol table, which we don't have yet. So, we leave this conflict in the grammar. This will produce code for primitiveElement like\nprimitiveElement() {\rif next token is IDENT || STRING_LITERAL || INTLIT\rcall constantValue\relse if next token is IDENT\rcall variableReference\relse if next token is LPAREN\rmatch LPAREN\rcall expression\rmatch RPAREN\relse\rreport error\rwhich means that an IDENT that could come in a primitiveElement context will be matched through constantValue. This is a bit of a problem, because things like a[4] cannot be matched, as they are handled by variableReference. Since constantValue only uses a single IDENT by itself, we won't lose anything by swapping it with variableReference, so swap 'em!\nTo compile the new version of the grammar, you can run\nant xl2\rBuilding the java code and running tests. If you run ant without any options, it will perform a full build on the new xl2.g file and run some sample tests against it.\nWrapup This wraps up the recognizer section of this tutorial. I hope it's been helpful at some level for you. As always, please let me know your comments (good or bad -- helps the ego ya know) at scott@javadude.com.\n","link":"https://javadude.com/post/20000304-antlrtut/","section":"post","tags":["java","antlr","parsing","language","dsl"],"title":"An ANTLR 2.0 Tutorial"},{"body":"","link":"https://javadude.com/tags/beans/","section":"tags","tags":null,"title":"Beans"},{"body":"Converting from LALR to LL can be challenging... Hopefully this article will make it a weeeeee bit simpler...\nThis is from a post of mine in a thread about automated tools to convert from LALR grammars to LL grammars... NOTE: These are fairly general (but pointed to PCCTS 1.33 -- note that PCCTS 2.0 does not implement syntactic predicates with setjmp/longjmp)\nToolwise, I think you're pretty much SOL. But there are several common algorithms available that you could probably use to write a simple tool.\nHOWEVER, I don't think you'd really want the code they'd generate, and hand-written ANTLR rules using its EBNF notation are much more maintainable.\nThere are two \u0026quot;big\u0026quot; issues to deal with in the conversion (and some minor headaches as well):\nProblem: Common Prefixes An LL(k) parser cannot choose between two rules that have the same k-token lookahead. For example, if k=1 (LL(1)), the following is ambiguous:\n1a 2 : A B C 3 | A D E 4 ; The above ambiguity will disappear if you specify k=2 -- the parser will look at the \u0026quot;B\u0026quot; or \u0026quot;D\u0026quot; after the \u0026quot;A\u0026quot; to determine which way to go. But, this can be inefficient, as the parser must look 2 tokens ahead in every prediction expression!\nAn LALR(1) parser doesn't have trouble with this because it is essentially \u0026quot;trying all the alts at once\u0026quot; and deciding which to use when it has enough info.\nAn LL(k) parser predicts which alt to take based on the next k tokens it sees in the input stream.\nSo what to do in a general case? There are a few possibilities:\nUp the value of k (lookahead) This may work, but will cause a performance hit and only covers an certain set of cases\nLeft factor In the above example (in ANTLR), left-factoring this would result in:\n1a 2 : A (B C | D E) 3 ; Now the parser just matches \u0026quot;A\u0026quot;, then makes another decision on which alternative based on \u0026quot;is the next token B or D?\u0026quot; Note that this could also be written\n1a 2 : A a_rest 3 ; 4a_rest 5 : B C 6 | D E 7 ; if you prefer. However, this creates another function call (ANTLR generates recursive-descent parsers.) Use your judgement as to when to create separate rules as opposed to subrules. Ask \u0026quot;is it readable? Does it make more sense to keep stuff in one rule?\u0026quot; and so on...\nAdd syntactic predicates There may be cases when it is very difficult/impossible to left factor, or you really need \u0026quot;infinite lookahead\u0026quot; (C++ is a great example of this with decl vs. expr)\nSyntactic predicates are a feature of ANTLR that says \u0026quot;if my first k tokens match, try me -- if I work, use me. Otherwise, try the next possibility\u0026quot;\nSay you may have a silly rule like\n1a 2 : A A A A A A B 3 | (A)+ B 4 ; Basically, we want to do a certain action if we see 6 A's then a B. Any other number of A's followed by a B does something else. (Yes -- you could just count the A's in the (A)+ part of the rule, but suppose I was stubborn and insisted you follow me...)\nThis rule would need 7 token lookahead, or some really nasty splitting up that would make the meaning unclear (or, don't say it, a counter in the (A)+...) By changing the rule to\n1a 2 : (A A A A A A B)? 3 | (A)+ B 4 ; You tell ANTLR to construct a parser that will \u0026quot;try\u0026quot; the first alt, and if it works, use it. Otherwise, _don't_ display a message and try the next alt and so on. Note that the \u0026quot;guess\u0026quot; it is taking doesn't execute action code, and if the \u0026quot;guess\u0026quot; says use that rule, it needs to re-run the match to run the actions.\nSyntactic predicates are your friend, but they are costly if overused. Also, be warned that they are implemented using setjmp/longjmp, which could cause problems if you create objects and need them destructed -- be careful!\nProblem: Left Recursion This one requires a bit of thought, but usually not too much.\nSuppose we have a rule\n1a 2 : a B C 3 | //nothing 4 ; Think about what that means -- any number of \u0026quot;B C\u0026quot; pairs. Just rewrite it as\n1a 2 : (B C)* 3 ; be careful as to the use of * vs + -- in the above, a can be empty, so * was used. this could also be written as a tail-recursive rule, but the first method is more efficient as it just generates a match loop, not extra function calls. (Use the (...)* and (...)+ constructs when possible to avoid recursive calls -- they save on performance!)\nLeft recursion is also prevalent in expression rules. Things like\n1expr 2 : expr \u0026#34;+\u0026#34; expr 3 | expr \u0026#34;-\u0026#34; expr 4 | expr \u0026#34;\\*\u0026#34; expr 5 ; and so on.\nTo rewrite the expression rules in LL(k) form, you'll need to break them up by the precedence of the operators. Start with a rule like \u0026quot;primary\u0026quot; that just lists the \u0026quot;atomic\u0026quot; elements of an expression, like variable, constant and (expr):\n1primary 2 : variable 3 | constant 4 | LPAREN expr RPAREN 5; then work your way down the precedence table, starting with the highest-level precedence operators, like NOT:\n1unary_expr 2 : (unary_operator)* primary 3 ; then go to the next level (suppose it's multiplicative operators)\n1mult_expr 2 : unary_expr (mult_op unary_expr)* 3 ; then the next level\n1add_expr 2 : mult_expr (add_op mult_expr)* 3 ; and so on. The idea is that things at each level of the precedence table reference the things at the next higher precedence level, possibly adding their own operators. In general\n1level_n_expr 2 : level_n-1_expr (level_n_op level_n-1_expr)* 3 ; making sure to use (...)* and NOT (...)+\nMost (if not all) yacc grammars can be converted into ANTLR grammars, but I suggest you use thought to do it rather than mechanical force (unless there's a mechanical force that smart enough, which I doubt.) It doesn't take too long to do it, either. A few other things to remember about ANTLR:\nAction code can be placed anywhere in rules without adding conflicts (although placing them at the start of a rule makes it and \u0026quot;init action\u0026quot; rather than a normal action -- see the docs\nYou can pass/return values to/from other rules as parameters to the rules. This is a GREAT feature that you just can't do in yacc due to the nature of LALR parsing try to use label names instead of label numbers (as in yacc) this'll save tons of headache when you need to make a mod like adding a rule reference to a rule.\nYACC\n1a 2 : B C {$$ \\= do($1, $2);} 3 ; ANTLR\n1a 2 : b:B c:C \u0026lt;\u0026lt;$0 \\= do($b, $c);\u0026gt;\u0026gt; 3 ; (keep in mind that you can only label terminals -- if you need a result from a subrule, pass it back as a return value)\nGood luck!\n","link":"https://javadude.com/post/20000304-lalr-to-ll/","section":"post","tags":["parsing"],"title":"Converting a Grammar from LALR to LL"},{"body":"Property editors are a way to make your bean more user-friendly.Â Bean builder tools can determine quite a lot about your bean just by looking at it and its corresponding BeanInfo class, but they usually have only very simple methods of editing the properties in the bean.\nMany properties can be represented as a String, number or Color, and most Bean design tools have built-in editors for these types.Â But if a property is another type of object, you must tell the design tool how to edit it.\nThe JavaBean spec defines a PropertyEditor interface in the java.beans package.Â This interface has several ways of reading and writing information about a property.Â This tutorial will walk you though several examples, from very simple String-validation editors to more complex GUIs to define properties.\nUnfortunately, the documentation available on property editors is rather sparse.Â Until now, that is...\nAll source code is available for download in zip (Windows) and tar.gz (Unix) formats under #Source Code at the end of the article.\nYou should be able to use any development environment that supports JavaBeans to work with the code in this article.Â Note that all code has been tested under VisualAge for Java 1.0, Visual Cafe for Java 2.1 and the November release of the BeanBox.Â VisualAge and VisualCafe both performed as expected.\nThe BeanBox acts unexpectedly in a few cases.Â I have checked with the folks at JavaSoft to see if these are bugs in the BeanBox and they informed me that they are.Â The problems noted in BeanBox are:\nIf you provide a non-null return from getAsText() and provide a non-null getCustomPropertyEditor(), the BeanBox gives you no way of accessing the custom property editor GUI. If you only provide getAsText(), setAsText(), getValue(), setValue() and getJavaInitializationString(), the BeanBox will ignore the property changes.Â (It seems like the BeanBox requires PropertyChangeEvents in all cases, which is not required by the way I interpret the JavaBeans spec.) Making Life Easier Before getting into the actual property editors, let's define a convenience \u0026quot;adapter\u0026quot; class for the PropertyEditor interface.Â This adapter will provide default behaviors for all the PropertyEditor methods, and we can use it as a convenient superclass for the rest of our property editors.Â We'll discuss the methods in this interface as we proceed through the article.\nAdapters make life a bit easier for us because we don't have to define all the methods ourselves; we just need to override the ones that we really care about.\n1// A simple adapter class for interface java.beans.PropertyEditor 2package com.magelang.adapter; 3 4import java.beans.PropertyEditor; 5import java.beans.PropertyChangeListener; 6import java.awt.Rectangle; 7import java.awt.Graphics; 8import java.awt.Component; 9 10public class PropertyEditorAdapter implements PropertyEditor { 11\tpublic void addPropertyChangeListener(PropertyChangeListener listener) {} 12\tpublic void removePropertyChangeListener(PropertyChangeListener listener) {} 13\tpublic void setAsText(String text) throws IllegalArgumentException {} 14\tpublic void setValue(Object value) {} 15\tpublic void paintValue(Graphics gfx, Rectangle box) {} 16\tpublic String getAsText() {return null;} 17\tpublic Component getCustomEditor() {return null;} 18\tpublic String getJavaInitializationString() {return null;} 19\tpublic String[] getTags() {return null;} 20\tpublic Object getValue() {return null;} 21\tpublic boolean supportsCustomEditor() {return false;} 22\tpublic boolean isPaintable() {return false;} 23} Note that the JDK provides a class java.beans.PropertyEditorSupport that is very similar to this adapter (it adds better default support for property change notification and getAsText/setAsText.Â I present this simpler adapter so we can avoid talking about property change events until later.Â When you're really creating a property editor, you may want to use java.beans.PropertyEditorSupport.\nThe negative angle to using this approach is that your property editor cannot be directly included in another GUI, such as a Customizer.Â If you want to use a property editor as a general bean as well as only a property editor, you can either:\nSubclass your property editor from some component class (such as Panel) directly, and implement all of the above methods in your property editor, or Create a wrapper bean for your property editor that is a component, and displays the property editor's GUI (you can get the GUI by calling getCustomEditor() from your wrapper...) Note that if you extend Panel or another GUI component, you don't need to define the addPropertyChangeListener or removePropertyChangeListener methods as they are defined in java.awt.Component.\n##Persistence in Bean Builders\nIt is very likely that once a user has set properties for bean, they'd like to see those properties appear in your property editor the next time they bring up the property sheet.Â To provide this capability, property editors can define setValue() and getValue().Â Strictly speaking, you're not require to provide real implementations for these methods.Â But if you don't, you may find some annoyed users at your door the day after release...\npublic void setValue(Object value) gives the bean builder a way to tell the property editor the current value of the property being edited.Â For many fields this value will initially be null, but as the user edits the properties, the bean builder will store the values and pass them to the property editor when the property sheet is displayed.Â The property editor can look at this value but it should not directly modify it!Â The property editor should create a new object to hold the value for the property, and return that new object when the bean builder asks for it.\npublic Object getValue() provides a way for a bean builder to ask for the property value it will store with the visual design information.Â This value will be kept and passed to setValue() any time the property sheet for the bean instance is opened.Â The property editor is responsible for creating an object containing the value for the property, and returning that object.\nStarting Simple: String Editors All Bean design tools will have some way of displaying a text field to get a String property value.Â There is no validation done on this text field.\nAs our first property editor, we'll define a Color editor that has the user type in a color name and verify that the color name is one of the \u0026quot;basic\u0026quot; colors.\nString property editors are fairly simple to program.Â Interaction between a String property editor and the bean builder works as follows\nThe bean builder tells the property editor the current value of the property by calling the setValue() method The bean builder asks \u0026quot;what String should be displayed\u0026quot; by calling the getAsText() method. When the user changes the String value, the bean builder tells the property the new value by calling the setAsText() method. The bean builder asks for the object value to store for the property by calling the getValue() method. The bean builder asks for the code that will initialize the property by calling getJavaInitializationString() One thing to note here: the bean builder is handling the interaction with the user, and informs the property editor when changes are made.Â The property editor does not need to worry about informing anyone of the property being changed.Â (This will become an issue when our property editor handles the user interaction and needs to inform the bean builder that the property value has changed.)\nOur implementation of this simple property editor looks as follows.Â Note that we subclass PropertyEditorAdapter so we only need to define the five methods mentioned above.\n1package coloredit; 2 3import java.awt.Color; 4import com.magelang.adapter.PropertyEditorAdapter; 5 6// An overly simple Color editor. The user types in the textual 7// name of a color and this class verifies that it is a basic color 8// name. If it isn\u0026#39;t, the color is set back to white. 9 10//Demonstrates use of the setAsText() and getAsText() methods. 11public class ColorEditor1 extends PropertyEditorAdapter { 12\t// Used to validate the color name 13\t// (this property is protected to make the second 14\t// editor a bit easier...) 15\tprotected static String colorNames[] = { 16\t\u0026#34;white\u0026#34;, \u0026#34;lightGray\u0026#34;, \u0026#34;gray\u0026#34;, \u0026#34;darkGray\u0026#34;, \u0026#34;black\u0026#34;, 17\t\u0026#34;red\u0026#34;, \u0026#34;pink\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;yellow\u0026#34;, \u0026#34;green\u0026#34;, 18\t\u0026#34;magenta\u0026#34;, \u0026#34;cyan\u0026#34;, \u0026#34;blue\u0026#34; 19\t}; 20 21\t// Used to map a color name to a Color object 22\tprivate static Color colors[] = { 23\tColor.white, Color.lightGray, Color.gray, Color.darkGray, 24\tColor.black, Color.red, Color.pink, Color.orange, 25\tColor.yellow, Color.green, Color.magenta, 26\tColor.cyan, Color.blue 27\t}; 28 29\t// The currently-selected color (start with white) 30\tprivate int selected = 0; 31\t32\t//Tells the bean builder the name of the current color 33\tpublic String getAsText() { 34\treturn colorNames[selected]; 35\t} 36 37\t// Allows the bean builder to tell the property editor the value 38\t// that the user has entered 39\tpublic void setAsText(String text) throws IllegalArgumentException { 40\tfor(selected = 0; 41\tselected \u0026lt; colorNames.length \u0026amp;\u0026amp; 42\t!colorNames[selected].equals(text); 43\tselected++); 44\tif (selected == colorNames.length) 45\tselected = 0; 46\t} 47 48\t// Tells the bean builder the value for the property 49\tpublic Object getValue() { 50\treturn colors[selected]; 51\t} 52 53\t// Allows the bean builder to pass the current property 54\t// value to the property editor 55\tpublic void setValue(Object value) { 56\tselected = 0; 57\tif (value != null) 58\tfor(int i=0; i\u0026lt;colors.length; i++) 59\tif (value.equals(colors[i])) { 60\tselected = i; 61\tbreak; 62\t} 63\t} 64 65\t// Get the initialization code for the property 66\tpublic String getJavaInitializationString() { 67\treturn \u0026#34;java.awt.Color.\u0026#34; + colorNames[selected]; 68\t} 69} This property editor converts the passed-in Color value to a String representing the color name, validates that name whenever it is set, and converts it back to a Color object.\nUsing the Property Editor There are two ways you can use property editors:\nTo provide editing capabilities for a specific property in a bean To provide editing capabilities for all properties of a given type in the bean development environment This article will concentrate on the first use.Â A later article will discuss setting up a property editor as the default editor for a given type.\nTo associate a property editor with a bean property, you need to define a BeanInfo class for the bean.Â Of course this means that we need a bean, so let's define a simple Panel subclass that has a \u0026quot;color\u0026quot; property whose implementation is to set/get the Panel's background color. (We will leave the background property intact so operation of this property editor can be compared to normal Color editor operation in the bean builder you are using.)\n1package coloredit; 2 3import java.awt.Color; 4import java.awt.Panel; 5 6// A Simple Panel extension that we\u0026#39;ll use to test our 7// property editor 8public class ColorBean extends Panel { 9\t// note that there is no real \u0026#34;color\u0026#34; field; 10\t// a property can be strictly algorithmic... 11\tpublic Color getColor() {return getBackground();} 12\tpublic void setColor(Color color) {setBackground(color);} 13} The BeanInfo class for this is big and hairy, and discussion of BeanInfo is out of the scope of this article.Â (I'd advise you to get a tool, such as VisualAge for Java, that generates the BeanInfo class for you...) The following is the relevant part of the ColorBeanBeanInfo class that sets up the property editor.Â The full BeanInfo class (as generated by VisualAge for Java) is available in the source distribution.\n1package coloredit; 2 3// Relevant parts of the ColorBeanBeanInfo class 4// Note that exception handling has been removed 5// and the relevant parts 6// have been simplified... 7 8import java.beans.PropertyDescriptor; 9import java.beans.SimpleBeanInfo; 10import java.lang.reflect.Method; 11import java.awt.Color; 12import coloredit.ColorEditor1; 13 14public class ColorBeanBeanInfo extends SimpleBeanInfo { 15\tpublic PropertyDescriptor colorPropertyDescriptor() { 16\t// get the \u0026#34;get\u0026#34; method 17\tClass aGetMethodParameterTypes[] = {}; 18\tMethod aGetMethod = 19\tgetBeanClass().getMethod(\u0026#34;getColor\u0026#34;, 20\taGetMethodParameterTypes); 21 22\t// get the \u0026#34;set\u0026#34; method 23\tClass aSetMethodParameterTypes = {Color.class}; 24\tMethod aSetMethod = 25\tgetBeanClass().getMethod(\u0026#34;setColor\u0026#34;, 26\taSetMethodParameterTypes); 27 28\t// define the property descriptor 29\tPropertyDescriptor aDescriptor = 30\tnew PropertyDescriptor(\u0026#34;color\u0026#34;, aGetMethod, aSetMethod); 31\t// Set a property editor 32\taDescriptor.setPropertyEditorClass(ColorEditor1.class); 33\treturn aDescriptor; 34\t} 35 36\tpublic PropertyDescriptor[] getPropertyDescriptors() { 37\tPropertyDescriptor aDescriptorList[] = 38\t{colorPropertyDescriptor()}; 39\treturn aDescriptorList; 40\t} 41 42\t// and more BeanInfo stuff... 43} When you use the ColorBean when visually designing a new bean, you can bring up the property sheet for the new instance of the ColorBean.Â Initially, the value for \u0026quot;color\u0026quot; will be \u0026quot;white\u0026quot;.Â If you change it to one of the valid color names, the change will stick.Â If you mistype, the color value becomes \u0026quot;white\u0026quot; again.\nMaking the Property Editor a Bit Nicer... Because we have a (small) finite set of values, a nicer user interface would be to give the user a list of choices.Â This is easily accomplished by adding a getTags() method to our color editor.Â If getTags() returns a null (which is the default that we defined in PropertyEditorAdapter) the bean builder will just present a TextField to get the value.Â If getTags() returns an array of Strings, the bean builder will present a Choice component with those String values.Â So we can extend our ColorEditor as follows:\n1package coloredit; 2 3public class ColorEditor2 extends ColorEditor1 { 4\tpublic String[] getTags() { 5\treturn colorNames; 6\t} 7} This is possible because we defined colorNames as a protected field (even before we thought of this extension ;)\nIf we change the ColorBeanBeanInfo definition to use ColorEditor2, the property can now be edited by the user selecting the color choice in the property sheet.\nTaking Control of the Property Edit Up until this point, we've let the bean builder tool handle the interaction with the user.Â For simple properties that can be represented by Strings this is perfectly acceptable.Â (For example, perhaps you want to have the user type a name and you want to make sure it's a valid word in the Dictionary.Â Your property editor could be similar to ColorEdit1, but do a spell-check on the value instead of checking the color.)Â For more complex properties, such as Colors, we really want something more, well, colorful...\nLet's take a small step toward a better property editor.Â We'll present a Choice component with the color names.Â This will require the following:\nWe need to create a simple GUI (the Choice component) We need to tell the bean builder that we provide the GUI We need to pass the GUI to the bean builder We need to tell the bean builder when the property has changed Let's look at the last item first: we need to tell the bean builder when the property has changed.Â The PropertyEditor interface requires methods addPropertyListener() and removePropertyListener(), which let other classes ask us to inform them when a property changes.Â The other class, in this instance, is the bean builder itself.\nLet's take our PropertyEditorAdapter and extend it to add the property change notification support we need.Â The JDK provides a support class, java.beans.PropertyChangeSupport, that will help us.Â All we need is:\n1package com.magelang.adapter; 2 3import java.beans.PropertyChangeSupport; 4import java.beans.PropertyChangeListener; 5 6// A default implementation of PropertyEditor Adapter 7// that provides support for property listeners. 8// This will be used for any property editors that 9// perform their own interaction with the user to 10// change the property value. 11public class PropertyEditorChangeAdapter extends PropertyEditorAdapter { 12\tprivate PropertyChangeSupport propertyChangeSupport = 13\tnew PropertyChangeSupport(this); 14\tpublic void addPropertyChangeListener(PropertyChangeListener listener) { 15\tpropertyChangeSupport.addPropertyChangeListener(listener); 16\t} 17\tpublic void removePropertyChangeListener(PropertyChangeListener listener) { 18\tpropertyChangeSupport.removePropertyChangeListener(listener); 19\t} 20\tprotected void firePropertyChange(Object oldValue, Object newValue) { 21\tpropertyChangeSupport.firePropertyChange(null, oldValue, newValue); 22\t} 23} We define addPropertyChangeListener() and removePropertyChangeListener() to delegate their tasks to an instance of PropertyChangeSupport. We define an extra \u0026quot;helper\u0026quot; method, firePropertyChange(), to make life a bit easier for our derived property editors.\nNow we'll take our original ColorEdit1 and change its superclass to PropertyEditorChangeAdapter.Â We'll also change its name to ColorEdit3 to keep things clear.Â After a few more changes, our new property editor looks like (changes to ColorEditor1 are in bold):\n1package coloredit; 2 3import java.beans.PropertyChangeListener; 4import java.awt.Choice; 5import java.awt.Component; 6import java.awt.Color; 7import java.awt.event.ItemListener; 8import java.awt.event.ItemEvent; 9import com.magelang.adapter.PropertyEditorChangeAdapter; 10 11// This color editor will display a custom property editor and 12// allow the user to select a color name from a list. 13public class ColorEditor3 extends PropertyEditorChangeAdapter implements ItemListener { 14\tprivate static String colorNames[] = { 15\t\u0026#34;white\u0026#34;, \u0026#34;lightGray\u0026#34;, \u0026#34;gray\u0026#34;, \u0026#34;darkGray\u0026#34;, 16\t\u0026#34;black\u0026#34;, \u0026#34;red\u0026#34;, \u0026#34;pink\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;yellow\u0026#34;, 17\t\u0026#34;green\u0026#34;, \u0026#34;magenta\u0026#34;, \u0026#34;cyan\u0026#34;, \u0026#34;blue\u0026#34; 18\t}; 19 20\tprivate static Color colors[] = { 21\tColor.white, Color.lightGray, Color.gray, 22\tColor.darkGray, Color.black, Color.red, 23\tColor.pink, Color.orange, Color.yellow, 24\tColor.green, Color.magenta, Color.cyan, Color.blue 25\t}; 26 27\tprivate int selected=0; 28\tprivate Choice myGUI; 29\t30\tpublic String getAsText() { 31\treturn colorNames[selected]; 32\t} 33 34\tpublic Component getCustomEditor() { 35\tif (myGUI == null) { 36\tmyGUI = new Choice(); 37\tfor(int i = 0; i \u0026lt; colorNames.length; i++) 38\tmyGUI.addItem(colorNames[i]); 39\tmyGUI.addItemListener(this); 40\t} 41\treturn myGUI; 42\t} 43 44\tpublic String getJavaInitializationString() { 45\treturn \u0026#34;java.awt.Color.\u0026#34;+colorNames[selected]; 46\t} 47 48\tpublic Object getValue() { 49\treturn colors[selected]; 50\t} 51 52\tpublic void itemStateChanged(ItemEvent e) { 53\tsetAsText((String)e.getItem()); 54\t} 55 56\tpublic void setAsText(String text) throws IllegalArgumentException { 57\tObject oldValue = getValue(); 58\tfor(selected = 0; 59\tselected \u0026lt; colorNames.length \u0026amp;\u0026amp; 60\t!colorNames[selected].equals(text); 61\tselected++); 62\tif (selected == colorNames.length) 63\tselected = 0; 64\tObject newValue = getValue(); 65\tfirePropertyChange(oldValue, newValue); 66\t} 67 68\tpublic void setValue(Object value) { 69\tselected = 0; 70\tif (value != null) 71\tfor(int i=0; i \u0026lt; colors.length; i++) 72\tif (value.equals(colors[i])) { 73\tselected = i; 74\tbreak; 75\t} 76\t} 77 78\tpublic boolean supportsCustomEditor() { 79\treturn true; 80\t} 81} So what is it doing now?\nFirst, we define supportsCustomEditor() to return true (recall that the default implementation in PropertyEditorAdapter returns false).Â This method tells the bean builder that our property editor will have its own GUI.Â The bean builder will then call getCustomEditor() to retrieve our GUI component that does the editing.Â The bean builder will display this component in a dialog.\nOur implementation of getCustomEditor() defines our simple GUI: a Choice component that is loaded with the color names.Â To make this component useful, we need to register an ItemListener with it.Â Because some of the bean design tools do not yet support inner classes (such as VisualAge for Java), we've made the property editor an ItemListener to catch the ItemEvent.Â The action we perform when the item changes is to just set the text value in our property editor.\nThe last change we made was to fire a PropertyChangeEvent when the text value of the property changes.Â This is accomplished by adding the firePropertyChange call to setTextValue().Â firePropertyChange() checks to see if the old and new values are different, and, if so, fires off a PropertyChangeEvent to all PropertyChangeListeners (which in this case is only the bean builder.)\nIf you use this ColorEditor in a bean builder, many builder will show a small \u0026quot;...\u0026quot; button with the property in the property sheet.Â Clicking this button will bring up a dialog with our Choice component in it.\nA More Natural Interface The interface still leaves something to be desired.Â What does \u0026quot;cyan\u0026quot; look like?Â Why don't we provide some buttons with the colors as their background?Â (Note: there are some versions of the JDK that have a bug in AWT's Button class that does not paint the background color of the Button.Â The current version of VisualAge for Java contains this AWT bug.)\nThe interface between the property editor and the bean builder remains exactly the same.Â All we are doing is changing our GUI a bit.Â Differences between this editor and ColorEditor3 are in bold.\n1package coloredit; 2 3import java.beans.PropertyChangeListener; 4import java.awt.GridLayout; 5import java.awt.Panel; 6import java.awt.Button; 7import java.awt.Component; 8import java.awt.Color; 9import java.awt.event.ActionListener; 10import java.awt.event.ActionEvent; 11import com.magelang.adapter.PropertyEditorChangeAdapter; 12 13// This color editor will display a custom property editor 14// and allow the user to select a color button. 15public class ColorEditor4 extends PropertyEditorChangeAdapter implements ActionListener { 16\tprivate static String colorNames[] = { 17\t\u0026#34;white\u0026#34;, \u0026#34;lightGray\u0026#34;, \u0026#34;gray\u0026#34;, \u0026#34;darkGray\u0026#34;, 18\t\u0026#34;black\u0026#34;, \u0026#34;red\u0026#34;, \u0026#34;pink\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;yellow\u0026#34;, 19\t\u0026#34;green\u0026#34;, \u0026#34;magenta\u0026#34;, \u0026#34;cyan\u0026#34;, \u0026#34;blue\u0026#34; 20\t}; 21\tprivate static Color colors[] = { 22\tColor.white, Color.lightGray, Color.gray, 23\tColor.darkGray, Color.black, Color.red, 24\tColor.pink, Color.orange, Color.yellow, 25\tColor.green, Color.magenta, Color.cyan, Color.blue 26\t}; 27\tprivate int selected=0; 28\tprivate Panel myGUI; 29\tpublic void actionPerformed(ActionEvent e) { 30\tsetAsText(((Button)e.getSource()).getLabel()); 31\t} 32 33\tpublic String getAsText() { 34\treturn colorNames[selected]; 35\t} 36 37\tpublic Component getCustomEditor() { 38\tif (myGUI == null) { 39\tmyGUI = new Panel(new GridLayout(0,2)); 40\tfor(int i = 0; i \u0026lt; colorNames.length; i++) { 41\tButton b = new Button(colorNames[i]); 42\tb.setBackground(colors[i]); 43\tb.addActionListener(this); 44\tmyGUI.add(b); 45\t} 46\t} 47\treturn myGUI; 48\t} 49 50\tpublic String getJavaInitializationString() { 51\treturn \u0026#34;java.awt.Color.\u0026#34;+colorNames[selected]; 52\t} 53 54\tpublic Object getValue() { 55\treturn colors[selected]; 56\t} 57 58\tpublic void setAsText(String text) throws IllegalArgumentException { 59\tObject oldValue = getValue(); 60\tfor(selected = 0; 61\tselected \u0026lt; colorNames.length \u0026amp;\u0026amp; 62\t!colorNames[selected].equals(text); 63\tselected++); 64\tif (selected == colorNames.length) 65\tselected = 0; 66\tObject newValue = getValue(); 67\tfirePropertyChange(oldValue, newValue); 68\t} 69 70\tpublic void setValue(Object value) { 71\tselected = 0; 72\tif (value != null) 73\tfor(int i=0; i \u0026lt; colors.length; i++) 74\tif (value.equals(colors[i])) { 75\tselected = i; 76\tbreak; 77\t} 78\t} 79 80\tpublic boolean supportsCustomEditor() { 81\treturn true; 82\t} 83} All we have changed is the appearance of the GUI (and how we respond to events.)Â If you are careful with how you interact with the bean builder, you can change the appearance of the GUI with very little effort.Â In this case, our GUI is now a Panel with a 2-column grid of Buttons. Each Button has the color name and (unless the AWT background color bug is present) the color that will be selected.Â When pressed, the color value is set.\nThe Final Touch But what about that textual color name in the property sheet?Â Shouldn't that appear as a color as well?Â It can!\nTo make this possible, we need to drop the getAsText() method and implement the isPaintable() and paintValue() methods.Â Instead of passing a text value for the property back to the bean builder, we're telling it that we can paint a value for the property, and providing a method to do that painting.Â Our changes to the class are very simple:\nremove the getAsText() method* add two imports:Figure 9: Imports to add 1\timport java.awt.Graphics; 2\timport java.awt.Rectangle; add an isPaintable() method (recall that the default defined in PropertyEditorAdapter returned false): 1\tpublic boolean isPaintable() {return true;} add a paintValue() method:Figure 11: paintValue() method 1\tpublic void paintValue(Graphics gfx, Rectangle box) { 2\tgfx.setColor(colors[selected]); 3\t// we use three 3-d rects to over-emphasize the 3-d effect 4\t// (this way you can be sure this editor is working...) 5\tgfx.fill3DRect(box.x+2,box.y+2, box.width-5, box.height-5, true); 6\tgfx.fill3DRect(box.x+3,box.y+3, box.width-7, boxheight-7, true); 7\tgfx.fill3DRect(box.x+4,box.y+4, box.width-9, box.height-9, true); 8\t} paintValue() is passed a graphics context into which its painting will be done, and a bounding Rectangle that tells us where we are allowed to draw within that graphics context.Â Make sure you respect that bounding box, or the property sheet graphics could end up looking pretty nasty!Â Our implementation for ColorEditor5 draws a raised box in the selected color.\nPropertyEditorSupport In this article, we define the PropertyEditorAdapter and PropertyChangeAdapter to help demonstrate how property editors work. The Java class libraries include a class named java.beans.PropertyEditorSupport which provides this base functionality for you. I recommend that when you really implement property editors, you use property editor support.\nConclusion Property editors are a simple way to make your bean more user friendly.Â They can provide simple textual validations, a GUI to assist the modification of the property and graphical representations of the property within the property sheet itself.\nIf you have any questions on how to get a property editor to work, feel free to email Scott Stanchfield or one of the other Magi.\nSource Code All of the source code for this article is downloadable.Â There are two formats you can choose:\npropedit.zip - a Windows-format zip file (note that files are formatted using \\r\\n for line separators) propedit.tar.gz - a unix-format tar/gzip file (files use \\n for line separators) Duke, the Java mascot, provided by Sun Microsystems under the New BSD license.\n","link":"https://javadude.com/post/20000304-property-editors/","section":"post","tags":["java","beans","design"],"title":"Creating JavaBean Property Editors"},{"body":"Automatic Expansion of Java Import Statements\nNews 10/17/2018\nUpdating my website. This tool is obsolete, and only runs in VisualAge for Java. I'm keeping it here for historical purposes. The same functionality (cleaning up imports) is available in most modern IDEs. 6/26/2001\nFixed line separation characters. Now the proper line separator ('\\n', '\\r', or \u0026quot;\\r\\n\u0026quot;) will be appended after each import statement. (Ummm... oops, silly me ;) Added checks that the source code compiles cleanly and is versioned. Note that you must now version classes before importifying them. Moved messages into the status dialog rather than in the VisualAge console.\n7/13/2000\nImportant limitation reported! If you only reference finals in another class/interface, importifier will not add an import for that class. See the limitations section below. Don't know if I'll be able to do anything about this near-term, so you may have to add a few imports by hand when the compiler complains...\n3/12/2000\nInitial release of Importifier Status: Works pretty well, but I'd recommend you version your source before using it, just in case...\nNote: This version of the tool only works inside VisualAge for Java. I've written the code such that I should be able to easily create a command-line version for non VAJ users in a later release. Introduction Java provides two forms of import statements:\nExplicit import - You write an import statement like\nimport java.awt.Button;\nwhich tells the compiler \u0026quot;when you see 'Button', I mean 'java.awt.Button'.\nImport on demand - You write an import statement like\nimport java.awt.*;\nwhich tells the compiler \u0026quot;when you see a name you don't recognize, check to see if it exists in package 'java.awt'\u0026quot;\nImport on demand is pure, unadulterated EVIL.\nThere are several problems with import-on-demand:\nIf you use a name that exists in more than one package, the Java compiler cannot determine which fully-qualified name to use. You need to specify the full qualification yourself. If a name is currently unambiguous (exists in only one package that you specify via import-on-demand), someone could add the same name to another package and your program will no longer compile. Note that this happened with the Java2 platform. Originally, the List class existed in package java.awt. In Java2, Sun added a new List class to the java.util package. If your program imports java.awt.* and java.util.*, and uses List, it will compile in JDK 1.1 but not in the Java 2 platform! If someone is reading your code, they need to check in each specified package to see which contains a referenced class Foo. The importifier replaces all import statements with exactly the import statements your program requires.\nHow the tool works First, it is important that the code you want to importify be error-free. The tool needs to examine the bytecode to determine the correct imports, as well as resolve ambiguities.\nSecond, you must version your classes and interfaces before running importifier against them. This is a safeguard, just in case importifier decides to have a bad fur day.\nImportifier starts by exporting the code you wish to importify. The tool exports .class files to a temporary directory, so it can parse the bytecode.\nNext, importifier parses the bytecode to see which classes are used. This is significantly easier than parsing the source code to find out the same information.\nAfter the tool knows which classes are used, it walks through the source code of the class definition to remove the old import statements and add the new, fully-qualified ones. In many cases this is straightforward, but in cases where the short name of the classes are ambiguous (as in List being in both java.awt and java.util in the Java2 platform), importifier examines your old imports to see which full name it should keep.\nIf the tool sees any inner classes listed in the .class file, it recursively parses the inner classes to determine all imports needed in the containing class.\nDistribution Importifier is packaged as a tool for VisualAge for Java 3.02 and above. Importifier will not work on earlier versions of VisualAge for Java. Note that the latest release has not been tested on versions earlier than 3.5.3 but should work on 3.02.\nInstallation for VisualAge for Java - Tool Packaging To use Importifier in VisualAge for Java:\nDownload importifier.zip from this site. Unzip importifier.zip to the directory where VisualAge for Java is installed.Â For example, if you installed VisualAge for Java in the c:\\IBMVJava directory were on your C:\\ drive, unzip the importifier.zip to C:\\IBMVJava directory. Note that VisualAge for Java version 3.5 and above are typically installed under C:\\Program Files\\IBM\\VisualAge for Java. Shutdown VisualAge for Java if it is running Start VisualAge for Java. This will add the importifier tool to the Tools menu for classes, packages, and projects.\nNote: If you are using VisualAge for Java 3.02 on Linux, you will need to download the tool api for linux. You can get this from VisualAge Developer Domain (http://www.software.ibm.com/vadd). The latest version of importifier has not been tested under Linux. Please let me know if you encounter any problems!\nUse VisualAge for Java To use Importifier (once it is installed)\nVersion the classes, packages, or projects that you want to importify. Note that the tool will check if the code is already versioned and abort if it isn't. Select Tools-\u0026gt;Expand import statements from the popup menu of selected classes, packages, or projects The status dialog for the Importifier reports its progress. Command-Line The importifier tool does not yet support command-line use. I will eventually release a version that includes command-line capability.\nLimitations This tool will not add imports for classes/interfaces from which you only use final variables.\nImportifier reads the generated bytcode for the class being importified to figure out what imports are needed. If all you reference are constants (finals) in another class/interface, it won't see that class/interface because the java compiler resolves them, leaving no reference to that class/interface in the bytecode. Bummer...\nIMHO, this is a design flaw in Java, but that's another issue... I'll have to see if there's some way I can fix it later, but don't know that I'll have time anytime soon. For now, you may have to add a few imports by hand after running importifier. It will still give you a great start toward freedom from import-on-demand, though.\nThis tool does not work on classes that exist in a default package! You should only use the tool on classes in a named package!\nThe tool does not change full-qualifications in the code to short names. I will add this capability in a later version of the tool.\nYou may need to clean up the code a bit after the tool is done, as it adds a bit of extra space. In many cases the space will be correct, but in some cases you may find there is an extra blank line between the imports and the class definition. Note also that the resulting file might look a bit strange if you had comments on the same lines or near the old import statements.\nThe tool will only work if the code to importify is error free!\nThe tool currently creates import statements for classes in the same package as well as classes in package java.lang. A later version of the tool may provide options to omit these imports if desired.\nLicense Importifier is free for any use other than selling it as a stand-alone product.\nNote that Importifier is provided \u0026quot;as-is\u0026quot; without any warrantee or guarantee of suitability for any purpose. Scott Stanchfield cannot be held responsible for any damage caused by its use.\n(In other words, use 'em for free at your own risk.)\n","link":"https://javadude.com/post/20000304-importifier/","section":"post","tags":["java"],"title":"Importifier"},{"body":"Some talks I gave at JavaOne in 2000, 2001, and 2002.\n#JavaOne 2002\nFirst, thanks to everyone who showed up at my talk, Creating Custom JSP Tags. At least that was the title until the legal folks got hold of it...\nI've posted a non-JavaOne copy of the slides as well as code samples that can be used in Tomcat.\nCreating Custom JSP Tags.zip - powerpoint slides customtag.zip - a zipped web application containing source of the sample code demonstrated during the lecture Using the Sample Code Trying the samples on your machine The sample code has been tested under Tomcat 4.0.3. (You can obtain tomcat from http://tomcat.apache.org).\nTo install the sample code:\nDownload it using the above link.\nUnzip it into the webapps directory of your tomcat installation. This should create a customtag directory under webapps.\nModify the conf/server.xml file in your tomcat installation to create a context for custom tag. You can add a line like\n\u0026lt;Context path=\u0026quot;/customtag\u0026quot; docBase=\u0026quot;customtag\u0026quot; debug=\u0026quot;0\u0026quot; reloadable=\u0026quot;true\u0026quot;/\u0026gt;\rin your server.xml file. Search for the other Contexts that are defined, such as the manager context, and place this new context there.\nRestart your tomcat server.\nOnce you have the sample code installed, you can surf to any of the following URLs to view the samples. Note that these URLs assume a standard development installation of tomcat, listening at port 8080 on your local machine. If tomcat is installed elsewhere, you'll need to modify the URLs accordingly.\nURLs for custom tag samples on your machine\nhttp://localhost:8080/customtag/header1.jsp\nA simple JSP that uses a custom header tag for a hardcoded replacement.\nhttp://localhost:8080/customtag/header2.jsp\nSimilar to header1, but this tag takes an attribute to allow simple customization of the replacement.\nhttp://localhost:8080/customtag/ifsample.jsp\nA JSP that conditionally includes some text based on parameters passed to it. Try\nhttp://localhost:8080/customtag/ifsample.jsp?showName=true http://localhost:8080/customtag/ifsample.jsp?showName=false as variations to see how this page behaves.\nhttp://localhost:8080/customtag/listpeople.jsp\nA JSP that uses a custom iterator tag to walk through data retrieved from a data source. Note that the data manager used for this example hardcodes the data for simpler setup. If you want to change it to use a database, you only need to change the data manager class.\nhttp://localhost:8080/customtag/layout.jsp\nA JSP that uses nested custom tags to provide AWT-like BorderLayout support. License The presentation is Copyright (c) 2002, Scott Stanchfield, All Rights Reserved. It may not be used for commercial purposes without obtaining permission.\nThis sample code is free for any use other than selling it as a stand-alone product.\nNote that the sample code is provided \u0026quot;as-is\u0026quot; without any warrantee or guarantee of suitability for any purpose. Scott Stanchfield cannot be held responsible for any damage caused by its use.\n(In other words, use 'em for free at your own risk.)\n#JavaOne 2001\nFirst, thanks to all who attended my talk, Effective Layout Management. I'm posting a non-JavaOne copy of the slides here. Be sure to read the original article, Effective Layout Management. A link can be found on my articles page.\nNote: I originally planned to update the Effective Layout Management article, but I have been approached by a publisher to write a book on the subject. I have not decided yet if I will actually write the book or not.\nEffective Layout Management.zip - PowerPoint Slides of Effective Layout Management presentation The presentation is Copyright (c) 2001, Scott Stanchfield, All Rights Reserved. It may not be used for commercial purposes without obtaining permission.\nJavaOne 2000 First, thanks to everyone who showed up at the BOFs (\u0026quot;Birds of a Feather\u0026quot; sessions) that I hosted! I had a great time jabbering on about VisualAge for Java, Model-View-Controller, Actions, and layout managers. I'm glad we got a chance to let the IBMers answer some of your buring questions, and many of those answers were just what we're looking for!\nIf you have any questions on anything I talked about, please don't hesitate to email me at scott@javadude.com!\nModel-View-Controller BOF (\u0026quot;MVC for You and Me\u0026quot;) As promised, you can download the slides for this talk here, as well as find some other interesting resources on MVC. Enjoy!\nMVC for You and Me.zip -- PowerPoint slides for my MVC talk. If you don't have PowerPoint, you can download a free viewer from Microsoft.com.Â Applying the Model-View-Controller Paradigm in VisualAge for Java (No longer online) Introduction to the Model-View-Controller Paradigm and details on applying it visually in VisualAge for Java. _Note: This article has many specifics to VisualAge for Java, but the general concepts and the walkthrough demonstration can be useful to help you see how to apply MVC in other environments as well.\n_Â Advanced Model-View-Controller Techniques (No longer online)\nA more general, conceptual article on some more advanced MVC topics. Much mess emphasis on VisualAge for Java, and includes examples of sorting, merging, and filtering Swing tables.\nActions: Experience and Speculation In case you're interested in the Swing Action slides, you can access there here:\nactions.zip Fun with Layout Managers I've put the MaxMinLayout manager file here for you to look at. Note that it has some rough edges, and is only meant to represent a simple example of a custom layout manager. It's actually an example from my book, Effective VisualAge for Java, where I discuss how to integrate custom layout managers with VisualAge for Java.\nMaxMinLayout.zip Look and Feel Guidelines: What do they mean to you? My apologies to anyone who wanted to come to this BOF. I had a few issues come up during the first day at JavaOne and had to cancel it. Please be aware that Sun is working on version 2 of the Look and Feel Guidelines, and they're really interested in any feedback you may have on the initial guidelines.\n","link":"https://javadude.com/post/20000304-javaone/","section":"post","tags":["java","language","design"],"title":"JavaOne 2000/2001/2002"},{"body":"Simple Swing Border Editing in GUI Builders\nNOTE: This is a plugin for VisualAge for Java and is now obsolete. I'm keeping it here for historical purposes only\nDescription NOTE: Make sure you read the WARNING sections under usage -- this tool is a tad rough around the edges, but if you enter the right stuff it'll treat you well ;)\nSwing Border support is fairly generic in VisualAge for Java 3.5.Â I've written a property editor that can be used in VAJ to make border edits easy.\nNOTE: The Swing Border Editor is only supported for version 3.5 of VisualAge for Java. It is no longer supported for version 2.0 or 3.0.\nInstallation To install the border editor in VisualAge for Java 3.5.\nWhen mentioned, installdir refers to the directory in which you installed VisualAge for Java, version 3.5. By default, this should be c:\\Program Files\\IBM\\VisualAge for Java\nShutdown VisualAge for Java. Download bordereditor.zip from this site.Â This zip includes the source and executables for the border editor. Extract bordereditor.zip into the installdir\\ide\\features directory. Startup VisualAge for Java.Â You should see a few messages about the features being installed. Select \u0026quot;Quick Start\u0026quot; from the \u0026quot;File\u0026quot; menu of the Workbench. Select \u0026quot;Features\u0026quot; from the left pane of the Quick Start window, then \u0026quot;Add Feature\u0026quot; from the right pane. Select \u0026quot;Javadude Swing Border Editor\u0026quot; and press OK. Create and save file installdir\\ide\\program\\lib\\ivj-property-editor-registry.properties containing the following line: javax.swing.border.Border=com.javadude.bordereditor.BorderEditor\nUse WARNING 1: If you use this border editor, you will lose any previous border settings!\nWARNING 2: I haven't added any real exception handling in yet -- BE CAREFUL WHEN ENTERING NUMBERS IN TEXTFIELDS!Â I'll fix this when I have time.Â I just wanted to get this out to try.\nWARNING 3: If you use \u0026quot;Custom\u0026quot; borders, you're completely on your own for the code you write.Â Be careful.Â And make sure you either add import statements for any class refs, or fully-qualify them.\nHopefully the interface is fairly obvious.\nYou select from the type of border you want:\nbevel - a raised/lowered, and possibly \u0026quot;soft\u0026quot; bevel border\netched - an etched/raised line\nline - a varying width and color line around the edge.Â NOTE: Make sure you enter valid numbers or you'll see exceptions thrown in the console...Â I'll fix this in the next release.\nempty - empty space around the edges. NOTE: Make sure you enter valid numbers or you'll see exceptions thrown in the console...Â I'll fix this in the next release.\ncustom - you type the code -- NOTE: the tool does not verify this code!\nnone - the layout will be set to \u0026quot;null\u0026quot;.Â Note that this is not the same as the \u0026quot;default\u0026quot; layout for the border.Â There is currently no way in VAJ to \u0026quot;unset\u0026quot; a property once it has been set.\nFill in the details for the border type you want, then choose if you want that border titled or not.Â If you want it titled, select the parameters for the titling.\nAs you make changes, they will be reflected in the border editor's border so you can see what the result will look like.\nWhen you press \u0026quot;Ok\u0026quot; you should see the new border appear in the VCE around the component being edited.\nUninstalling from VisualAge for Java, version 3.5 To uninstall from version 3.5:\nDelete the javax.swing.border.Border=com.javadude.bordereditor.BorderEditor\nline from installdir\\ide\\program\\lib\\ivj-property-editor-registry.properties\nDelete the added features (File-\u0026gt;Quick Start-\u0026gt;Features-\u0026gt;Delete Feature) License The Swing Border Editor for VisualAge for Java is free for any use other than selling it as a stand-alone product.\nNote that this code is provided \u0026quot;as-is\u0026quot; without any warrantee or guarantee of suitability for any purpose. Scott Stanchfield cannot be held responsible for any damage caused by use this code.\n(In other words, use 'em for free at your own risk.)\nBug Reports/Feature Requests Please let me know about any bugs you find or requests for what you'd like to see this tool do.Â Feel free to send example code to implement it as well.\nFuture Directions I need to document and comment the code like crazy I want to add nested borders (should be fairly easy, but I gotta think about exactly how they interact first) Good exception handling is necessary -- I'll add it in the next release. ","link":"https://javadude.com/post/20000304-border-editor/","section":"post","tags":["java"],"title":"Swing Border Editor"},{"body":"The basics of the JavaBean Component Model\n(Note - this article is quite old... I only had time to reformat it, so please forgive use of \u0026quot;Vector\u0026quot;, though I'm not sure why I used it... I have anonymous inner classes in here, so java.util.List existed... I assume it was just code evolution at some point...)\nJavaBean components, or simply beans, are classes that are proud of what they are, and they let the world know it. Using certain naming conventions and possibly a helper class, a bean identifies its attributes and behavior to any interested party. Bean-builder tools or other applications use that knowledge to customize beans and glue them together through event registration.\nYou have most likely seen this type of behavior in the form of bean-builder tools. You drag and drop GUI components in a design area, change their attributes, and specify interactions between them. However, you might wonder how these tools can know so much about the components. In fact, these tools are much simpler than they appear, thanks to the JavaBean component model.\nThe power of beans is not limited to designing user interfaces. A bean can be a nonvisual component, such as a data structure or a proxy for a remote database. Bean-builder tools manipulate beans, helping to build applications without requiring you to write code. Moreover, beans are not only useful in application design tools; they can prove useful in run-time environments as well.\nWhat Makes a Class a Bean? All beans must meet two requirements:\nThey must be public classes (so any class can inquire about it). They must support persistence of their state. The bean specification enables this persistence through the java.io.Serializable or java.io.Externalizable interfaces. This requirement enables an application such as a bean-builder tool to restore a \u0026quot;pickled\u0026quot; instance of a bean, an instance created before running the application.\nIf you plan to always restore the bean from its serialized state, no other requirements must be met. However, it is generally desirable to create new instances of a bean by using a new expression. To enable this, the bean must provide a public no-argument (otherwise known as default) constructor.\nTip: Many bean-builder tools, including VisualAge for Java, interpret the bean specification as requiring public no-argument constructors. Others require persistence. Because of this, always make your beans persistent and define a public, no-argument constructor. If you do not make your bean serializable, it may not be usable in other bean-builder tools.\nOf course, simply making a class persistent and possibly providing a public no-argument constructor does not make the bean terribly interesting. For a bean to be useful, it should provide information about its attributes and behavior.\nBean Features The bean specification defines three types of bean features. Features are aspects of a bean that might prove interesting to another application or class, describing the state and behavior of the bean. The three types of bean features are:\nProperties. Exposed pieces of the beanâ€™s state Event Sets. A stimulus from the bean, signaling that something, like a changes of state has occurred. The bean broadcasts this information to its listeners Methods. Public methods, callable from other beans or applications All bean features must be public! This allows any other bean to inspect or modify properties, register itself as an event listener, or call provided methods. This does not mean that the actual data inside the class needs to be public, nor do all methods in the class need to be public. Only the parts of a bean that describe its features must be public.\nThrough use of simple naming conventions, a bean enables applications to determine which features it supports. Tools discover bean features solely through the names of the public methods defined in a bean class. A beans-enabled tool can use the Java language reflection API to determine which public methods a class defines; the tool can also determine available bean features based on the names of those methods. Some beans also provide an explicit class called a BeanInfo class that describes features in more detail, but this is not necessary. This additional information can enhance design-time use of the bean, but has no affect on the runtime behavior of the bean.\nProperties Properties describe part of the state of its bean, usually information that can distinguish different instances of a bean. There are two types of properties: simple and indexed.\nNote: A property can be either simple or indexed; it cannot be both.\nSimple Properties Simple properties act like individual bits of data, describing the state of a bean. You define simple properties using sets of methods that match the following patterns:\n1public TypeName getPropertyName() 2public boolean isPropertyName() 3public void setPropertyName(TypeName value) Note: You can only define the isPropertyName() method for boolean properties.\nTypeName is the name of a class or primitive type, and PropertyName is the name of the property. The presence of a get or is method defines a readable property. A set method defines a writeable property. The property name is actually a lower-cased version of whatever follows the get or set in the method declaration. For example, suppose a bean defines the following method:\n1public Color getEyeColor() This defines a readable property named eyeColor of type java.awt.Color.\nNote that there can be both a get and is method for a boolean property; the is method is allowed for readability. Normally, you define the get and set methods, but sometimes the get method doesn't read naturally. For example\n1if (list.isEmpty()) {...} 2 3// is more readable than 4 5if (list.getEmpty()) {...} The beauty of this model is its simplicity. Many programmers already use get and set methods to access their data, so defining properties is no different from their current style.\nA tool that recognizes these get and set methods can present a list of properties to a user, enabling the user to specify property values. The tool generates code to pass the specified values to the set methods.\nBecause the tool is only querying the names of the methods, there does not need to be any actual data corresponding to the property. A property could simply be a computation or an alternate means to validate and set other data inside the class. An isEmpty() method might simply count items in a referenced list, or a getMaximumValue() method might return an integer such as five.\nIndexed Properties Indexed properties are an extension of simple properties that allow multiple values for that property. The property acts like an array, even if there is no actual data for that property or if the data is stored in a non-array structure.\nYou define indexed properties using four methods:\n1public TypeName[] getPropertyName() 2public TypeName getPropertyName(int index) 3public void setPropertyName(TypeName[] value) 4public void setPropertyName(int index, TypeName value) Recognizing these methods, a bean-builder tool can present a (possibly editable) list of values for setting the property.\nBound and Constrained Properties While these names may conjure images of Harry Houdini, bound and constrained properties have nothing to do with ropes, shackles, or chains. (If you're thinking something other than Harry Houdini, remember that this is a family show...)\nBound and constrained properties fire events that report any modification to their state. Bound properties notify registered listeners after their state has changed, while constrained properties notify listeners before they change, allowing those listeners to veto the change. You can bind and constrain simple or indexed properties.\nBound or constrained properties greatly enhance the flexibility of a bean. Bound properties enable you easily to keep property values in different beans synchronized. VisualAge for Java provides techniques to take advantage of bound properties. Constrained properties allow you to plug in validation, in the form of listener objects, rather than hardcoding that validation into the property code itself.\nBound Properties: Reporting Property-State Changes (NOTE: This is an implementation of the Observer Pattern...)\nA bound property fires a PropertyChangeEvent (defined in package java.beans) when its state changes. PropertyChangeListeners register themselves with the bean to receive notification of those changes. The java.beans package provides support for this processing through its PropertyChangeSupport class. For example, consider a simple property phoneNumber, defined as follows:\n1private String phoneNumber; 2 3public void setPhoneNumber(String phoneNumber) { 4 this.phoneNumber = phoneNumber; 5} 6 7public String getPhoneNumber() { 8 return phoneNumber; 9} Note: Sometimes the statement\n1this.phoneNumber = phoneNumber; can be quite confusing to read, especially when first learning the Java language. We use it here because it is and accepted common practice. The this qualification on the first phoneNumber means, \u0026quot;I'm talking about the instance variable phoneNumber.\u0026quot; This is necessary to distinguish it from the current active use of phoneNumber, the parameter phoneNumber.\nThis simple property definition directly sets and gets its data. To bind this property, we need to provide the following:\nMethods to register(add) and remove PropertyChangeListeners Code to fire a PropertyChangeEvent to the registered listeners Because the code to perform these functions is identical for every bound property, we can delegate these functions to an instance of PropertyChangeSupport. A resulting Person bean containing the phoneNumber property could look as follows:\n1package effectivevaj.bean.intro.boundproperty; 2 3import java.beans.PropertyChangeEvent; 4import java.beans.PropertyChangeListener; 5import java.beans.PropertyChangeSupport; 6import java.io.Serializable; 7 8/** 9 * A sample Person bean that defines a bound property 10 */ 11 12public class Person implements Serializable { 13 // Create a PropertyChangeSupport instance 14 // to which we\u0026#39;ll delegate our bound-property 15 // functionality 16 17 private transient PropertyChangeSupport pcs = 18 new PropertyChangeSupport(this); 19 20 /** Let classes listen for property changes */ 21 public void addPropertyChangeListener(PropertyChangeListener l) { 22 pcs.addPropertyChangeListener(l); 23 } 24 25 /** Let classes stop listening to property changes */ 26 public void removePropertyChangeListener(PropertyChangeListener l) { 27 pcs.removePropertyChangeListener(l); 28 } 29 30 // Define a read/write/bound property named phoneNumber 31 private String phoneNumber; 32 33 /** Define property phoneNumber as readable String */ 34 public String getPhoneNumber() { 35 return phoneNumber; 36 } 37 38 /** Define property phoneNumber as writeable String 39 * phoneNumber is bound, firing PropertyChangeEvents 40 * whenever its value changes 41 */ 42 public void setPhoneNumber(String phoneNumber) { 43 // save the old value 44 String oldNumber = this.phoneNumber; 45 46 // set the new value 47 this.phoneNumber = phoneNumber; 48 49 // report the change 50 pcs.firePropertyChange(\u0026#34;phoneNumber\u0026#34;, oldNumber, phoneNumber); 51 } 52} The highlighted text in the previous example is the extra code needed to bind the phoneNumber property. Note that many tools, such as VisualAge for Java, can generate all of this code for you.\nAfter binding phoneNumber, we can keep the telephone numbers of two people synchronized by creating listeners. For example, suppose we have a married couple, Scott and Nancy, who share a telephone number. When one spouse changes the telephone number, the telephone number should change for the other person as well.\nThe following code acts as glue between two Person beans, scott and nancy. We create event listeners (using anonymous inner classes) to listen for changes to the phoneNumber property of each bean. Whenever we hear that the phoneNumber of scott changes, we set the phoneNumber of nancy. We provide the same type of handling for changes to the phoneNumber in nancy as well.\n1package effectivevaj.bean.intro.boundproperty; 2 3import java.beans.PropertyChangeEvent; 4import java.beans.PropertyChangeListener; 5 6/** 7 * Test the Person bean\u0026#39;s bound phone number property 8 */ 9 10public class PhoneSync { 11 12 /** 13 * Test the bound phoneNumber of the Person bean 14 * Create two people that share a phone number and 15 * create property-change listeners that will keep 16 * their phone numbers synchronized 17 */ 18 public static void main(String[] args) { 19 // create two people who share a phone number 20 21 final Person scott = new Person(); 22 final Person nancy = new Person(); 23 24 // when scott\u0026#39;s phone changes, change nancy\u0026#39;s 25 scott.addPropertyChangeListener( 26 new PropertyChangeListener() { 27 public void propertyChange(PropertyChangeEvent e) { 28 if (e.getPropertyName().equals(\u0026#34;phoneNumber\u0026#34;)) { 29 nancy.setPhoneNumber(scott.getPhoneNumber()); 30 } 31 } 32 } 33 ); 34 35 // when nancy\u0026#39;s phone changes, change scott\u0026#39;s 36 nancy.addPropertyChangeListener( 37 new PropertyChangeListener() { 38 public void propertyChange(PropertyChangeEvent e) { 39 if (e.getPropertyName().equals(\u0026#34;phoneNumber\u0026#34;)) { 40 scott.setPhoneNumber(nancy.getPhoneNumber()); 41 } 42 } 43 } 44 ); 45 46 // Run a little test... 47 48 System.out.println(\u0026#34;Initial phone numbers\u0026#34;); 49 System.out.println(\u0026#34;Scott: \u0026#34; + scott.getPhoneNumber()); 50 System.out.println(\u0026#34;Nancy: \u0026#34; + scott.getPhoneNumber()); 51 System.out.println(); 52 System.out.println(\u0026#34;Set Scott\u0026#39;s number to 555-1212\u0026#34;); 53 scott.setPhoneNumber(\u0026#34;555-1212\u0026#34;); 54 System.out.println(\u0026#34;Scott: \u0026#34; + scott.getPhoneNumber()); 55 System.out.println(\u0026#34;Nancy: \u0026#34; + scott.getPhoneNumber()); 56 System.out.println(); 57 System.out.println(\u0026#34;Set Nancy\u0026#39;s number to 555-7777\u0026#34;); 58 nancy.setPhoneNumber(\u0026#34;555-7777\u0026#34;); 59 System.out.println(\u0026#34;Scott: \u0026#34; + scott.getPhoneNumber()); 60 System.out.println(\u0026#34;Nancy: \u0026#34; + scott.getPhoneNumber()); 61 } 62} Creating PropertyChangeListeners for each Person bean automatically updates both Person beans when either telephone number changes. We will use this technique during visual composition to achieve several interesting effects, including keeping a model synchronized with a GUI. The results of running PhoneSync follow:\nInitial phone numbers\rScott: null\rNancy: null\rSet Scott's number to 555-1212\rScott: 555-1212\rNancy: 555-1212\rSet Nancy's number to 555-7777\rScott: 555-7777\rNancy: 555-7777\rNote: Some tools, such as VisualAge for Java, can generate code to perform exactly this task.\nConstrained Properties: Property Validation by Delegation Note that this is not an ideal way to do validation (you lose the invalid value...), and in practice, is rarely, if ever, used.)\nConstrained properties allow registered listeners to veto a proposed change. The bean fires a PropertyChangeEvent before the property state is changed, and the listeners can object to the change by throwing a PropertyVetoException. The exception prevents the state from changing and informs the code that called the set method of the veto.\nConstrained properties perform property validation through external objects. Rather than hardcoding validation inside the set method, we delegate the validation to registered listeners. Consider the benefits of this approach. If we design a text-field GUI component that has a constrained text property, we can plug in any validation we want.\nIn one use, we could plug in the following validation criteria:\nAll characters must be numbers. There must be exactly seven characters. In a different instance, we might plug in different validations:\nThe first character must be alphabetic. The text must be a single word. The text must contain at least one number. The text must be greater than six characters. Each validation process is contained in a separate VetoableChangeListener and registered with the text field. If any of the separate validations is not successful, the setText() method will fail. This is preferable to making a new subclass of the text field simply to add different validation in its setText() method. Think of all the subclasses that you would need to provide validation. Suppose we wanted to check that the value entered in a text field or a combo box were a date. We would need to subclass each of these classes to perform the validation. If we made their text or value properties constrained, we would only need to define the data-check logic in one validator class.\nThe java.beans package provides another concrete-implementation class, VetoableChangeSupport, to assist with constrained-property event processing. Constraining a property is very similar to making it bound.\nThe following code defines a constrained property called phoneNumber. Similar to our earlier bound property example, we delegate the listener tracking and event firing to another object, one of class VetoableChangeSupport.\n1package effectivevaj.bean.intro.constrainedproperty; 2 3import java.io.Serializable; 4import java.beans.PropertyChangeEvent; 5import java.beans.VetoableChangeListener; 6import java.beans.VetoableChangeSupport; 7import java.beans.PropertyVetoException; 8 9// A sample Person bean that defines a constrained property 10 11public class Person implements Serializable { 12 13 // Create a VetoableChangeSupport instance 14 // to which we\u0026#39;ll delegate our constrained-property 15 // functionality. (Note - using lazy-instantiation this time, just \u0026#39;cause I can...) 16 private transient VetoableChangeSupport vcs; 17 18 // Let classes listen for property changes 19 public void addVetoableChangeListener(VetoableChangeListener l) { 20 if (vcs == null) 21 vcs = new VetoableChangeSupport(this); 22 vcs.addVetoableChangeListener(l); 23 } 24 25 // Let classes stop listening to property changes 26 public void removeVetoableChangeListener(VetoableChangeListener l) { 27 if (vcs == null) 28 vcs = new VetoableChangeSupport(this); 29 vcs.removeVetoableChangeListener(l); 30 } 31 32 // Define a read/write/constrained property named 33 // phoneNumber 34 private String phoneNumber; 35 36 // Define property phoneNumber as readable String 37 public String getPhoneNumber() { 38 return phoneNumber; 39 } 40 41 // Define property phoneNumber as writeable String 42 // phoneNumber is constrained, firing 43 // PropertyChangeEvents whenever its value is 44 // about to change 45 public void setPhoneNumber(String phoneNumber) throws PropertyVetoException { 46 if (vcs != null) { 47 // report the impending change 48 vcs.fireVetoableChange(\u0026#34;phoneNumber\u0026#34;, 49 this.phoneNumber, phoneNumber); 50 } 51 // change to the new value 52 this.phoneNumber = phoneNumber; 53 } 54} The highlighted text is the set of changes necessary to support a constrained property. Again, many tools, such as VisualAge for Java, can generate all of this code for you.\nRegistered VetoableChangeListeners can throw a PropertyVetoException, which halts the setPhoneNumber processing, throwing the exception to the caller of setPhoneNumber().\nAs a simple example, we restrict a Personâ€™s telephone number to exactly seven numeric characters. Our strategy to implement this is as follows:\nConstrain the phoneNumber property. (We have defined that previously.)* Create the class StringLengthCheck to ensure that a String is within a minimum-maximum range, as follows: 1package effectivevaj.bean.intro.constrainedproperty; 2 3import java.beans.PropertyVetoException; 4import java.beans.PropertyChangeEvent; 5import java.beans.VetoableChangeListener; 6 7// A VetoableChangeListener that validates that a String\u0026#39;s 8// length falls within a given range 9public class StringLengthCheck implements VetoableChangeListener { 10\tprivate int minimum, maximum; 11 12\t// constructor -- gather the min-max range for 13\t// the legal string length 14\tpublic StringLengthCheck(int min, int max) { 15\tminimum = min; 16\tmaximum = max; 17\t} 18 19\t// VetoableChangeListener notification - check to see 20\t// if the length of the new string value is within 21\t// the minimum/maximum range 22\tpublic void vetoableChange(PropertyChangeEvent e) throws PropertyVetoException { 23\tif (e.getPropertyName().equals(\u0026#34;phoneNumber\u0026#34;)) { 24\tString number = (String) e.getNewValue(); 25\tif (number == null) 26\tthrow new PropertyVetoException(\u0026#34;No new value!\u0026#34;, e); 27\tint len = number.length(); 28\tif (len \u0026lt; minimum || len \u0026gt; maximum) 29\tthrow new PropertyVetoException(\u0026#34;Improper length: must be in range \u0026#34; + 30\tminimum + \u0026#34;-\u0026#34; + maximum, e); 31\t} 32\t} 33} Create class NumberStringCheck to ensure that all characters are numeric, as follows: 1package effectivevaj.bean.intro.constrainedproperty; 2 3import java.beans.VetoableChangeListener; 4import java.beans.PropertyChangeEvent; 5import java.beans.PropertyVetoException; 6 7// A VetoableChangeListener that validates that a 8// String\u0026#39;s value is completely numeric 9public class NumberStringCheck implements VetoableChangeListener { 10\tpublic void vetoableChange(PropertyChangeEvent e) throws PropertyVetoException { 11\tif (e.getPropertyName().equals(\u0026#34;phoneNumber\u0026#34;)) { 12\tString number = (String) e.getNewValue(); 13\tif (number != null) { 14\tint len = number.length(); 15\tfor (int i = 0; i \u0026lt; len; i++) { 16\tif (!Character.isDigit(number.charAt(i))) { 17\tthrow new PropertyVetoException(number + 18\t\u0026#34; contains non-numeric characters\u0026#34;, e); 19\t} 20\t} 21\t} 22\t} 23\t} 24} Add instances of StringLengthCheck and NumberStringCheck to the Person bean as VetoableChangeListeners, as follows: 1package effectivevaj.bean.intro.constrainedproperty; 2 3import java.beans.PropertyVetoException; 4 5// Test our constrained phoneNumber property 6public class PhoneValidate { 7\t// A convenience method to handle the exceptions for us 8\tprotected static void setPersonsPhoneNumber(Person person, String number){ 9\ttry { 10\tperson.setPhoneNumber(number); 11\tSystem.out.println(\u0026#34;Set number to \u0026#34; + number); 12\t} catch (PropertyVetoException e) { 13\tSystem.out.println(e); 14\t} 15\t} 16 17\t// Runs a simple test of our constrained phone property 18\tpublic static void main(String[] args) { 19\tPerson scott = new Person(); 20\tscott.addVetoableChangeListener( 21\tnew StringLengthCheck(7, 7)); 22\tscott.addVetoableChangeListener(new NumberStringCheck()); 23\t// test a non-numeric phone number 24\tsetPersonsPhoneNumber(scott,\u0026#34;111aaaa\u0026#34;); 25\t// test a long phone number 26\tsetPersonsPhoneNumber(scott,\u0026#34;5551111111111\u0026#34;); 27\t// test a normal phone number 28\tsetPersonsPhoneNumber(scott,\u0026#34;5551212\u0026#34;); 29\t// create a new person that only checks that the 30\t// phoneNumber is numeric 31\tPerson nancy = new Person(); 32\tnancy.addVetoableChangeListener(new NumberStringCheck()); 33\t// test a non-numeric phone number 34\tsetPersonsPhoneNumber(nancy,\u0026#34;111aaaa\u0026#34;); 35\t// test a long phone number 36\tsetPersonsPhoneNumber(nancy,\u0026#34;5551111111111\u0026#34;); 37\t} 38} As you can see from the previous test, not only can we plug in several validations, but we can also use different sets of validations for each instance of a class. The previous example will print the following to System.out:\nConstrained test output\n1java.beans.PropertyVetoException: 111aaaa contains non-numeric characters 2java.beans.PropertyVetoException: Improper length: must be in range 7-7 3Set number to 5551212 4java.beans.PropertyVetoException: 111aaaa contains non-numeric characters 5Set number to 5551111111111 Tool support for constrained properties is pretty much non-existent. Eventually, tools should support attaching validation vetoers to your beans, but we may not see this behavior for some time.\nHow Can a Tool Tell if a Property is Bound or Constrained? Tools like VisualAge for Java have two ways to determine if properties are bound and/or constrained. They can make educated assumptions, or they can find out for certain through a BeanInfo class.\nIf a tool sees that a bean defines method\n1public void addPropertyChangeListener(PropertyChangeListener l) it assumes that contained properties may be bound. While that is a bit over-assuming, it really does not hurt use of the bean. If the bean has any properties that are not bound, it is the bean-developer's responsibility to provide a BeanInfo class that explicitly states which properties are not bound.\nConstrained properties are similar, but assumptions are safer. Whenever the tool sees that a property's set method throws a PropertyVetoException, the tool can assume the property is constrained.\nRemember that properties can be both bound and constrained. In practice, most properties are only bound, and very few are only constrained.\nEvent Sets Beans may or may not fire events. If they support bound or constrained properties, they will fire events (as we have seen); they can also fire other types of events. Event firing requires the following elements:\nAn event class to transmit information about the event An interface that describes how the bean will notify interested parties, known as listeners A data structure to track listeners Registration methods to add and remove listeners Code to fire the events For example, suppose we were creating a WeatherStation bean that notifies any interested parties when the sun rises or sets. We use this example throughout the following sections.\nAn Event Class The first requirement for event firing is a class to represent information about the event. Our SunEvent object contains the time of the event and a boolean property that tells us if the event represents the sun rising or setting.\nEvent classes should be immutable! Immutable objects are ones that cannot be changed. Event firing passes a reference to a single event to each listener in an unspecified order. It is important that these listeners cannot modify the event, or it could change the way processing continues for other listeners. Note that the following class is not a bean, because its superclass does not implement java.io.Serializable. If you like, you can define the event object as a bean but in practice this is rarely done.\nNote that the event object must extend class java.util.EventObject. EventObject provides the getSource() method so we can determine the event origin. By extending EventObject, we can handle these objects generically in other methods, and some tools, like VisualAge for Java, take advantage of this when creating generic methods to forward events.\n1package effectivevaj.bean.intro.eventsets; 2 3import java.util.Date; 4import java.util.EventObject; 5 6// An event that represents the Sun rising or setting 7public class SunEvent extends EventObject { 8 private boolean risen; 9 private Date date; 10 11 public SunEvent(Object source, boolean risen, Date date) { 12 super(source); 13 this.risen = risen; 14 this.date = date; 15 } 16 17 // return a String representation of the date 18 public String getDate() { 19 // return only a String representation 20 // so the user cannot modify the real date 21 return date.toString(); 22 } 23 24 // return whether the sun rose or set 25 public boolean isRisen() { 26 return risen; 27 } 28} EventObject requires a source (a reference to the object that fired the event), which we set to our WeatherStation bean when firing the event. Whenever we fire events, we create an instance of the EventObject class and pass it to each registered listener.\nAn Event-Listener Interface Event listeners are classes that have registered interest in an event that a bean can fire. The bean notifies listener classes by calling certain methods in those listener classes. But how does the bean know which methods to call?\nWhen defining our event, we also define a contract between the event source and its listeners. This contract specifies which methods the event source will call. Any listeners must implement these methods. Sounds like a perfect use for a Java language interface!\nTherefore, we define an interface that specifies our contract. Because each listener must implement that interface, the event-source bean can determine which methods it can call. Continuing our example, we define a simple interface for our sun events.\nNote that the following interface extends the java.util.EventListener interface. EventListener requires no methods. It is just a tag that indicates an interface is acting as an event listener. This assists determination of the events a bean can fire.\n1package effectivevaj.bean.intro.eventsets; 2 3import java.util.EventListener; 4 5// A contract between a SunEvent source and 6// listener classes 7public interface SunListener extends EventListener { 8 // Called whenever the sun changes position 9 // in a SunEvent source object 10 public void sunMoved(SunEvent e); 11} We require that any SunEvent listeners implement a single method, sunMoved(). Normally, event-listener methods should take a single parameter: the event object. However, if you have a strong need, the Beans specification allows (but strongly discourages) different parameters.\nAn Event-Source Bean Now we define the source of our sun events, the WeatherStation. This class needs to track its listeners and fire the events. We implement this as follows, and provide a simple GUI to trigger the SunEvents:\n1package effectivevaj.bean.intro.eventsets; 2 3import java.util.Vector; 4import java.util.Date; 5import java.util.Enumeration; 6import java.awt.Button; 7import java.awt.Frame; 8import java.awt.GridLayout; 9import java.awt.event.ActionListener; 10import java.awt.event.ActionEvent; 11import java.awt.event.WindowAdapter; 12import java.awt.event.WindowEvent; 13import java.io.Serializable; 14 15// A sample event source - this class fires SunEvents 16// to anyone watching. A simple GUI is provided 17// with \u0026#34;rise\u0026#34; and \u0026#34;set\u0026#34; buttons that cause the 18// SunEvents to be fired. 19public class WeatherStation extends Frame implements Serializable { 20 private transient Vector listeners; 21 22 // Provide a simple GUI that triggers our SunEvents 23 public WeatherStation() { 24 super(\u0026#34;Sun Watcher\u0026#34;); 25 setLayout(new GridLayout(1,0)); 26 Button riseButton = new Button(\u0026#34;Rise\u0026#34;); 27 Button setButton = new Button(\u0026#34;Set\u0026#34;); 28 add(riseButton); 29 add(setButton); 30 31 // make the \u0026#34;Rise\u0026#34; button fire \u0026#34;rise\u0026#34; SunEvents 32 riseButton.addActionListener(new ActionListener() { 33 public void actionPerformed(ActionEvent e) { 34 fireSunMoved(true); 35 } 36 }); 37 38 // make the \u0026#34;Rise\u0026#34; button fire \u0026#34;set\u0026#34; SunEvents 39 setButton.addActionListener(new ActionListener() { 40 public void actionPerformed(ActionEvent e) { 41 fireSunMoved(false); 42 } 43 }); 44 45 // Provide a means to close the application 46 addWindowListener(new WindowAdapter() { 47 public void windowClosing(WindowEvent e) { 48 System.exit(0); 49 } 50 }); 51 52 pack(); 53 } 54 55 // Register a listener for SunEvents 56 synchronized public void addSunListener(SunListener l) { 57 if (listeners == null) { 58 listeners = new Vector(); 59 } 60 listeners.addElement(l); 61 } 62 63 // Remove a listener for SunEvents 64 synchronized public void removeSunListener(SunListener l) { 65 if (listeners == null) { 66 listeners = new Vector(); 67 } 68 listeners.removeElement(l); 69 } 70 71 // Fire a SunEvent to all registered listeners 72 protected void fireSunMoved(boolean rose) { 73 // if we have no listeners, do nothing... 74 if (listeners != null \u0026amp;\u0026amp; !listeners.isEmpty()) { 75 // create the event object to send 76 SunEvent event = new SunEvent(this, rose, new Date()); 77 78 // make a copy of the listener list in case 79 // anyone adds/removes listeners 80 Vector targets; 81 synchronized (this) { 82 targets = (Vector) listeners.clone(); 83 } 84 85 // walk through the listener list and 86 // call the sunMoved method in each 87 Enumeration e = targets.elements(); 88 while (e.hasMoreElements()) { 89 SunListener l = (SunListener) e.nextElement(); 90 l.sunMoved(event); 91 } 92 } 93 } 94} Our event source can now notify interested listeners. The synchronized keywords and cloning are necessary to avoid possible problems if the list of listeners changes while we are notifying listeners. Pressing the Rise and Set buttons fires an appropriate SunEvent to any registered listeners.\nTypically, developers will create a fire method similar to the previous fireSunMoved() method, but the method is not required. The event-firing code can appear in any method you prefer. VisualAge for Java will create a method similar to this fire method, taking a SunEvent as its argument.\nA Sample Event Listener In our example, the weather channel informs any interested parties about the sun rising or setting. Continuing this example, Mrs. Jones assigns her class the task of graphing the behavior of the sun. They must watch a weather channel to find out at exactly what time the sun rose and set each day, logging this information in their notebook. We can model this example using a Student class as follows:\n1// A sample SunListener, logging when the sun rises and sets 2public class Student implements SunListener { 3 private String name; 4 5 public Student(String name) { 6 this.name = name; 7 } 8 9 public void sunMoved(SunEvent e) { 10 log(name + \u0026#34;\\tlogs : \u0026#34; + (e.isRisen() ? \u0026#34;rose\u0026#34; : \u0026#34;set\u0026#34;) + 11 \u0026#34; at \u0026#34; + e.getDate()); 12 } 13 14 protected void log(String text) { 15 System.out.println(text); 16 } 17} Note that Student implements SunListener, defining the details of a sunMoved() method. Any number of Students may watch the weather channel to hear the time of sunrise and sunset.\n1package effectivevaj.bean.intro.eventsets; 2 3// A simple test of the SunEvent source and listeners 4public class WeatherTest { 5 // Run a test on the weather station, using Scott\u0026#39;s 6 // kids as sample students 7 public static void main(String[] args) { 8 // create a new sun event source 9 WeatherStation w = new WeatherStation(); 10 11 // add some students to listen for sun rise/set 12 w.addSunListener(new Student(\u0026#34;Nicole\u0026#34;)); 13 w.addSunListener(new Student(\u0026#34;Alex\u0026#34;)); 14 w.addSunListener(new Student(\u0026#34;Trevor\u0026#34;)); 15 w.addSunListener(new Student(\u0026#34;Claire\u0026#34;)); 16 17 // display the GUI for the weather channel 18 w.setVisible(true); 19 } 20} Running WeatherTest and pressing the Rise and Set buttons results in something like the following:\nNicole logs : rose at Thu Apr 29 14:55:21 PDT 1999\rAlex logs : rose at Thu Apr 29 14:55:21 PDT 1999\rTrevor logs : rose at Thu Apr 29 14:55:21 PDT 1999\rClaire logs : rose at Thu Apr 29 14:55:21 PDT 1999\rNicole logs : set at Thu Apr 29 14:55:22 PDT 1999\rAlex logs : set at Thu Apr 29 14:55:22 PDT 1999\rTrevor logs : set at Thu Apr 29 14:55:22 PDT 1999\rClaire logs : set at Thu Apr 29 14:55:22 PDT 1999\rWarning!\nThe above listener methods run in a specific order each time an event is fired. This is because we stored the listeners in an ordered data structure. HOWEVER, There is NO guarantee of event-notification order in the Beans specification! Unless a bean documents its event-firing behavior as ordered, you should not assume any particular order of notification. Beans could store their listeners in any data, and they may report them in a different order every time they fire an event.\nAlso, note that event firing is synchronous. That is to say, the event source calls only one event handler at a time. Most beans fire their events in this manner (although there is nothing to stop you from writing a bean that fires events asynchronously). Because of this, you should perform only short operations in your event handlers. Think of it this way: The next listener has to wait for you, so you should be courteous and return as quickly as possible. If you need more complex operations, spawn another thread from your event handler.\nDetermining Which Events Are Fired Events are useful when writing code by hand, but they require a lot of code. Fortunately, bean-builder tools can provide assistance in generating this code. But how can a bean-builder tool determine which events can be fired so it can assist?\nRecall that methods define properties using certain naming conventions; we define events in a similar manner. Bean-builder tools look for methods with the following naming pattern:\n1public void addSomeName(SomeName l) 2public void removeSomeName(SomeName l) When a tool sees a method that matches this naming pattern, it checks to see if SomeName is an interface that implements EventListener. (Remember that tag we added to the SunListener interface?) A method matching this pattern defines an event set.\nOnce identified, the bean-builder tool examines the event listener interface to see which methods it requires. These methods are possible events that the bean can fire. Using this information, the bean-builder tool can tell the user which events a bean can fire, enabling the user to associate an event from one bean with an action on another. We will see later how the bean-builder tool can use this information to help a user generate an application.\nMethods The last type of bean features are methods. You may have guessed by now that bean methods are leftovers; that is, they are any public methods that remain after we determine properties and event sets. Bean-builder tools can present a list of methods to the programmer, stating available actions for any given bean. Bean tools do not treat method features as anything special. Normally you just connect to them as the result of some event being fired.\nBean-Builder Tools and Beans Now that we know how tools can recognize bean features, we can explore how these tools use beans.\nBean-builder tools typically have a tool bar or palette that holds pictures of commonly used beans. The user selects one of these beans and drops it in a design area that represents the class being built. The user can drop multiple beans in the design area; some tools allow only graphical user-interface beans, while other tools allow any beans.\nThe user can ask for a property sheet for any bean in the design area. Property sheets are dialogs that contain a list of property names and values. The bean-builder tool determines which properties are available and then calls the appropriate get method to display the current values of those properties. The user can then modify writeable properties (properties with set methods).\nValues set in a property sheet represent the initial state of that particular bean instance. Of course, the program can modify the property values during execution by invoking their set methods. When a bean-builder tool generates source code for a bean, it creates new statements for each bean, as well as calls to each set method to set the property values specified in the property sheet.\nMost bean-builder tools enable the user to specify interactions between beans. These interactions start with one bean firing an event, and end by calling a method or setting a property in another (or the same) bean. Some tools provide wizards to specify this interaction, while others enable the user to draw lines between components, choosing the source event and target feature via pop-up menus. The bean-builder tool can generate an event listener to respond to these events and call the appropriate target method. VisualAge for Java provides the most advanced bean-builder tool available, its Visual Composition Editor.\nIntrospection and the Role of BeanInfo Classes Introspection is the process of determining which features a bean supports. In its most basic form, introspection is simply a process of using the Java core reflection classes to determine which public methods the bean defines and match those methods against the bean naming patterns.\nThe introspection process examines the bean class and proceeds to each superclass. The process inspects public methods in each class, adding them to the list of features. If any duplicate features exist, subclass definitions take precedence. Often this provides the desired functionality; sometimes it can fall short.\nHow can we hide features from the user of a bean-builder tool? How can we allow only expert users to see some features, while non-expert users see only very basic features? How can we change the way the user interacts with the properties in a property sheet, or enable several properties to be set as a group? Explicit metadata is required to address these and other issues, describing exactly what we want. The bean specification calls this metadata BeanInfo. BeanInfo are classes that are delivered along with beans. Any bean may have a BeanInfo class, which describes in detail the features provided by that bean.\nBeanInfo classes are associated with a bean by a simple naming convention. The name of the BeanInfo class is the name of the bean with \u0026quot;BeanInfo\u0026quot; as its suffix. For example, a bean named Person could have a PersonBeanInfo class that describes it. BeanInfo classes all implement the java.beans.BeanInfo interface, which requires methods that return arrays of PropertyDescriptors, MethodDescriptors, and EventSetDescriptors as well as general information about the bean itself.\nIf the introspection process discovers a BeanInfo class, it queries that BeanInfo class to determine features instead of examining public method names. The FeatureDescriptors (PropertyDescriptors, MethodDescriptors, and EventSetDescriptors) provide the names and descriptions of the features. Each FeatureDescriptor can contain additional information, stating if a feature should be hidden or considered expert. The bean-builder tool uses the FeatureDescriptor information to filter the features that are available. PropertyDescriptors can also specify a property editor, one means of customizing the way a user edits a propertyâ€™s value in the bean-builder tool.\nFinally, the BeanInfo class provides a BeanDescriptor, which describes the overall bean, possibly including a Customizer (which provides customized editing for the entire bean) and icons to represent the bean in the bean-builder toolâ€™s palette. BeanInfo classes are tedious to write, but fortunately, many tools, such as VisualAge for Java, generate them for you.\nKeep in mind that once you define a BeanInfo class, it is in charge of describing bean features. If you add new methods to your bean, bean builder tools will not know about them unless you add the features to the BeanInfo class as well.\n","link":"https://javadude.com/post/20000304-javabeans/","section":"post","tags":["java","beans","design"],"title":"The JavaBean Component Model"},{"body":"Accessors are a key ingredient to proper encapsulation.Â The can restrict access to only read/write data, inform other objects of changes to data, and perform validation on new values being set.Â Consistent accessor usage makes class modification easy and transparent.\nWhat are Accessors? An accessor is a method that allows read or write access to a piece of class or instance data.Â These are commonly defined using the naming convention\nget_VarName_() -- reads the data for class/instance variable varName set_VarName_(value) -- sets the value for class/instance variable varName By providing and using accessor methods to read/write data contained within a class, you provide stronger encapsulation for the data of that class.Â This has several advantages, especially if you decide to change the implementation of the underlying data (or remove the data itself and replace it with a computation).\nIn addition, creating accessors for a private class/instance variable allow you to restrict access to read-only or write-only by providing only a get or set method.\nBut That's Inefficient! The most-common objection to use of accessors is \u0026quot;but that's another method call, and it will drastically slow down my program!\u0026quot;\nNot any more!\nThe new HotSpot VM provides excellent run-time optimization.Â Part of this optimization is automatic inlining of simple methods.Â If you write accessors that just set and return a value, these will be inlined to simple assignment statements.Â Accessors that do more may still be inlined, depending on their complexity.\nBottom line: set aside any worries about accessors causing a performance hit.\nAll Data Must Be Private! I could go on and on about this forever, but I'll try to keep it brief: All data defined in a class must be private!\nI may sound a bit like an \u0026quot;OO-purist\u0026quot; when I say this, but I view this from a practical standpoint, having been burned by not doing it...\nMaking data (by data I mean class and instance variables) non-private allows another class to change their values without the owner of that data knowing about the change.Â If the owner doesn't know about the change:\nthe owner has no control over the value; it could be outside the intended range of the data the owner cannot know the value has change, and cannot respond if needed the owner cannot tell others that the value has changed the owner cannot allow others to veto the change On top of these problems, if you ever decide to change your code to allow other classes to listen for changes, or restrict bounds on a variable, you would need to find every reference to the data and change it.Â This can be very painful if the class were a public library that many people had used in their own code.\nEven worse, you cannot change the implementation of the data without changing the users of that data.Â For example, suppose you had an integer instance variable to keep track of some ID for a list node.Â Perhaps you had done some research and decided that the memory cost of keeping that ID was more expensive than recomputing it the few times it was needed.Â If ID were only available via an accessor, all you would need to do to affect the change is to remove the instance variable and change the getID accessor to compute the ID and return it.Â Far simpler than creating the getID accessor and going back and changing every reference to x.id...\nPrivacy is the key to true encapsulation.Â All manipulation of an object's state must be done by the object itself!\nOnce you use accessors to read/write class/instance data, that data is instantly available as a JavaBean property!\nJavaBean Properties The Java Bean spec defines the entities described by get and set accessors as \u0026quot;properties\u0026quot;.Â I use the term entities here because a property does not need to have any actual data associated with it.Â (A get method could just perform a computation instead of returning a variable's value.)Â By using the simple get/set naming convention, any tool that supports JavaBeans can determine which properties are available for a bean just by looking at the names of the provided methods!\nJavaBean properties come in four flavors:\nsimple properties bound properties constrained properties indexed properties Properties can be any combination of bound, constrained and indexed, or just \u0026quot;simple\u0026quot; properties.\nSimple Properties These are basic properties defined by a JavaBean, and can be readable, writable or both.\nBound Properties This is where the real power of accessors shines.Â A bound property is one that will dispatch an event any time it has changed.Â By restricting write access of a property to its set method, you can have the set method fire PropertyChangeEvents to any object registered to listen for a change to that property!\nConstrained Properties Taking the bound concept a bit further, we can tell listeners that a property has changed and allow those listeners to veto the change!Â This works pretty much the same as a bound property, but if the listener doesn't agree with the change, he can throw a PropertyVetoException which the property's set method will respect and halt the actual data change.\nIndexed Properties The JavaBeans specification provides for one more type of property.Â Indexed properties are properties that appear like arrays.Â You can read or write the entire group of property values with one get/set method, or you can read/write individual elements of that indexed property.Â Again, the data does not have to be represented as an array; it could be stored in any format, or there might not even be data behind the property.\nUse Accessors in the Class that Defines the Data! A final note: All references to class/instance data should be through accessors, even if the reference is in the class that defines that data!Â This centralizes access to the data, allows all changes to be known (including notification for bound and constrained properties.)\nThis may seem like a bit of overkill, but if you ever need to change how a property is implemented, you'll be glad you used accessors consistently.\n","link":"https://javadude.com/post/20000304-accessors/","section":"post","tags":["java","language","design"],"title":"Using JavaBean Accessors"},{"body":"Java provides three types of comments; when should we use which?\nSingle-Line (C++-Style) Comments The simplest comment in Java is the single line comment. It starts with two forward slashes and continues to the end of the line. For example:\n1// this is a single-line comment 2x = 1; // a single-line comment after code Multi-Line (C-Style) Comments Java also provides a comment type that can span multiple lines. You start this type of comment with a forward slash followed by an asterisk, and end it with an asterisk followed by a forward slash. The start and end delimiters for this type of comment may be on the same line, or they can be on different lines. For example\n1/* This is a c-style comment */ 2 3/* This is also a 4 c-style comment, spanning 5 multiple lines */ Note that C-style comments cannot be nested. Something like\n1/* A comment looks like 2 /* This is a comment */ 3 blah blah blah 4*/ will generate a syntax error because the java compiler will only treat through the first */ as a comment. (The comment ends at the first */ the compiler sees.)\nYou can nest single-line comments within multi-line comments:\n1/* This is a single-line comment: 2 // a single-line comment 3*/ and multi-line comments in single-line comments:\n1// /* this is 2// a multi-line 3// comment */ Documentation Comments Documentation comments are special comments that look like multi-line comments but can be used to generate external documentation about your source code. These begin with a forward slash followed by two asterisks, and end with an asterisk followed by a forward slash. For example:\n1/** This is a documentation comment */ 2 3/** This is also a 4 documentation comment */ There are a few important things to note about documentation comments:\nThe documentation generator, javadoc, will add all text inside a documentation comment to an HTML paragraph. This means that any text inside a documentation comment will be formatted into a paragraph; spacing and line breaks are ignored. If you want special formatting, you must include HTML tags inside your documentation comment.* If a documentation comment begins with more than two asterisks, javadoc assumes this is just used to create a \u0026quot;box\u0026quot; around the comment in the source code and ignores the extra asterisks. For example:\n1/********************************** 2 This is the start of a method 3**********************************/ will only keep the text \u0026quot;This is the start of a method\u0026quot;.\njavadoc will ignore leading asterisks inside a documentation-comment block. For example:\n1/*************************************** 2 * This is a doc comment 3 * on multiple lines that I want to stand 4 * out in source code, looking \u0026#34;neat\u0026#34; 5 ***************************************/ will only keep the text \u0026quot;This is a doc comment on multiple lines that I want to stand out in source code, looking \u0026quot;neat\u0026quot;\u0026quot;\nIt's common practice to use something like\n1/****************************************** 2... 3******************************************/ to make a comment stand out. Be aware that this is treated as a documentation comment (even if that's not what you had intended), and could show up in the generated documentation.\nWhen to Use Documentation Comments Documentation comments should (at very least) be used in front of every public class, interface, method and class/instance variable in your source code. This allows someone to run javadoc against the code and generate a simple document that lists the public entities and a brief description of each. You may also use documentation comments in front on non-public methods, and use a javadoc option to generate documentation for them. Using documentation comments on non-public entities is not as important as publics (the interface isn't exposed...) but if you're commenting the code anyway you might as well write those comments as documentation comments.\nWhen to Use Single-Line Comments Always!\nMy simple advice on commenting is that whenever you want to write a normal comment (not a documentation comment that describes and class, interface, method or variable) use a single line comment.\nWhy? Because you can easily use multi-line comments to \u0026quot;comment out\u0026quot; a section of your code! (\u0026quot;Commenting out code\u0026quot; refers to changing the lexical state of a section of source code to being inside a comment, making the compiler ignore that code.) Take as an example:\n1x = 1; /* set x to 1 */ 2y = 2; /* set y to 2 */ 3f(x, y); /* call f with x and y */ If you want to comment out these three lines, you would either need to put a single line comment in front of each line:\n1// x = 1; /* set x to 1 */ 2// y = 2; /* set y to 2 */ 3// f(x, y); /* call f with x and y */ or add in multi-line comments wherever there isn't already one present:\n1/* x = 1; */ /* set x to 1 */ 2/* y = 2; */ /* set y to 2 */ 3/* f(x, y);*/ /* call f with x and y */ or mutilate/remove the \u0026quot;end comment\u0026quot; delimiters of the existing comments:\n1/* 2 x = 1; /* set x to 1 * / 3 y = 2; /* set y to 2 * / 4 f(x, y); /* call f with x and y * / 5*/ None of these are terribly pleasant. It's much easier if the original code were:\n1x = 1; // set x to 1 2y = 2; // set y to 2 3f(x, y); // call f with x and y then you can easily comment it out by just placing a multi-line comment around it:\n1/* 2x = 1; // set x to 1 3y = 2; // set y to 2 4f(x, y); // call f with x and y 5*/ Always use single-line comments for your everyday commenting needs!\nNOTE: Most IDEs have a simple \u0026quot;comment-out\u0026quot; function - highlight a block and it comments it out. Most often, it simply prepends // at the front of each selected line.\nWhen to Use Multi-Line Comments After reading the above section, this becomes obvious. Only use multi-line comments to comment out sections of code. Never use them for any other purpose!\n","link":"https://javadude.com/post/20000304-comments/","section":"post","tags":["java","language"],"title":"Using the Right Comment in Java"},{"body":"A VisualAge for Java plugin to create interfaces from classes\nNews 10/17/2018\nI'm converting my website to a new form. This tool is obsolete (as it is a VisualAge for Java plugin), but I wanted to keep it here for historical purposes 6/7/2003\nIn case you didn't know, Eclipse has this function built in. To use it Select the name of a class in Eclipse Choose Refactor-\u0026gt;Extract Interface 10/24/99\nInitial release of autogut Status: An initial release - not entirely robust, but should work pretty well. I need to add a bit more checking for situations like \u0026quot;project already exists in repository\u0026quot; and ask if you want to create it. I suggest for now that you always use the Browse buttons for project and package.\nThis release has not undergone a great deal of testing, but should not pose any risks to your existing data. It does not modify theÂ Introduction VisualAge for Java provides some excellent tools for JavaBean component creation and maintenance. However, it is often important to create interfaces to abstract a bean, especially for use in design patterns such as Model-View-Controller (MVC).\nIn a normal MVC development cycle, you first create your interfaces, then implement them as concrete models. Conceptually, this is the right way to go. However, this can involve a lot of typing. Often, the model interface provides standard bound properties and custom event registration capabilities.\nVisualAge for Java's BeanInfo editor creates JavaBean properties and events quite easily. We can leverage this by creating a concrete model first, then gutting it to create an interface.\nAutoGut examines an existing class and creates an interface for all of its public methods. This provides a good initial interface that you can use for your model. You may need to do a bit of tweaking (AutoGut currently does not copy import statements, for example), but this is much simpler than writing the interface by hand.\nDistribution I have just packaged autogut as a tool for VisualAge for Java 3.0. It will probably work in version 2.0 but I have not tested it there.Tools\nInstallation for VisualAge for Java - Tool Packaging To use AutoGut in VisualAge for Java:\nDownload autogut.zip from this site. Unzip autogut.zip to the directory where VisualAge for Java is installed.Â For example, C:\\IBMVJava. Shutdown VisualAge for Java if it is running Start VisualAge for Java. This will add the autogut tool to the Workspace-\u0026gt;Tools menu, as well as the Tools menu for classes.\nSource Code If you're interested in the source code for this tool, you can download Autogut-dat.zip. Note that you do not need the source code to use the tool. This is a zipped VisualAge for Java repository file. You will need to unzip this file and import the JavaDude AutoGut project from this repository.\nUse VisualAge for Java To use AutoGut (once it is installed)\nSelect Tools-\u0026gt;Create Interface from Class from the Workbench menu or from a class' popup menu Specify the name of the class to gut (automatically selected if you had started AutoGut from a class' tool menu) Specify the name of the interface you want to create Specify the project and package where you want to create that interface. Note that if you pick a package that is in the workspace it will automatically select the project. Limitations Currently the tool does not copy the import statements from the class. You may need to add them yourself.\nThe tool is not completely bulletproof yet, though it's in pretty good shape. Just be careful what you type.\nLicense AutoGut free for any use other than selling it as a stand-alone product.\nNote that AutoGut is provided \u0026quot;as-is\u0026quot; without any warrantee or guarantee of suitability for any purpose. Scott Stanchfield cannot be held responsible for any damage caused by its use.\n(In other words, use 'em for free at your own risk.)\n","link":"https://javadude.com/post/19991024-autogut/","section":"post","tags":["java"],"title":"Autogut"},{"body":"A Layout Manager for Split Windows\nNOTE: I'm updating my website, and this is pretty ancient... I'm keeping this here for historical purposes. Ran the code in Android Studio to get pics... Still works, but maaaaaan, it's ugly. Some folks actually used it back-in-the-day, and I used it in ParseView...\nSplitterLayout is a simple layout manager that handles segmented displays with optional draggable bars between them.Â In its simplest use, it's just a nice proportional layout manager.Â More complex uses can create some interesting GUIs.\nHere are some examples.Â I'll add more information to this page as I get time.Â SplitterLayout is available as part of the TabSplitter distribution.Â See TabSplitter for details on how to download it.\nNOTE 1: All of these examples require a JDK 1.1 compatible browser.\nNOTE 2: Because I use AWT Windows to represent the SplitterBars as they are moving, they will probably appear with the words \u0026quot;Warning Applet Window\u0026quot; or something like that on them as they are being dragged.Â I'm trying to come up with a solution for this... Grr... Arg...\nProportional layouts with no SplitterBars The above layout was created with the following code:\npackage com.magelang.test;\r// GAH! Forgive the import-on-demand... I wrote this before my article on it!\rimport java.applet.*;\rimport java.awt.*;\rimport com.magelang.splitter.*;\rpublic class SplitterEx1 extends Applet {\rpublic void init() {\rsuper.init();\rsetLayout(new SplitterLayout(SplitterLayout.HORIZONTAL));\radd(\u0026quot;1\u0026quot;,new Button(\u0026quot;A (1)\u0026quot;));\radd(\u0026quot;2\u0026quot;,new Button(\u0026quot;B (2)\u0026quot;));\radd(\u0026quot;4\u0026quot;,new Button(\u0026quot;C (4)\u0026quot;));\radd(\u0026quot;8\u0026quot;,new Button(\u0026quot;D (8)\u0026quot;));\radd(\u0026quot;3\u0026quot;,new Button(\u0026quot;E (3)\u0026quot;));\r}\r} The quoted numbers act as proportions to determine the amount of space each component gets.\nAdding SplitterBars The above layout was created with the following code:\npackage com.magelang.test;\nimport java.applet.*;\rimport java.awt.*;\rimport com.magelang.splitter.*;\rpublic class SplitterEx2 extends Applet {\rpublic void init() {\rsuper.init();\rsetLayout(new SplitterLayout(SplitterLayout.HORIZONTAL));\radd(\u0026quot;1\u0026quot;,new Button(\u0026quot;A (1)\u0026quot;));\radd(new SplitterBar());\radd(\u0026quot;2\u0026quot;,new Button(\u0026quot;B (2)\u0026quot;));\radd(new SplitterBar());\radd(\u0026quot;4\u0026quot;,new Button(\u0026quot;C (4)\u0026quot;));\radd(new SplitterBar());\radd(\u0026quot;8\u0026quot;,new Button(\u0026quot;D (8)\u0026quot;));\radd(new SplitterBar());\radd(\u0026quot;3\u0026quot;,new Button(\u0026quot;E (3)\u0026quot;));\r}\r} Adding Splitterbars between components allows the user to resize the components.Â The quoted numbers are now only used as an initial size for the components.\nSplitterBars can contain other components! SplitterBars are just Panels with dragging and painting stuff added.Â They can contain any other components you want in any layout (even another SplitterLayout!)Â The following shows a simple \u0026quot;movable status bar\u0026quot; layout:\nThe above layout was created with the following code:\npackage com.magelang.test;\nimport java.applet.*;\rimport java.awt.*;\rimport com.magelang.splitter.*;\rpublic class SplitterEx3 extends Applet {\rpublic void init() {\rsuper.init();\rsetLayout(new SplitterLayout(SplitterLayout.VERTICAL));\radd(\u0026quot;1\u0026quot;,new Button(\u0026quot;A (1)\u0026quot;));\rSplitterBar b1 = new SplitterBar();\rb1.setLayout(new GridLayout(1,0));\rb1.add(new SplitterSpace());\rb1.add(new Label(\u0026quot;Status\u0026quot;));\rb1.add(new TextField(\u0026quot;Enter your name\u0026quot;));\rb1.add(new SplitterSpace());\radd(b1);\radd(\u0026quot;2\u0026quot;,new Button(\u0026quot;B (2)\u0026quot;));\rSplitterBar b2 = new SplitterBar();\rb2.setLayout(new SplitterLayout(SplitterLayout.HORIZONTAL));\rb2.add(\u0026quot;5\u0026quot;,new SplitterSpace());\rb2.add(new SplitterBar());\rb2.add(\u0026quot;10\u0026quot;,new Label(\u0026quot;Status\u0026quot;));\rb2.add(new SplitterBar());\rb2.add(\u0026quot;40\u0026quot;,new TextField(\u0026quot;Enter your name\u0026quot;));\radd(b2);\radd(\u0026quot;4\u0026quot;,new Button(\u0026quot;C (4)\u0026quot;));\r}\r} ","link":"https://javadude.com/post/19980228-splitterlayout/","section":"post","tags":["java"],"title":"SplitterLayout"},{"body":"JavaBeans for BoxLayout Visualization\nNews 10/17/2018\nUpdating this website. The VisualAge for Java version of these beans are obsolete, and I'm just keeping this around for historical purposes. The beans themselves might still work in GUI builders, but I haven't tested them in years, and the source is in a VisualAge repository so I can't get to it... 11/26/1998\nWith the current VisualAge fixpacks you no longer need the extra swing package.Â I've removed them from the VAJ distribution I've added a JAR file distribution and tested it with JBuilder -- it seems to work just fine! Introduction Swing's BoxLayout is a fairly useful layout manager, but using it in a visual environment such as VisualAge for Java's Visual Composition Editor isn't easy.\nThere are several problems to face:\nThe Box class isn't a bean Support for \u0026quot;struts\u0026quot; and \u0026quot;glue\u0026quot; is only provided programmatically BoxLayout uses getPreferredSize(), getMaximumSize() and getMinimumSize() to perform its calculations.Â These sizes are settable for Swing components, but for non-swing components you must subclass components to change them. This became frustrating while teaching, so I developed the Box Beans.Â The box beans provide visual support for easy use of BoxLayout.\nThe following beans are provided:\nBoxAdapter - a simple container that can be used to change the resize behavior of any component in a BoxLayout.Â It has four boolean properties:\nshrinkHorizontal - controls the \u0026quot;width\u0026quot; when asked for getMinimumSize(). shrinkVertical - controls the \u0026quot;height\u0026quot; when asked for getMinimumSize(). stretchHorizontal - controls the \u0026quot;width\u0026quot; when asked for getMaximumSize(). stretchVertical - controls the \u0026quot;height\u0026quot; when asked for getMaximumSize(). When any of these properties is false, the appropriate value from getPreferredSize() is returned.Â For example, if all of these properties are false, the component will always be displayed at its preferred size.Â If all are true, the component will stretch and shrink as needed.\nBy placing a BoxAdapter in a BoxLayout-controlled Container, you can have it control the resize behavior of its contained Component(s).\nBy default, BoxAdapter uses GridLayout(1,0) as its layout manager.Â It is really intended to hold a single component, though it could be used anywhere a Container is needed.\nVerticalStrut - Represents a fixed-size vertical component, used for fixed spacing in a y-axis-oriented BoxLayout.\nHorizontalStrut - Represents a fixed-size horizontal component, used for fixed spacing in a x-axis-oriented BoxLayout.\nVerticalGlue - Represents a varying size vertical component, used to force space between other components in a y-axis-oriented BoxLayout.\nHorizontalGlue - Represents a varying size horizontal component, used to force space between other components in a x-axis-oriented BoxLayout.\nThe struts have a \u0026quot;pixels\u0026quot; property that controls how much space they take up.Â Glue doesn't need it, as it expands and collapses as needed.\nAll of the above beans have a design representation.Â That is, when used in a bean builder, they will paint an image to easily identify themselves.Â When used at runtime, no image will be painted.Â For example:\nNote that the struts and Glue have minimum sizes that are \u0026gt; 0 when designing with them.Â This ensures that they are visible at design time, and may cause the layout to look slightly different when the bean is actually run.\nBoxAdapter in particular would normally be (0,0) when empty.Â However, to help visual design I set it up to (20,20) when empty at design time.Â That way you can just drop another bean right on top of it without using the Beans List.\nDistribution I have just packaged these as a \u0026quot;feature\u0026quot; for VisualAge for Java 2.0.Â I will set up a standard jar file later for use in other (inferior ;) ) environments.\nInstallation for VisualAge for Java - Feature Packaging To use the Box Beans in VisualAge for Java:\nDownload box-vaj.zip from this site. Unzip box.zip to the directory where VisualAge for Java is installed.Â For example, C:\\IBMVJava. Start VisualAge for Java. Select \u0026quot;Quick Start\u0026quot; from the \u0026quot;File\u0026quot; menu. Select \u0026quot;Add feature\u0026quot; from the \u0026quot;Features\u0026quot; category. Select \u0026quot;Javadude Box Beans\u0026quot; to install the box beans. This will add the box beans to both the AWT and Swing palettes, with the following icons:\nBoxAdapter VerticalStrut HorizontalStrut VerticalGlue HorizontalGlue If anyone has some better icon images, please let me know and I'll include them!\nInstallation for Other IDES - Standard JAR File A standard JavaBean JAR file exists at boxbeans.jar.Â I've tested this under JBuilder and it seems to work ok.\nUse VisualAge for Java To use the Box Beans (once they are installed)\nOpen a class to the VCE Add a Container (Panel, JPanel, whatever) to your composition Set that Container's layout to BoxLayout Drop combinations of of the beans in the BoxLayout-controlled Container. If you want to add other beans (like a java.awt.Button), drop a BoxAdapter in the BoxLayout first, then drop the other bean inside it.Â Adjust the properties of the BoxAdapter to get the resize behavior you want. Adjust the \u0026quot;pixels\u0026quot; property of the struts to control how much space they reserve. Other IDEs or BeanBox Setup and use depends on the IDE in question.Â As I test against other IDEs I will post usage instructions.\nIn JBuilder, you can add the jar file to the palette and use it the same way as in VisualAge for Java.\nLicense Box Beans are free for any use other than selling them as a stand-alone product.\nNote that these beans are provided \u0026quot;as-is\u0026quot; without any warrantee or guarantee of suitability for any purpose. Scott Stanchfield cannot be held responsible for any damage caused by use of these beans.\n(In other words, use 'em for free at your own risk.)\n","link":"https://javadude.com/post/19981126-boxbeans/","section":"post","tags":["java"],"title":"BoxBeans"},{"body":"Visual Debugging for ANTLR 2.x\nStatus 10/17/2018\nCleaning up my website. This tool is obsolete; it was a debugger for ANTLR 2.x. I'm keeping it here for historical purposes. (Wow... It's over 20 years old!) 6/17/1999\nParseView 1.2** released! This source-only release will only work with\nANTLR 2.6.0 and later\nJDK 1.1.x or Java 2\nSwing with package names starting with javax.swing\nIncluded in Java2, or Swing 1.1 or later You need to compile the distributed files in parseview1.2.zip and place them in your CLASSPATH. Then follow the operating instructions at the end of this page.\n1/22/1999\nYou can now download ParseView from this link: ParseView.zip. (People had trouble finding it at http://www.antlr.org.) ParseView will be distributed as an add-on feature.Â Terence and I decided it would be easier for me to provide updates if I controlled it. This version of ParseView only works with ANTLR 2.5.x and earlier 7/17/1998\nI've given a first pass of the tool to Terence.Â He's checking things out and making sure I didn't break ANTLR. Developed a good debugging model for ANTLR that will make it easy to add any sort of debugger you want (especially ParseView).Â The API for this will eventually be documented so people can add their own debuggers, simple (like just \u0026quot;println\u0026quot;s) or complex, like ParseView. ParseView will be a free part of the real ANTLR distribution.Â Terence and I realized it would just be too much work to try to really have this be supported the way a \u0026quot;pay\u0026quot; tool should be.Â We just don't have that much time.Â Instead, we're releasing it with source so others can add to it. The source will be included with the distribution.Â Please refrain from making changes just yet -- I'd like to add a few more things, like breakpoints and some AST stuff before people start sending in changes to integrate. Send mail to Scott Stanchfield with any comments, suggestions, ideas or recipes!\nCurrent State of the Tool The tool currently supports the following features.\nParse Tree and Scan Tree\nRules entered Tokens matched Semantic Predicates result of the predicate evaluation predicting or validating Syntactic Predicates when they are started when they finish if they failed or succeeded (color coded red or green) Rules and tokens inside a guess are displayed with a yellow background Status of parse (what was matched when parser paused, line numbers while parse is running) Controller\nNote: The controller currently only controls the Parse Tree -- you cannot step using through the scan tree yet.Â Sorry -- I just ran out of time... Step to next rule entry Step to exit of current rule Step to next matched token Step to next semantic predicate evaluation Step to start/end of next syntactic predicate Step to any of the above Continue parse until any of the buttons are pressed Stop the program (System.exit(0) called) Find text in the Parse Tree (again -- not implemented for Scan Tree yet) Character \u0026quot;ticker\u0026quot;\nShows consumed characters during scan at top of screen. VisualAge for Java Debugging Hooks\nStart VisualAge for Java debugger at current position Inspect current parser instance Known Problems Swing JTree Apparently has a limit on how many rows it will display I'm hoping this is a bug that Sun will fix, otherwise I'll need to go back to my own treeview again Sometimes doesn't properly scrollPathToVisible() -- when you pause the parse you may need to adjust the scrollbars to see the newest edition to the Parse or Scan trees \u0026quot;Finish\u0026quot; and \u0026quot;Continue\u0026quot; do pretty much the same thing - I'll probably remove the \u0026quot;Finish\u0026quot; button Planned Features Socket-proxy for debugging interface\nProvide a proxy listener that can gather parser events and send them across a socket Provide a debugger \u0026quot;server\u0026quot; that listens to a socket, creates the new debugging events and sends them to real listeners (like ParseView.) This will allow Remote debugging Debugging from non-Java parsers (ie C++) w/o JNI (they can access ParseView) Token ticker\nLike the character ticker, but with tokens Breakpoints\nRule, token match, syntax error In context -- for example, \u0026quot;break in expression in ifStatement\u0026quot; Source line number Source text Before/After manipulating an AST On a failed/succeeded predicate Scanned-text view\nDocumentation on ANTLR 2.0 debugging API\nAdd a Swing toolbar for the controller buttons\nFilter tree contents\n\u0026quot;show only x, y and z\u0026quot; -- everything else is grouped into larger \u0026quot;ignore\u0026quot; boxes in the tree that can be expanded if needed. Scanned-text \u0026quot;relief-map\u0026quot; view\nReally cool way to see how the source text is recognized by the parser/scanner\nEach rule entered adds a tier to the current \u0026quot;hill\u0026quot;; rule exit closes current tier\nSource file will be laid out as closely as possible to original input as read\nShows all text that has been scanned to current breakpoint\nEach top-level box represents a terminal in the grammar -- the text is the text read from the source file\nwhite space is skipped in the view -- might add an option to display it ToolTips or some other mechanism will display the parse rule relating to a box at any given level\nInteraction between parse tree and scanned text view\nclicking on a box in the scanned text view will select the corresponding node in the parse tree vice-versa ('cause I'm too lazy to type the rest) Initial mock up -- I'll do a better mock up another time...\nAST Support\nIn standard tree view and graphical depiction(s) Save current tree in a serialized form Comparison against a serialized tree Track accidentally lost subtrees where possible Display ASTs before and after modification Breakpoint settings will be added to help step through AST construction All built-in AST manipulations are tracked and reported Current AST states shown at all breakpoints for all ASTs available in rule AST manipulations in action code -- investigating ways of tracking these with minimal impact May add a thumbnail view with fisheye lens -- depends how daring I feel the night I code it Note: These pictures are just rough mockups to give you an idea of what I'm thinking of... Static Grammar Analysis\nfirst \u0026amp; follow sets conflict displays derivation trees prediction expressions syntax (\u0026quot;railroad\u0026quot;) diagrams for grammar (if I feel like it ;) Available as an ANTLR option, run immediately after ANTLR parsing completes Will assist conflict resolution provide examples of conflicts using grammar vocabulary show trees with conflicts Grammar Coverage Analysis\nDisplay which rules were used during the parse Keep track of cumulative usage across runs in an external file Keep track of predicate usage to help balance cost of predicates Keep track of grammar exception usage Read Java profiling report and show overall usage information Grammar method usage Non-Grammar method usage Debugging methods filtered Operating Instructions These are brief for now; I'll add more later\nBuilding a Parser for Debugging Run ANTLR as you normally would, but add \u0026quot;-debug\u0026quot; to your command line.Â For example:\njava antlr.Tool -debug java.g\nWhat you'll need to run ParseView You need the ANTLR distribution that contains ParseView You need Swing 1.0.2 Your code needs to have a System.exit(0) call at its end.Â Simply returning from main will not stop the program,Â as ParseView starts an AWT thread which must be killed... ParseView only works with programs that use both ANTLR-generated scanners and parsers.Â If you use a custom parser or scanner, ParseView probably won't work.Â I'll be writing some adapters to make this easy to do, using the debugger interface. Other than that, run your parser normally.Â A ParseView window will appear.\nThe ParseView Window The ParseView window contains the following:\nAt the top, a line containing the consumed characters.Â This will eventually also tell you lookahead characters hile moving through the scan tree The main part of the display is the Parse and Scan tree area.Â (This is in a JTabbedPane because there will be a breakpoint, scanned text,Â and AST view pane later) The Parse and Scan tree views show the entered rules and all tokens/characters matched in those rules Any rules entered while in \u0026quot;guess mode\u0026quot; via a syntactic predicate will have a yellow background Characters that are skipped in the scan are colored gray At each stop point, the status line will say which event has happened (like a token being matched or a rule being entered or exited.) While the parse is running, the status line under the scan tree will display the current line number in the source file.Â Note: This will only work properly if your scanner calls newline() anytime a newline sequence is detected.Â Newline sequences should be \u0026quot;\\n\u0026quot;, \u0026quot;\\r\u0026quot; or \u0026quot;\\r\\n\u0026quot; The column of buttons (which will eventually be a toolbar) is the controller.Â The buttons do the following: Parser Rule - continue parse until the next time a parser rule method has been entered Parser End Rule - continue parser until the current rule has been ended Token - continue parse until a token has been matched Parser Sem Pred - continue parse until a semantic predicate is evaluated Parser Guess - continue parse unti a syntactic predicate starts or finishes Finish - continue parse without watching for breakpoints.Â Currently, this does the same as the \u0026quot;Continue\u0026quot; button. Any - continue parse until any of the above things are matched Continue - continue parse until the next breakpoint or step button event occurs button Find - locate text in the parse tree -- this will pop up a dialog asking for text and whether you want to start at the top or find the next occurrence VAJ Debug - halt the parser and enter the VisualAge for Java debugger.Â This will only appear if you are running in VisualAge for Java. Inspect - bring up the VisualAge for Java variable inspector for the Parser.Â This will only appear if you are running in VisualAge for Java System.exit() -- calls System.exit(0) to stop the parser ","link":"https://javadude.com/post/19980717-parseview/","section":"post","tags":["java","antlr"],"title":"ParseView"},{"body":"Way Cool (And Antiquated) Tabbed Panel Component\nLatest News 10/17/2018\nUpdating my wesite... This is pretty obsolete, but I'm keeping it here for historical purposes and to make myself feel old... It was kind of a neat idea, allowing the user to re-arrange the UI however they would like, but a pretty weird implementation. When IDEs like Eclipse came out (not too long after this) they had very nice support for arrangeable views. The style of this component was definitely patterned after what VisualAge for Java looked like... 2/28/1998 - version 2.0.10 : This version enables the popup menu when executing under VisualAge for Java.Â The popup menu bug that was introduced in VisualAge for Java version 1.0 patchset2 has been corrected.Â This version of TabSplitter will work with VisualAge for Java in either of the following configurations:\nVisualAge for Java version 2.0 and later Note: Until I get a chance to rebuild it, you'll need to open the following classes to the BeanInfo editor and choose \u0026quot;Generate BeanInfo\u0026quot; from the \u0026quot;Features\u0026quot; menu: TabPanel TabSplitter Overview When developing ParseView, I needed a decent tabbed panel component.Â The one that came with Symantec Visual Cafe was ok, but I liked to tinker, so I wrote this one up.\nIt's evolved quite a bit over the past few months, and I came up with the cool idea of combining my SplitterLayout with it to make TabSplitter, tabbed component of the Gods!Â (No, really, my ego's more in check than it may seem...)\nSo what the hell does it do?Â It looks and acts like a nice tabbed panel, complete with OS/2-like +/- buttons and a pop-up menu for easy flipping through the contained components. The following screenshot illustrates what TabSplitter can do:\nBut it's hiding the neat feature.Â If you drag a tab on top of another tab, they are merged together into one tab with a splitter bar separating them.Â Pressing the title button at the top of each sub-panel will separate that component back into the tab panel.\nThese components are free for any use you see fit (other than selling the components as a standalone product.)\nDownloadable files tabsplitter.zip (120K).Â All source files, documentation and a jar containing all the class files. The SplitterLayout can be used on its own too!Â It's a nice way to create panels with splitter bars.Â See SplitterLayout.\nNote that the documentation is not yet complete.Â I did what I could before going insane adding doc comments.Â Next time I'll do more as I code.Â (That's what we all say, eh?)\n","link":"https://javadude.com/post/19980228-tabsplitter/","section":"post","tags":["java"],"title":"TabSplitter"},{"body":"Let's get familiar with Java Layout Managers!\n(I wrote this article for the Sun Java Developer Connection website around 1998 and is no longer available. I used the Wayback Machine to retrieve it and post it here)\nThis module will explore in great detail how the standard Abstract Window Toolkit (AWT) layout managers perform their jobs and how they can be effectively nested to create useful graphical user interfaces (GUIs).\nWhy do you need Layout Managers?\nTo describe why layout managers are necessary, all you need to do is examine a few of the problems they solve. Look at the following screen shots. These describe several_GUI sins_that are all too common:\nWindow Expanded, Components Stay Put\nThe first layout sin is to ignore a user-resize. The most common display size is probably still 640x480, so it's a good idea to make sure your application fits on that size screen. However, some users have much more screen real estate and want to take advantage of it. Non-resizable GUIs can be extremely frustrating. For example, in the initial display of a screen, the name entered is rather long, so it doesn't quite fit in the text field such that all is visible at once:\nIn the hopes of seeing the entire name at once, you could expand the dialog horizontally. Unfortunately, the programmer who wrote this application used absolute positioning and sizing, so the components in the dialog do not expand:\nAfter reporting this behavior, the developer realizes the error that has been committed and changes the GUI to resize properly:\nBefore resizing\nAfter resizing\nComponents Designed for a Specific Look-And-Feel or Font Size\nAnother common problem is expecting all platforms or LookAndFeel libraries (when using Java Foundation Classes (JFC) Project Swing technology) to have the same sizing characteristics. The following picture shows the above GUI under theMotifLookAndFeelof the JFC Project Swing technology without using a layout manager:\nNotice that theMotifLookAndFeeluses a wider, empty border around the buttons, causing some undesirable drawing effects. Switching font sizes will have a similar effect.\nComponents Designed for a Specific Language\nSome words take up the same amount of space in different languages. \u0026quot;No\u0026quot; is a good example, as it's spelled that way in several languages.\nHowever, most words have varying lengths depending on which language you are using. For example:\nA simple button to end an application. The programmer didn't give much thought to translations into other languages...\n...such as German. Auf Wiedersehen gets chopped to the much smaller Wieder.\nThis is unfortunate for two reasons:\nThe user doesn't see the entire phrase, but even worse... ...\u0026quot;wieder\u0026quot; means again. (I had a student from Germany who started laughing when I showed that button and told me what it meant...) What are Layout Managers?\nA layout manager encapsulates an algorithm for positioning and sizing of GUI components. Rather than building the layout algorithms into your code and watching for window resizing and other layout-modifying events, the algorithm is kept separate. This allows a layout algorithm to be reused for several applications, while simplifying your application code.\nLayoutManager is an interface in the Java class libraries that describes how a Container and a layout manager communicate. It describes several methods which:\nAsk for sizing information for the layout manager and the components it manages. Tell the layout manager when components are added and removed from the container. Size and position the components it manages. An additional interface, LayoutManager2, was added in JDK 1.1, which adds a few more positioning and validation methods.\nComponent Size Methods\nThe Component class defines several size accessor methods to assist the layout process. Each of these methods returns a Dimension object describing the requested size. These methods are as follows:\npublic Dimension getPreferredSize()\nThis returns the desired size for a component.\npublic Dimension getMinimumSize()\nThis returns the smallest desired size for a component.\npublic Dimension getMaximumSize()\nThis returns the largest desired size for a component.\nLayout managers will use these sizing methods when they are figuring out where to place components and what size they should be. Layout managers can respect or ignore as much or as little of this information as they see fit. Each layout manager has its own algorithm and may or may not use this information when deciding component placement. Which of these methods is respected or ignored is very important information and should be documented carefully when creating your own layout manager.\nControlling the sizes returned for your own components can be accomplished in two ways, depending on whether you are using the JFC Project Swing components.\nIf your component is a JFC Project Swing component, you inherit three methods,setPreferredSize(Dimension), setMinimumSize(Dimension) and setMaximumSize(Dimension). You can call these methods directly to explicitly set the size information for a component. For example:\n1JButton okButton = new JButton(\u0026#34;Ok\u0026#34;); 2okButton.setPreferredSize(new Dimension(100,10)); You should only adjust the sizes if you're really sure what you're doing. (The above example is probably_not_a good idea...)\nIf your component is not a JFC Project Swing component, you will need to subclass it to adjust the sizes. For example:\n1public class MyButton extends Button { 2 public Dimension getPreferredSize() { 3 return new Dimension(100,10); 4 } 5} Layout Managers and Containers\nA layout manager must be associated with a Container object to perform its work. If a container does not have an associated layout manager, the container simply places components wherever specified by using the setBounds(), setLocation() and/orsetSize() methods.\nIf a container has an associated layout manager, the container asks that layout manager to position and size its components before they are painted. The layout manager itself_does not_perform the painting; it simply decides what size and position each component should occupy and calls setBounds(), setLocation()and/orsetSize() on each of those components.\nA LayoutManager is associated with a Container by calling the setLayout(LayoutManager) method of Container. For example:\n1Panel p = new Panel(); 2p.setLayout(new BorderLayout()); Some containers, such as Panel, provide a constructor that takes a layout manager as an argument as well:\n1Panel p = new Panel(new BorderLayout()); The add(...) Methods\nContainers have several methods that can be used to add components to them. They are:\n1public Component add(Component comp) 2public Component add(String name, Component comp) 3public Component add(Component comp, int index) 4public void add(Component comp, Object constraints) 5public void add(Component comp, Object constraints, int index) Each of these methods adds a component to the container and passes information to the layout manager of the container. All of the methods take aComponentparameter, specifying which component to add. Some take an index. This is used to specify an order in the container; some layout managers (such asCardLayout) respect the ordering of added components.\nThe other parameters, name and constraints are information that can be used by a layout manager to help direct the layout. For example, when adding a component to a container that is managed by a BorderLayout, you specify a compass position as a constraint.\nEach of the aboveadd()methods delegates its work to a singleaddImpl()method:\n1protected void addImpl(Component comp, Object constraints, int index) Note: addImpl stands for \u0026quot;implementation of the add method.\u0026quot;\nThis method is the one that does all the work. It adds the Component to the Container, and, if a layout manager is managing the container layout, calls the addLayoutComponent() method of the layout manager. It is through addLayoutComponent() that the layout manager receives the constraints (from the add() call).\nIf you create a subclass of Container and want to override an add() method, you only need to override addImpl(). All other add() methods route through it.\nContainer Insets\nIn addition to a layout manager, each Container has a getInsets() method that returns an Insets object. The Insets object has four public fields: top, bottom, left and right.\nThese insets define the area a container is reserving for its own use (such as drawing a decorative border). Layout managers_must_respect this area when positioning and sizing the contained components.\nTo demonstrate, create a simple Panel subclass that provides a raised, 3D border around whatever is contained within it. You'll define this border as being 5 pixels away from each edge of the container border, and reserving some extra room between it and the laid out components. The class will look something like this:\n1public class BorderPanel extends Panel { 2 private static final Insets insets = new Insets(10,10,10,10); 3 public Insets getInsets() {return insets;} 4 public void paint(Graphics g) { 5 Dimension size = getSize(); 6 g.setColor(getBackground()); 7 g.draw3DRect(5,5,size.width-11, size.height-11, true); 8 } 9} To create the panel, you defined a static Insets object that represents the space to reserve. Because that space won't change, you used a single static final instance of it. You'll return this instance anytime a layout manager (or anyone else) calls getInsets().\nYou then define a paint() method that gets the size of the container into which it is painting, then draws a raised border within that space. If you use the above class as follows:\n1Frame f = new Frame(\u0026#34;Test\u0026#34;); 2f.setLayout(new GridLayout(1,0)); 3f.setBackground(Color.lightGray); 4BorderPanel p = new BorderPanel(); 5p.setLayout(new GridLayout(1,0)); 6p.add(new Button(\u0026#34;Hello\u0026#34;)); 7f.add(p); 8f.setVisible(true); 9f.pack(); you'll get the following GUI:\nIf you are not familiar with GridLayout, it will be discussedlater.\nYou can get another interesting effect by adding the following to the paint() method:\n1g.draw3DRect(6,6,size.width-13,size.height-13,false); after the first draw3DRect():\nor if you swap the true / false on the two drawRect() calls:\nIf you are using the JFC Project Swing components, you will want to explore the various Border classes provided to generate these types of effects, instead of using Insets.\nThe Standard AWT Layout Managers\nThe AWT library includes five layout managers. These can be used in various combinations to create just about any GUI you may possibly want to write. The standard AWT layout managers are:\nFlowLayout BorderLayout GridLayout CardLayout GridBagLayout Each of these will now be discussed in detail, including strategies and pitfalls when using them. By themselves, these layout managers may not seem terribly useful. However, when combined they become incredibly flexible.FlowLayout\nThis is the simplest of the AWT layout managers. Its layout strategy is:\nrespect the preferred size of all contained components lay out as many components as will fit horizontally within a container start a new row of components if more components exist if all components can't fit, too bad! To add components to a container managed by FlowLayout, you could use one of the following add() methods:\n1public Component add(Component comp) 2public Component add(Component comp, int index) You do not specify any constraints for the components, as FlowLayout only depends on the order of the add() calls (or the index specified in the call to add(Component, int).)\nExamine a simple FlowLayout in action. Suppose you had the following class definition:\n1public class FlowTest { 2 public static void main(String[] args) { 3 Frame f = new Frame(\u0026#34;FlowTest\u0026#34;); 4 f.setLayout(new FlowLayout()); 5 f.add(new Button(\u0026#34;A\u0026#34;)); 6 f.add(new Button(\u0026#34;B\u0026#34;)); 7 f.add(new Button(\u0026#34;C\u0026#34;)); 8 f.add(new Button(\u0026#34;D\u0026#34;)); 9 f.add(new Button(\u0026#34;E\u0026#34;)); 10 f.setVisible(true); 11 } 12} This class creates a Frame and adds five buttons to it. It lays the buttons out as many can fit per row, then moves to the next row to display more of them. The following pictures show the frame being expanded horizontally:\nInitial Size\nSome horizontal expansion\nMore horizontal expansion\nNotice how the layout is fitting as many components per line as possible. If there isn't room for all the components, they are simply not shown:\nFlowLayoutVariations\nFlowLayout can be customized at construction time by passing the constructor an alignment setting:\nFlowLayout.CENTER(the default) FlowLayout.RIGHT FlowLayout.LEFT These settings adjust how the components in a given row are positioned. By default, all components in a row will be separated by an horizontal gap, then the whole chunk will be centered in the available width. LEFT and RIGHT define padding such that the row is left or right aligned. The alignment can also be changed by calling the setAlignment() method of FlowLayout with one of the same alignment constants.\nFlowLayout can also be customized with different horizontal and vertical gap settings. These specify how much space is left between components, horizontally (hgap) and vertically (vgap)\nPreferred Size of aFlowLayoutContainer\nRecall that when a Container is asked for its preferred size, it bases that preferred size on its layout manager. This raises the subject of what FlowLayoutwould prefer to do with its components.\nUnfortunately, there is no way for a container to know anything about the size of its parent or how its parent's layout manager plans to lay it out. So, the only information available to determine the preferred size of a container is the set of components contained within it.\nFlowLayout's preference would be to lay all its components out into a single row. This means that its preferred height would be the maximum height of any of its components plus some \u0026quot;slop\u0026quot; known as itsvgap. (vgap and hgapare common properties of most of the standard layout managers, and specify how far apart components are placed.) The preferred width would be the sum of all widths of its contained components, plus an hgap between each and on either end of the row.\nThink about the consequences of this. What would happen if a FlowLayout-managed container was nested within another FlowLayout-managed container? For example:\n1Panel p1 = new Panel(new FlowLayout()); 2Panel p2 = new Panel(new FlowLayout()); 3p2.add(new Button(\u0026#34;A\u0026#34;)); 4p2.add(new Button(\u0026#34;B\u0026#34;)); 5p2.add(new Button(\u0026#34;C\u0026#34;)); 6p2.add(new Button(\u0026#34;D\u0026#34;)); 7p2.add(new Button(\u0026#34;E\u0026#34;)); 8p1.add(p2); Think this through a bit and the answer is very disconcerting. The following walks you through the layout process:\np1's parent container tells it to lay itself out. p1 sees that it has a layout manager and delegates thelayout task to it. p1's FlowLayout checks the preferred sizes of all its components: The only component in p1 is p2 p2 sees it has a layout manager and delegates the preferred size request to the layout manager: p2's FlowLayout states that it would prefer to lay out all of its components in a single row. p2's FlowLayout asks its components (the buttons) for their preferred sizes and calculates the size of that single, preferred row. p2's FlowLayout returns that preferred size. p2 returns the preferred size. p1's FlowLayout tries to respect the preferred size of p2 as much as possible. If there's enough room for the single row, it sets the bounds of p2 to its preferred size. If there's not enough horizontal room, it sets p2's bounds to the single-line height and as much width as is available. If there's not enough horizontal or vertical room, it sets the bounds of p2 to whatever it has. So what does this tell us? If a FlowLayout-managed container is placed within another container whose layout manager respects its preferred height, the nestedFlowLayout-managed container will always have a single row.\nBefore Resizing\nAfter Resizing\nFlowLayoutStrategies and Potential Pitfalls\nKeep the following in mind when using aFlowLayout:\nNever nest aFlowLayout-managed container within a container whose layout manager respects preferred height. Caveat: If you only have a few components, this is not as important to avoid. The FlowLayout manager effectively hides components if they won't fit. There is no visual indication of this to the userâ€”as far as the user is concerned, the unshown components never even existed. Because of the previous point, FlowLayout is really only useful when you have a small number of components. FlowLayout is_horizontally_biased. If you want a_vertical_flow layout, you must write your own. (Or use theBoxLayoutmanager which comes with the JFC Project Swing component set.TheBoxLayoutmanager is discussed in theFundamentals of Swing: Part Itutorial.) BorderLayout\nBorderLayout is probably the most useful of the standard layout managers. It defines a layout scheme that maps its container into five logical sections:\nThe first thing going through your mind should be \u0026quot;but I will_never_have a GUI that looks like that!\u0026quot; Moreover, you are probably correct. However, the secret is in mastering its nesting capabilities, and using two or three of the logical sections. (It's very rare that you'll actually use more than three of the positions in a container at once.)\nFirst, look at the sample code for the above GUI:\n1Frame f = new Frame(\u0026#34;orderTest\u0026#34;); 2f.setLayout(new BorderLayout()); 3f.add(new Button(\u0026#34;North\u0026#34;), BorderLayout.NORTH); 4f.add(new Button(\u0026#34;South\u0026#34;), BorderLayout.SOUTH); 5f.add(new Button(\u0026#34;East\u0026#34;), BorderLayout.EAST); 6f.add(new Button(\u0026#34;West\u0026#34;), BorderLayout.WEST); 7f.add(new Button(\u0026#34;Center\u0026#34;), BorderLayout.CENTER); The BorderLayout manager requires a constraint when adding a component. The constraint can be one of the following:\nBorderLayout.NORTH BorderLayout.SOUTH BorderLayout.EAST BorderLayout.WEST BorderLayout.CENTER These constraints are specified within the following twoadd()methods:\npublic void add(String constraint, Component component)\nThis is the \u0026quot;old\u0026quot; form of adding a constraint. JDK 1.0.2 only provided for constraints that were represented by aStringto be added when adding aComponentto aContainer\npublic void add(Component component, Object constraint)\nThis is the \u0026quot;new\u0026quot; form of adding a constraint, added in JDK 1.1.\nYou'll see a few more variations of theadd()method when you examineCardLayoutlater. Concentrate on just these forms for now.\nForBorderLayout, the constraint argument describes which position the component will occupy. Note that the earlierBorderLayoutexample source code could have been written as follows:\n1Frame f = new Frame(\u0026#34;BorderTest\u0026#34;); 2f.setLayout(new BorderLayout()); 3f.add(\u0026#34;North\u0026#34;, new Button(\u0026#34;North\u0026#34;)); 4f.add(\u0026#34;South\u0026#34;, new Button(\u0026#34;South\u0026#34;)); 5f.add(\u0026#34;East\u0026#34;, new Button(\u0026#34;East\u0026#34;)); 6f.add(\u0026#34;West\u0026#34;, new Button(\u0026#34;West\u0026#34;)); 7f.add(\u0026#34;Center\u0026#34;, new Button(\u0026#34;Center\u0026#34;)); The big difference is that the newer form (using theBorderLayout.NORTHtype constraints) can be compile-time checked; if you typeBorderLayout.NORFHthe compiler will catch it. If you just type \u0026quot;Norfh\u0026quot;, it will not be caught until runtime, causing anIllegalArgumentExceptionto be thrown.\nThe Java 2 platform (previously known as the JDK 1.2) adds additional constants ofBEFORE_FIRST_LINE,AFTER_LAST_LINE,BEFORE_LINE_BEGINS, andAFTER_LINE_ENDS. These are effectively equivalent toNORTH,SOUTH,WEST, andEAST, respectively. However, they could have other orientations where text is not oriented left-to-right, top-to-bottom. Examine thejava.awt.ComponentOrientationclass for additional information on language-sensitive orientation issues.\nHow IsBorderLayoutLaid Out?\nBorderLayoutrespects_some_of the preferred sizes of its contained components,but not all. Its layout strategy is:\nIf there is aNORTHcomponent, get its preferred size.\nRespect its preferred_height_if possible, and set its width to the full available width of the container.\nIf there is aSOUTHcomponent, get its preferred size.\nRespect its preferred_height_if possible, and set its width to the full available width of the container.\nIf there is anEASTcomponent, get its preferred size.\nRespect its preferred_width_if possible, and set its height to the_remaining_height of the container.\nIf there is anWESTcomponent, get its preferred size.\nRespect its preferred_width_if possible, and set its height to the_remaining_height of the container.\nIf there is aCENTERcomponent, give it whatever space remains, if any.\nNow consider nesting aFlowLayout-managed container inside aBorderLayout-managed container. First, what would happen if you added theFlowLayout-managed container as theNORTHorSOUTHcomponent of theBorderLayout?\n1Panel flow = new Panel(new FlowLayout()); 2Panel border = new Panel(new BorderLayout()); 3flow.add(new Button(\u0026#34;A\u0026#34;)); 4flow.add(new Button(\u0026#34;B\u0026#34;)); 5flow.add(new Button(\u0026#34;C\u0026#34;)); 6flow.add(new Button(\u0026#34;D\u0026#34;)); 7flow.add(new Button(\u0026#34;E\u0026#34;)); 8border.add(flow, BorderLayout.NORTH); Remember what happens when aFlowLayout-managed container is added to a layout that respects preferred height?TheFlowLayoutcontainer will only ever have a single row! It will never flow its components to more than that one row.\nThat was the easy one (now that you know the secret). Now, what if you add theFlowLayout-managed container as theWESTorEASTcomponent? To demonstrate, place the container in theEASTsection:\nThis initial display looks pretty much as you would expect. Each component is taking up its preferred size.\nNext, reduce the width and increase the height. TheFlowLayoutcontainer is still insisting on a single row for its preferred_width_(as you should expect) and is eating up room that theCENTERcomponent would have liked to use. This result can be very unexpected, as you might think theFlowLayoutcontainer should expand to fill theEASTarea and give some room back to theCENTERcomponent:\nRemember: aBorderLayoutcontainer asks for the preferred size of each section and respects it as much as possible.\nTo demonstrate this even further, reduce the width until only theEASTcomponent is still visible:\nFinally, if you compress it more, theFlowLayout-managed container is clipped to the available space:\nSo, the only place that you should really put aFlowLayoutmanaged container within aBorderLayout-managed container is theCENTERsection (unless you only have very few components in theFlowLayout).\nNow consider some nice generalizations aboutBorderLayout:\nNORTH andSOUTHpositions in aBorderLayoutcan be useful if you want to_bind_the height of part of a GUI to that part's preferred height. EAST andWESTpositions in aBorderLayoutcan be useful if you want to_bind_the width of part of a GUI to that part's preferred width. Once part of the GUI is bound, theCENTERis the expanding part. These are very important properties ofBorderLayout, and make it very powerful when used to create a more complex, nested GUI.\nTake a very simple example. Suppose you wanted to create a simple labeled text field. You want this new component to exhibit the following properties:\nThe label takes up exactly as much horizontal room as needed The label is to the left of the text field The text field expands horizontally You could start with the following code:\n1Panel p = new Panel(new BorderLayout()); 2Label nameLabel = new Label(\u0026#34;Name:\u0026#34;); 3TextField entry = new TextField(); 4p.add(nameLabel, BorderLayout.WEST); 5p.add(entry, BorderLayout.CENTER); Here you are binding the width of the label to its preferred width. It will take up that much space and not expand. The entry field is not bound and can expand. So, you achieve the desired result:\nInitial size\nAfter horizontal stretch\nAt least it_seems_you achieved the desired result. Look what happens when you expand vertically:\nTheTextFieldis stretched. So, you need to bind the height of the two components to their preferred height. This can be accomplished by placing theLabel/TextFieldcombination inside_another_BorderLayout-managed container, as theNORTHorSOUTHcomponent. Assuming that you want the fields to stay at the top of the GUI, you can place it to theNORTH:\n1Panel p = new Panel(new BorderLayout()); 2Label nameLabel = new Label(\u0026#34;Name:\u0026#34;); 3TextField entry = new TextField(); 4p.add(nameLabel, BorderLayout.WEST); 5p.add(entry, BorderLayout.CENTER); 6Panel p2 = new Panel(new BorderLayout()); 7p2.add(p, BorderLayout.NORTH); Now, when you expand vertically, you get the following effect:\nBorderLayoutVariations\nBorderLayoutcan be customized with hgap and vgap values at construction time. These values specify how much space is left between components, horizontally (hgap) and vertically (vgap).\nPreferred Size of aBorderLayoutContainer\nIf aBorderLayout-controlled Container is asked for its preferred size, what will it return? The idea behind its preferred size is to make sure all contained components are given their preferred sizes. First, look at the preferred width:\nLooking at the above picture, there are three rows of components:\nNORTH WEST,CENTERandEAST(plus hgaps as needed) SOUTH The preferred width of the layout needs to take into account the widest of these rows. Using pw as the abbreviation for \u0026quot;preferred width\u0026quot;, you can write a simple equation for the preferred width of aBorderLayout:\n1pw = max(north.pw, south.pw, 2 (west.pw + center.pw + east.pw + hgaps)) The_hgaps_amount to include depends on which components are present in the center row.\nThe preferred height (ph in the following equation) depends on the sizes of theNORTHandSOUTHcomponents plus the_tallest_of the middle-row components:\n1ph = vgaps + north.ph + south.ph + 2 max(west.ph, center.ph, east.ph) The vgaps amount depends on which rows are present in the BorderLayout.\nA useful application of this preferred-size knowledge is creating two or three rows of components that each keep their preferred size. Suppose you had aLabel, aTextArea, and aTextFieldthat you wanted to lay out like this:\nAnd when you expand it vertically, you_do not_want the components to stretch vertically:\nFirst, recall that you can_bind_the height of a component to its preferred height by placing it in theNORTHorSOUTHpart of aBorderLayout. If that bound component happens to be anotherBorderLayout, (withNORTH,CENTER, andSOUTHcomponents) each component within that layout would get its preferred height. This results in the above figure, with code to produce it:\n1Frame f = new Frame(\u0026#34;BorderTest\u0026#34;); 2Panel p = new Panel(new BorderLayout()); 3f.setLayout(new BorderLayout()); 4p.add(new Label(\u0026#34;Hello\u0026#34;, Label.CENTER), 5 BorderLayout.NORTH); 6p.add(new TextArea(), BorderLayout.CENTER); 7p.add(new TextField(), BorderLayout.SOUTH); 8f.add(p, BorderLayout.NORTH); An effective combination of aFlowLayoutand aBorderLayoutis for the common \u0026quot;Ok\u0026quot; and \u0026quot;Cancel\u0026quot; buttons on a dialog. For example:\nThe above is accomplished with the following code:\n1Frame f = new Frame(\u0026#34;BorderTest\u0026#34;); 2Panel p = new Panel(new FlowLayout(FlowLayout.RIGHT)); 3f.setLayout(new BorderLayout()); 4p.add(new Button(\u0026#34;Ok\u0026#34;)); 5p.add(new Button(\u0026#34;Cancel\u0026#34;)); 6f.add(p, BorderLayout.SOUTH); There is one problem with this approach: the widths of the two buttons are different. You'll see a better way to create this type of GUI in a moment.\nGridLayout\nGridLayoutlays out its components in a grid. Each component is given the same size and is positioned left-to-right, top-to-bottom.\nThe code that produced the above GUI looks like:\n1Frame f = new Frame(\u0026#34;Grid Test\u0026#34;); 2f.setLayout(new GridLayout(3,4)); 3for (int x = 1; x \u0026lt; 13; x++) 4 f.add(new Button(\u0026#34;\u0026#34;\u0026#34;+x)); When specifying aGridLayout, there are two main parameters:rows_and_columns. You can specify both of these parameters, but only one will ever be used. Take a look at the following code snippet fromGridLayout.java:\n1if (nrows \u0026gt; 0) { 2 ncols = (ncomponents + nrows - 1) / nrows; 3else 4 nrows = (ncomponents + ncols - 1) / ncols; Notice that if_rows_is non-zero, it_calculates_the number of columns; if_rows_is zero, it calculates the number of rows based on the specified number of columns.\nTo the casual observer, a statement like\n1f.setLayout(new GridLayout(3,4)); looks like it will_always_divide the screen into twelve sections, but that's not the case. In the above statement, you could substitute_any_value for the number of columns, and the effect would be exactly the same.\nA better way to specify the_rows_and_columns_of aGridLayoutis to_always_set one of them to zero. A zero value for_rows_of_columns_means \u0026quot;any number of\u0026quot;.\nNote: A word of caution: you cannot specify zero for_both_; anIllegalArgumentExceptionwill be thrown.\nSpecifying zero for one value makes the_design intent_obvious. If you always_want_four rows, say so; if you always_want_three columns, say so. The above example_should_be written as either\n1f.setLayout(new GridLayout(3,0)); or\n1f.setLayout(new GridLayout(0,4)); Preferred Size of aGridLayoutContainer\nHow do you determine the preferred size of aGridLayout?GridLayoutwants to accommodate the preferred size of_all_its contained components if possible. To do this, it looks at all the preferred sizes and determines the maximum preferred width and the maximum preferred height.One thing to keep in mind, the maximum preferred height and maximum preferred width_do not_necessarily come from the same component!\nTheGridLayoutwould like to set the size of_each_component to that maximum preferred width and maximum preferred height. (Rememberâ€”all components in aGridLayoutwill be the same size!) This makes the preferred size of aGridLayout\n1pw = (maxPrefWidth \\* cols) + (hgap \\* (cols+1)) 2ph = (maxPrefHeight \\* rows) + (vgap \\* (rows+1)) \u0026quot;Ok\u0026quot; and \u0026quot;Cancel\u0026quot; Revisited\nOne of the goals of the earlier \u0026quot;Ok\u0026quot; and \u0026quot;Cancel\u0026quot; dialog was to make the buttons the same size. This can be accomplished by putting the buttons in a single-rowGridLayout. You can then add thatGridLayoutcontainer to theFlowLayout, or use a nestedBorderLayoutin place of theFlowLayout. Here are both approaches:\n1Frame f = new Frame(\u0026#34;Ok/Cancel\u0026#34;); 2f.setLayout(new BorderLayout()); 3Panel p = new Panel(); 4p.setLayout(new FlowLayout(FlowLayout.RIGHT)); 5Panel p2 = new Panel() 6p2.setLayout(new GridLayout(1,0,5,5)); 7p2.add(new Button(\u0026#34;Ok\u0026#34;)); 8p2.add(new Button(\u0026#34;Cancel\u0026#34;)); 9p.add(p2, BorderLayout.EAST); 10f.add(p, BorderLayout.SOUTH); 1Frame f = new Frame(\u0026#34;Ok/Cancel\u0026#34;); 2f.setLayout(new BorderLayout()); 3Panel p = new Panel(); 4p.setLayout(new BorderLayout()); 5Panel p2 = new Panel() 6p2.setLayout(new GridLayout(1,0,5,5)); 7p2.add(new Button(\u0026#34;Ok\u0026#34;)); 8p2.add(new Button(\u0026#34;Cancel\u0026#34;)); 9p.add(p2, BorderLayout.EAST); 10f.add(p, BorderLayout.SOUTH); Notice the difference in appearance. TheFlowLayoutpads_around_the components with the hgap and vgap, whileBorderLayoutonly pads_between_components (so the components butt right against the edges of the container.)\nIn both cases, the buttons now appear the same size. The nesting for this layout can be more easily seen in the following picture:\nAnd similarly for the second version of the layout, using the nestedBorderLayout.\nCardLayout\nCardLayoutuses a different strategy than the other layout managers. Instead of assigning locations in the container for all nested components, it only displays one component at a time. Components can be added to aCardLayoutusing the followingaddmethods:\n1public void add(Component component, String key); 2public void add(String key, Component component); 3public void add(String key, Component component, int index); The first two forms of theadd()method will add the component at the end of the list of components for the container. The last form of theadd()method will add the component at the specified position in the container. The position of the component within the container determines the order in which the components will be displayed via the manipulation methods ofCardLayout.\nA uniqueStringkey must be assigned for each component that is added to the container. For example:\n1Panel p = new Panel(new CardLayout()); 2p.add(\u0026#34;one\u0026#34;, new Button (\u0026#34;the first component\u0026#34;)); 3p.add(new Button (\u0026#34;the second component\u0026#34;), \u0026#34;two\u0026#34;); 4p.add(\u0026#34;three\u0026#34;, new Button (\u0026#34;the third component\u0026#34;)); 5p.add(\u0026#34;between two and three\u0026#34;, new Button (\u0026#34;the fourth component\u0026#34;), 2); When components are added to container that is controlled by aCardLayout, aStringkey is associated with each component. Different components can be displayed by using thenext(),previous, andshowmethods ofCardLayout. The order in which components are added to the container determines their display order when using thenext()andpreviousmethods. For example:\n1CardLayout l = (CardLayout)p.getLayout(); 2l.previous(p); 3l.next(p); 4l.show(p, \u0026#34;two\u0026#34;); Notice that theprevious(),next(), andshow()methods require a reference to the container be passed into them has an argument. Layout managers do not keep a reference to the container that uses them. When performing actions such as callingprevious(),next(), andshow(), and, as you will see later, the laying out of the actual components, the layout manager needs to be informed of the container on which it is operating so it can have access to the components it is laying out.\nCardLayoutis commonly used in GUIs that want to organize their data into several smaller screens, rather than having all components on one larger screen. This is typically used in combination with several buttons for switching components within theCardLayout, or a tabbed panel component.\nPreferred Size of aCardLayoutContainer\nSo how do you determine the preferred size of aCardLayout? Keeping in mind that the preferred size wants to take into account the preferred size of all contained components in the container, the preferred size of theCardLayoutwill be the maximum preferred width of all contained components and the maximum preferred height of all contained components\nGridBagLayout\nGridBagLayouttends to be one of the most difficult layout managers to understand. There are several reasons for this widely held opinion:\nIt is very complex and can be difficult to learn. If_you_learn it and use it in your GUI, the poor maintenance programmer will have to learn it just as well as you did. There are a few bugs inGridBagLayoutthat evidence themselves after components are added to or removed from theGridBagLayoutafter theGridBagLayouthas been displayed\nNote:GridBagLayoutmaintains some internal state that sometimes gets confused when components are added and removed. Covering all of the details of usingGridBagLayoutcould span an entire book. It will be covered briefly in the context of an example in a latersection.\nWithout a GUI builder like VisualAge for Java or JBuilder, you should avoidGridBagLayoutif at all possible. For most GUIs, you can achieve the same results by nesting the other, simpler layout managers.\nSetting the Initial Frame Size\nTheFrameclass provides apack()method that helps set an \u0026quot;ideal\u0026quot; initial size. Thepack()method calls thegetPreferredSize()method ofFrameto determine what size it would like to be laid out, and, if the screen is large enough to allow it, sets the Frame to that size. If there isn't enough screen space, the Frame will be limited to the available screen space.\nNesting Layout Managers to Achieve Nirvana\nThe following sections describe a real-life user interface and how it might be created with the help of Java layout managers.\nThe GUI to Create\nA great example of nesting the standard layout managers is WS_FTP, a Windows program for graphical FTP support.\nThis GUI, while it may seem nice for \u0026quot;power users\u0026quot; is overly complex. The buttons at the bottom should really be menu items and the buttons to the right of each file list should be popup menus on the file lists. Nevertheless, the GUI as it stands makes a great example for nesting the basic layout managers.\nHow to Design this GUI\nBefore writing_any_GUI code, you should_always_do two things:\n**Draw a picture!**You would be surprised how many people try to visualize the GUI in their head. Drawing a picture makes the design significantly easier to develop. **Describe the resize behavior.**After drawing the picture, add information about which parts of the GUI will expand/collapse when the window is resized. In the above example, ignore the border lines around components. These can be added after the GUI is constructed, either by applying the Decorator Pattern or, if using JFC Project Swing containers, by callingsetBorder().\nStart with a picture describing what you want the GUI to look like. Simplify things a bit by removing the decorative borders and assume the existence of a \u0026quot;File List\u0026quot; component (probably a table with a header).\nThe arrows indicate which parts of the GUI will expand/collapse when the GUI is resized.\nThe above diagram is marked with the resize behavior of the GUI. The key explains which lines refer to fixed and varying sizing behaviors. When part of a component has a fixed size (horizontal, vertical, or both) it will not expand or contract as the window is resized. The equal signs (=) refer to adjoining components that have the same size.\nA few notes on the GUI's behavior:\nThe two large sections that contain the File Lists should occupy the same amount of space. The two arrow buttons in the middle should be vertically centered between the file list sections. The ChgDir, MkDir, and other buttons all are the same size and are fixed at the group's preferred width and do not expand vertically. (The space below them expands when the window is stretched vertically.) The buttons at the bottom of the GUI are all the same size and will expand/collapse horizontally with the GUI's width. The ASCII, Binary and Auto checkboxes stay a fixed amount apart, floating as a group horizontally centered. Now, the fun begins. You need to examine the GUI and try to visualize layout managers being used to represent sections of it. When trying to design the GUI, work from the outside edges inward. Always start by looking for \u0026quot;borders\u0026quot;; a component, or group of components that border an edge with a fixed width or height.\nLooking at the above GUI, you can visualize it as aBorderLayoutwith two components: aSOUTH, and aCENTER:\nTheSOUTHpart of theBorderLayouthas a fixed height, based on the preferred size of its components. TheCENTERpart will expand to fill the remaining room in the GUI. Examining theSOUTHsection closer, you can view it as three parts:\nNote that there are three components here, stacked vertically, each with their preferred height. You might be tempted to stick this in aGridLayout, but that would force them all to take up the same amount of space vertically. That's not what you want.\nSuppose you put these three components asNORTH,CENTER, andSOUTHof aBorderLayout. This newBorderLayoutpanel is nested as theSOUTHcomponent of the overallBorderLayout. Think through what happens when this part of the GUI is laid out:\nThe overallBorderLayoutasks itsSOUTHcomponent for its preferred size TheSOUTHcomponent, being aBorderLayoutitself, asks_its_components for their preferred sizes The nestedBorderLayoutreturns a size that is Width = max preferred width of those three components. Height = sum of the preferred heights of those three components. The overallBorderLayout_assigns_the size of itsSOUTHcomponent to the frame's width, and the preferred height of thatSOUTHcomponent. TheCENTERcomponent gets all remaining room. TheSOUTHcomponent now gets its chance to lay out its contained components. TheSOUTHcomponent asks for the preferred sizes of its children. TheSOUTHcomponent assigns the width of all components to the width it has been given. It grants_its_NORTHcomponent its preferred height. It grants_its_SOUTHcomponent its preferred height. It grants_its_CENTERcomponent the remaining space. Note that last bullet. TheCENTERgets the remaining space. Because the overallBorderLayouthad granted theSOUTHcomponent its preferred height, and the preferred height was equal to the sum of the preferred heights of the contained components, that nestedCENTERcomponent (the messageTextArea) just happens to get its preferred height.\nFirst, define theNORTHpart of this sub-GUI. It has three components, equally spaced, with all of them centered across the width of thePanel. Sounds like aFlowLayout, eh? So, it is aPanelwith aFlowLayoutcontaining threeCheckBoxcomponents. Notice that the first twoCheckBoxcomponents must be associated with aCheckboxGroupso they will become radio buttons.\nNow you must create theSOUTHpart of this sub-GUI. It has sevenButtoncomponents, all equally sized. The phrase \u0026quot;equally-sized\u0026quot; should immediately triggerGridLayoutin your mind. So, theSOUTHpart of the sub-GUI is aPanelwith aGridLayoutcontaining sevenButtoncomponent. ThisGridLayoutconsists of a single row, so use parameters of (1,0) to its constructor.\nTheCENTERpart is just a single component, aTextArea. You do not need to nest this inside anotherPanel; components can be directly added to containers... You'll set thisTextArea's number of rows to 3 and columns to 30. These numbers drive the_preferred size_of theTextArea; they have no effect on theTextAreaonce it has been sized by the layout manager. You must specify these because its placement in the layout asks for its preferred size, and it would return a larger number of rows than three if asked. The 30 will only come in handy if youpack()theFrame, where it will help contribute to the calculated width of the frame. One final note on thisTextArea: if you place it in aBorderPanelas previously discussed in theInsetssection above, you can give it a raised, lowered, or etched border.\nTo sum up what the layout looks like so far:\nFtpextends Frame, layout=BorderLayout SOUTH=Panel, layout=BorderLayout NORTH=Panel, layout=FlowLayout Checkbox(\u0026quot;ASCII\u0026quot;) w/CheckboxGroup Checkbox(\u0026quot;Binary\u0026quot;), w/CheckboxGroup Checkbox(\u0026quot;Auto\u0026quot;) CENTER=TextArea(3,30) SOUTH=Panel, layout=GridLayout(1,0) Button(\u0026quot;Close\u0026quot;) Button(\u0026quot;Cancel\u0026quot;) Button(\u0026quot;LogWnd\u0026quot;) Button(\u0026quot;Help\u0026quot;) Button(\u0026quot;Options\u0026quot;) Button(\u0026quot;About\u0026quot;) Button(\u0026quot;Exit\u0026quot;) CENTER=? (that's next...) Now you need to address theCENTERpart of that overallBorderLayout. First, take a look at the following picture of the center section:\nNotice anything interesting? It has to do with those two boxes drawn around the left and right side components. They are structurally the same.Exactly_the same. When two things are the same, and it's a chore to build it each time, you should think_reuse.\nA Helper Class:FileDisplay\nExtract out one of those chunks and look at it separately. Put it in its own class calledFileDisplay. Start examining this sub-GUI by looking for bordering components. You can immediately see three:\nTheNORTHpart consists of aLabeland combo box (you'll use an AWTChoicecomponent for now), vertically stacked. TheCENTERis aListcomponent. TheEASTis a bunch ofButtons vertically stacked.\nLooking first at theNORTHpart, you need to have theLabelandChoicetake up their preferred height and the full width. Since this is theNORTHcomponent, whatever they are contained in will receive its preferred height. By placing theLabelandChoiceasNORTHandSOUTH(orNORTHandCENTER, orCENTERandSOUTH) of aBorderLayout, they will receive their preferred height. Again, aGridLayoutwould be a bad choice because that assumes that both components want the same height. You could change the font size on theLabelto make it larger, and you wouldn't want that to affect the size of theChoice.\nTheCENTERpart is simple: just aListcomponent. Not contained inside anyPanel(unless you had aPanelsubclass that provided a decorative border, such as the previously-discussedBorderPanel).\nNow for theEASTpart, which is a bit trickier. You want all theButtoncomponents the same size (your mind should immediately thinkGridLayout) but that size should be their preferred height and preferred width. Any space below the buttons expands and collapses.\nBecause you've placed the entire strip ofButtons as anEASTcomponent of aBorderLayout, their width is fixed on the preferred width of the container that encloses those buttons. To fix their height on their preferred height, you can place the strip_inside anotherBorderLayout, as theNORTHcomponent_! SoEASTis aPanelwith aBorderLayoutcontaining anotherPanelas itsNORTHcomponent, and thatNORTH``Panelhas aGridLayoutcontrolling its buttons. TheGridLayoutis a single column of buttons, so its constructor parameters are (0,1).\nNow for a look at the structure of theFileDisplay:\nFileDisplayextendsPanel, layout=BorderLayout NORTH=Panel, layout=BorderLayout NORTH=Label(\u0026quot;\u0026quot;) SOUTH=Choice CENTER=List EAST=Panel, layout=BorderLayout NORTH=Panel,layout=GridLayout(0,1) Button(\u0026quot;ChgDir\u0026quot;) Button(\u0026quot;MkDir\u0026quot;) TextField(\u0026quot;*.*\u0026quot;) Button(\u0026quot;View\u0026quot;) Button(\u0026quot;Exec\u0026quot;) Button(\u0026quot;Rename\u0026quot;) Button(\u0026quot;Delete\u0026quot;) Button(\u0026quot;Refresh\u0026quot;) Button(\u0026quot;DirInfo\u0026quot;) To make this work properly, you must haveFileDisplay\u0026quot;promote\u0026quot; the text property of itsLabelas a property of its own. Provide aget()andset()method for that property that simply gets and sets the text property of theLabel. You'll see this when the code is reviewed later.\nAll that remains now is theCENTERsection of the main GUI.\nBack to the Main FTP GUI...\nExamine what theCENTERsection looks like without the details that you captured inFileDisplay:\nThe two ovals represent the two instance ofFileDisplay. The behavior of this part of the GUI is really up to four components: twoFileDisplaycomponents, which should take up equal amounts of space, and twoButtoncomponents, each with its preferred size, floating casually in between them.\nFor purposes of aesthetics, assume that the buttons should be centered vertically.\nThis is a tricky layout situation. Among the standard layout managers, there is really only one choice: theGridBagLayout.\nExamine how difficult this can be for a simple case like this. First, you need to determine where the grid cells are. You do this as is always necessary to do withGridBagLayoutâ€”draw lines between each pair of adjoining components all the way across the GUI:\nYou can see that thisGridBagLayoutwill have six cells and four (numbered) components. Each cell requires the configuration of aGridBagConstraintsobject, to be passed along as the constraints in theadd(Component component, Object constraints)version of theadd()method. You now need to walk through theGridBagConstraintsoptions and determine what they should be.\nFirst, the easy ones, gridx, gridy, gridwidth, gridheight, ipadx, and ipady. You'll use insets rather than padding, so it makes the ipadx and ipady settings zero for all components:\nparameter 1 2 3 4 gridx 0 2 1 1 gridy 0 0 0 1 gridwidth 1 1 1 1 gridheight 2 2 1 1 ipadx 0 0 0 0 ipady 0 0 0 0 Next you need to understand fill. Recall that this tells how the components will expand within their allotted cells. For components 1 and 2, this will be BOTH; you want components 3 and 4 to be their preferred size, so fill will be NONE.\nNext, anchor. Because components 1 and 2 completely fill their allotted space, their anchor could be any value. Usually you use the default ofCENTER. Component 3 sits at the bottom/center of its cellâ€”that's theSOUTHanchor position. Component 4 sits at the top/center of its cellâ€”that's theNORTH, anchor position.\nThe insets define the space to leave around components. There's no space around components 1 and 2, so their insets are all 0. You want some space around components 3 and 4. How about four pixels between them and any adjoining components. You can do this in several ways to put 4 pixels between components 3 and 4â€”give them 2 as their bottom and top insets.\nNow the tricky part of thisGridBagLayout: the weights. Think about the constraints rules you want:\nThe cells of components 1 and 2 expand horizontally, equally The cells of components 3 and 4 do not expand horizontally The cells of components 1 and 2 expand vertically to fill the entire space equally The cells of components 3 and 4 expand vertically, each filling half the space By rule #1, the weightx settings of components 1 and 2 must be equal. By rule #2, the weightx settings of components 3 and 4 must be 0. These are the only rules relating to horizontal space, so you can pick any weights you want for components 1 and 2, as long as they are the same. The weights are floating point numbers, and a nice convention to follow is to normalize the total weights to 1.0, giving each component 1 and 2 a weightx of 0.5.\nBy rule #3, the weighty settings of components 1 and 2 must be equal, and should be the total weighty of the container. By rule #4, the weighty settings of components 3 and 4 must be equal and be half of the total weighty. This gives the following results:\nparameter 1 2 3 4 gridx 0 2 1 1 gridy 0 0 0 1 gridwidth 1 1 1 1 gridheight 2 2 1 1 ipadx 0 0 0 0 ipady 0 0 0 0 fill BOTH BOTH NONE NONE anchor CENTER CENTER SOUTH NORTH weightx 0.5 0.5 0.0 0.0 weighty 1.0 1.0 0.5 0.5 insets - top 0 0 0 2 insets - bottom 0 0 2 0 insets - left 0 0 4 4 insets - right 0 0 4 4 Setting theseGridBagConstraintsfinishes the GUI design. Writing code for this GUI produces:\nWhich, decorations aside, looks just like you wanted it to!\nA note on that lastGridBagLayout: sometimes the initial thought regarding components 3 and 4 is to have weightx and weighty be zero for both components. This would produce the following result:\nNotice where the \u0026quot;\u0026lt;--\u0026quot; and \u0026quot;--\u0026gt;\u0026quot; buttons are. The weightx and weighty values control the sizing of the_grid cells_that a component will occupy. If the sum of the weights for a given row or column in aGridBagLayoutdoes not equal that of the other rows or columns,GridBagLayoutmakes up the difference by setting the weight of the_last_component in that row or column. In this case, you have three columns: two are theFileDisplaycomponents, and the third is the column with the two buttons in it. Because the weighty values of the two buttons don't add to the same weighty values of the other two columns,GridBagLayoutgives the lower button's grid cell the entire remaining height.\nLooking at Some Code for this GUI\nThere are two common approaches to writing GUI code by hand. One involves building sub-GUIs via method calls, the other involves simply putting all the code in one-big blob.\nThe following example code for this GUI follows the first pattern:\nFtp1.java FileDisplay1.java This code was generated using IBM's VisualAge for Java, and simplified by removing the exception handling and \u0026quot;ivj\u0026quot; prefixes on all the variable names. The code follows a \u0026quot;lazy instantiation\u0026quot; strategy: no GUI components or sub-GUIs are created until needed. This has several advantages:\nIf a GUI in your application isn't used, it's never created, making the program more efficient. You never need to worry if you've already created part of a GUI or not; you simply call the method in question to access that part of the GUI. The GUI structure is directly reflected in the code. Nested GUI elements are calls made to other methods. Of course, there are a few disadvantages as well:\nMore code to write Slightly slower performance due to extra method calls (although this is minimal compared to other performance issues) Another alternative is to use a GUI builder tool to create the interfaces. This can be a very attractive option, especially if your GUI is very complex.\nTaking this same example and writing it_blob_-style can result in the following code:\nFtp2.java FileDisplay2.java The advantage here is less code, although it can be difficult to see the GUI structure in the code. It can also be very difficult to properly order the creation/addition of GUI objectsâ€”you must be very careful to create everything you need before you use it.\nA Very Common Layout Need\nA common GUI need is to create some sort of input form. The following is a simple example:\nNote that in this GUI all of the labels line up horizontally, as do the text fields. When this GUI is expanded horizontally, the text fields should stretch but the labels should not.\nOne of the things to be mindful of when designing this GUI is what happens when the window is expanded vertically. Text fields tend not to look too good when expanded vertically. You probably want everything to keep its preferred height.\nKeeping the labels and text fields at their preferred height\nAllowing the labels and text fields to stretch\nSo, how do you design this GUI?\nFirst, you need to think about how to bind the labels and text fields to their preferred height. This can be accomplished by placing all of the components as theNORTHcomponent of aBorderLayout.\nNext, you need to divide the GUI into two evenly spaced parts: the left half the right half. You should think \u0026quot;GridLayout\u0026quot; whenever you hear the phrase \u0026quot;equally spaced\u0026quot;. ThisGridLayoutconsists of a single row; its parameters to its constructor would be (1,0). (In the above example, you are also setting hgap to five.)\nNow what do you do about the pairs of text fields and labels? Your initial answer might involve placing each pair of text fields and labels into their ownBorderLayout. For example:\n1Panel panel1 = new Panel(new BorderLayout()); 2panel1.add(new Label(\u0026#34;First name:\u0026#34;), BorderLayout.WEST); 3panel1.add(new TextField(), BorderLayout.CENTER); Using this strategy for each pair of labels and text fields, and adding each of those into their proper place in the GUI, you get a slightly undesirable affect:\nSo what happened? Think about whatBorderLayoutdoes. It says \u0026quot;look at myWESTcomponent. Give it its preferred width. Then, give theCENTERcomponent the remaining available space.\u0026quot; Note that it doesn't say \u0026quot;look at the component below me. Make sure myWESTcomponent matches the same size as_his_WESTcomponent.\u0026quot; You need to somehow associate the labels with one other, and the text fields with one another.\nThe only way you can do this is to put all the labels that go together in the same container. Similar for the text fields. However, you also need to make sure the text fields and labels line up.\nIf you can make sure that the container that holds the labels takes up the same vertical space as the container that holds the text fields, you can use aGridLayoutto divide each of those spaces evenly. But wait; you have already decided to put all of the labels and text fields in theNORTHcomponent of the overallBorderLayout. This fixes the height of that set of components to its preferred height.\nSo, you start off with the overallBorderLayout. You add a Panel as theNORTHcomponent of theBorderLayout. ThisNORTHPanel contains all the other components, and uses a single-rowGridLayout.\nWithin thatGridLayout, you add two Panels for the left and right halves of the GUI. Each of these panels will contain two components: a Panel that contains the labels, and a Panel that contains the text fields. Because you want the text fields to expand horizontally, and the labels to keep a fixed width, you want to use aBorderLayout.\nThe final GUI will be structured as follows:\nFrame, layout=BorderLayout NORTH=Panel, layout=GridLayout(1,0) Panel, layout=BorderLayout WEST=Panel, layout=GridLayout(3,0) Label(\u0026quot;First name:\u0026quot;) Label(\u0026quot;Street:\u0026quot;) Label(\u0026quot;Phone:\u0026quot;) CENTER=Panel, layout=GridLayout(3,0) TextField TextField TextField Panel, layout=BorderLayout WEST=Panel, layout=GridLayout(3,0) Label(\u0026quot;Last name:\u0026quot;) Label(\u0026quot;City:\u0026quot;) CENTER=Panel, layout=GridLayout(3,0) TextField TextField One thing to notice here is the parameters passed to the most deeply nestedGridLayoutcontainers. Your first thought when setting up theseGridLayoutcontainers should be \u0026quot;there is one column of components\u0026quot;. The problem is, the first set ofGridLayoutcontainers have three components each; the second set has two components each. If you set aGridLayoutconstructor parameters to (0, 1), the GUI would look as follows:\nNotice the second set of labels and text fields is evenly spaced into two chunks. What you wanted was to have all the text fields and all the labels take up the same amount of vertical space (which means that there will be a blank spot at the bottom of the rightmost set of labels and text fields).\nDuke, the Java mascot, provided by Sun Microsystems under the New BSD license.\n","link":"https://javadude.com/post/20000304-layouts/","section":"post","tags":["java","design"],"title":"Effective Layout Management"},{"body":"","link":"https://javadude.com/series/","section":"series","tags":null,"title":"Series"}]