
<!DOCTYPE html>
<html
  lang="en"
  data-figures=""
  
    class="page"
  
  
  >
  <head>
<title>An ANTLR 2.0 Tutorial | javadude.com</title>
<meta charset="utf-8">

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">





<meta property="og:locale" content="en" />

<meta property="og:type" content="article">
<meta name="description" content="Learning to use ANTLR v2." />
<meta name="twitter:card" content="summary" />
<meta name="twitter:creator" content="">
<meta name="twitter:title" content="An ANTLR 2.0 Tutorial" />
<meta name="twitter:image" content="https://www.javadude.com/images/thumbnail.png"/>
<meta property="og:url" content="https://www.javadude.com/post/20000304-antlrtut/" />
<meta property="og:title" content="An ANTLR 2.0 Tutorial" />
<meta property="og:description" content="Learning to use ANTLR v2." />
<meta property="og:image" content="https://www.javadude.com/images/thumbnail.png" />
  <meta name="keywords" content="java,antlr,parsing,language,dsl" />
  <script type="application/ld+json">
    {
      "@context": "http://schema.org",
      "@type": "BlogPosting",
      "mainEntityOfPage":"https:\/\/www.javadude.com\/post\/20000304-antlrtut\/",
      "name": "javadude.com",
      "headline": "An ANTLR 2.0 Tutorial",
      "description": "Learning to use ANTLR v2.",
      "url": "https:\/\/www.javadude.com\/post\/20000304-antlrtut\/",
      "datePublished": "2000-03-04T00:00:00Z",
      "dateModified": "2000-03-04T00:00:00Z",
      "keywords": ["java","antlr","parsing","language","dsl"],
        "articleSection": ["Articles"],
      "author": {
        "@type": "Person",
        "name": "map[name:Scott Stanchfield photo:images\/yellow.jpeg]"
      },
      "image":{
        "@type":"ImageObject",
        "url": "https:\/\/www.javadude.com\/images\/thumbnail.png"
      },
      "publisher": {
        "@type": "Organization",
        "logo": {
          "@type":"ImageObject",
          "url": "https:\/\/www.javadude.com\/"
        },
        "name": "javadude.com"
      }
    }
  </script>

<link rel="apple-touch-icon" sizes="180x180" href="https://www.javadude.com/icons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://www.javadude.com/icons/favicon-32x32.png">
<link rel="manifest" href="https://www.javadude.com/icons/site.webmanifest">

<link rel="canonical" href="https://www.javadude.com/post/20000304-antlrtut/">



<link rel="preload" href="https://www.javadude.com/css/styles.bc1eb1dd1fc5d14285e0b88a05fef346a89bc5e461c683e5fc57576c7455fe75831ec8ecacec5edfb95ff21decee7759160e705bc419e8e864dcf581963a4140.css" integrity = "sha512-vB6x3R/F0UKF4LiKBf7zRqibxeRhxoPl/FdXbHRV/nWDHsjsrOxe37lf8h3s7ndZFg5wW8QZ6Ohk3PWBljpBQA==" as="style" crossorigin="anonymous">



<link rel="preload" href="https://www.javadude.com/en/js/bundle.91a9d0f0da58c5acdd5ce35d3bad54e076ed9e5bd70e8601c2d68ec9430e043db3691652dfc22e2cbf23188abd51a3c15dd3c3bdaba83991e7c37b71b127c01d.js" as="script" integrity=
"sha512-kanQ8NpYxazdXONdO61U4HbtnlvXDoYBwtaOyUMOBD2zaRZS38IuLL8jGIq9UaPBXdPDvauoOZHnw3txsSfAHQ==" crossorigin="anonymous">


<link rel="stylesheet" type="text/css" href="https://www.javadude.com/css/styles.bc1eb1dd1fc5d14285e0b88a05fef346a89bc5e461c683e5fc57576c7455fe75831ec8ecacec5edfb95ff21decee7759160e705bc419e8e864dcf581963a4140.css" integrity="sha512-vB6x3R/F0UKF4LiKBf7zRqibxeRhxoPl/FdXbHRV/nWDHsjsrOxe37lf8h3s7ndZFg5wW8QZ6Ohk3PWBljpBQA==" crossorigin="anonymous">

  </head>
  <body
    data-code="10000"
    data-lines="true"
    id="documentTop"
    data-lang="en"
  >

<header class="nav_header" >
  <nav class="nav"><a href='https://www.javadude.com/' class="nav_brand nav_item" title="javadude.com">javadude.com
  <div class="nav_close">
    <div><svg class="icon">
  <title>open-menu</title>
  <use xlink:href="#open-menu"></use>
</svg>
<svg class="icon">
  <title>closeme</title>
  <use xlink:href="#closeme"></use>
</svg>
</div>
  </div>
</a>

    <div class='nav_body nav_body_left'>
      
      
      
        

  <div class="nav_parent">
    <a href="https://www.javadude.com/" class="nav_item" title="Home">Home </a>
  </div>
  <div class="nav_parent">
    <a href="https://www.javadude.com/categories/class" class="nav_item" title="Classes">Classes </a>
  </div>
  <div class="nav_parent">
    <a href="https://www.javadude.com/categories/articles" class="nav_item" title="Articles">Articles </a>
  </div>
  <div class="nav_parent">
    <a href="https://www.javadude.com/categories/videos" class="nav_item" title="Videos">Videos </a>
  </div>
  <div class="nav_parent">
    <a href="https://www.javadude.com/categories/tools" class="nav_item" title="Tools">Tools </a>
  </div>
  <div class="nav_parent">
    <a href="https://www.javadude.com/publications/" class="nav_item" title="Publications">Publications </a>
  </div>
  <div class="nav_parent">
    <a href="https://www.javadude.com/about/" class="nav_item" title="About">About </a>
  </div>
      
<div class='follow'>
  <a href="https://github.com/javadude">
    <svg class="icon">
  <title>github</title>
  <use xlink:href="#github"></use>
</svg>

  </a>
  <a href="https://gitlab.com/javamage">
    <svg class="icon">
  <title>gitlab</title>
  <use xlink:href="#gitlab"></use>
</svg>

  </a>
  <a href="https://www.youtube.com/scottstanchfield">
    <svg class="icon">
  <title>youtube</title>
  <use xlink:href="#youtube"></use>
</svg>

  </a>
  <a href="https://stackoverflow.com/users/12541/scott-stanchfield">
    <svg class="icon">
  <title>stackoverflow</title>
  <use xlink:href="#stackoverflow"></use>
</svg>

  </a>
  <a href="https://www.facebook.com/scott.stanchfield">
    <svg class="icon">
  <title>facebook</title>
  <use xlink:href="#facebook"></use>
</svg>

  </a>
    
  <a href="https://www.javadude.com/index.xml">
    <svg class="icon">
  <title>rss</title>
  <use xlink:href="#rss"></use>
</svg>

  </a>
<div class="color_mode">
  <input type="checkbox" class="color_choice" id="mode">
</div>

</div>

    </div>
  </nav>
</header>

    <main>
  
<div class="grid-inverse wrap content">
  <article class="post_content">
    <h1 class="post_title">An ANTLR 2.0 Tutorial</h1>
  <div class="post_meta">
    <span><svg class="icon">
  <title>calendar</title>
  <use xlink:href="#calendar"></use>
</svg>
</span>
    <span class="post_date">
      Mar 4, 2000	  
    </span>
    <span class="post_time"> · 61 min read</span><span>&nbsp;· <a href='https://www.javadude.com/tags/java/' title="java" class="post_tag button button_translucent">java
        </a><a href='https://www.javadude.com/tags/antlr/' title="antlr" class="post_tag button button_translucent">antlr
        </a><a href='https://www.javadude.com/tags/parsing/' title="parsing" class="post_tag button button_translucent">parsing
        </a><a href='https://www.javadude.com/tags/language/' title="language" class="post_tag button button_translucent">language
        </a><a href='https://www.javadude.com/tags/dsl/' title="dsl" class="post_tag button button_translucent">dsl
        </a>
    </span>
    <span class="page_only">&nbsp;·
  <div class="post_share">
    Share on:
    <a href="https://twitter.com/intent/tweet?text=An%20ANTLR%202.0%20Tutorial&url=https%3a%2f%2fwww.javadude.com%2fpost%2f20000304-antlrtut%2f&tw_p=tweetbutton" class="twitter" title="Share on Twitter" target="_blank" rel="nofollow">
      <svg class="icon">
  <title>twitter</title>
  <use xlink:href="#twitter"></use>
</svg>

    </a>
    <a href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fwww.javadude.com%2fpost%2f20000304-antlrtut%2f&t=An%20ANTLR%202.0%20Tutorial" class="facebook" title="Share on Facebook" target="_blank" rel="nofollow">
      <svg class="icon">
  <title>facebook</title>
  <use xlink:href="#facebook"></use>
</svg>

    </a>
    <a href="#linkedinshare" id = "linkedinshare" class="linkedin" title="Share on LinkedIn" rel="nofollow">
      <svg class="icon">
  <title>linkedin</title>
  <use xlink:href="#linkedin"></use>
</svg>

    </a>
    <a href="https://www.javadude.com/post/20000304-antlrtut/" title="Copy Link" class="link link_yank">
      <svg class="icon">
  <title>copy</title>
  <use xlink:href="#copy"></use>
</svg>

    </a>
  </div>
  </span>
  </div>

    <div class="post_body"><p>A tutorial on ANTLR 2.x</p>
<h3 id="note-this-is-the-antlr-2x-tutorial-if-youre-looking-for-an-antlr-3x-tutorial-please-see-my-new"><em>Note: This is the ANTLR 2.x Tutorial. If you're looking for an ANTLR 3.x Tutorial, please see my new <a href="../20091221-antlr3tut">ANTLR 3.x Video Tutorial</a></em></h3>
<h2 id="introduction">Introduction</h2>
<h3 id="the-part-youll-never-read">(the part you'll never read...)</h3>
<p><em>Note: I've had several requests over the years to make this a single page. Well, here it is. Enjoy!</em></p>
<p>I need to warn you up front that I can be a bit long-winded, so bear with me while I try to describe a bit about what ANTLR is, how you can write parsers and compilers using it, what type of code it will produce, the color of the moon on an October evening and why &quot;42&quot; is such an important number (or so says Douglas Adams.)</p>
<p>Ok. Call me nuts. I just sick of all the whining about how hard it is to learn ANTLR. (So the whining is valid -- it's a <em>bit</em> hard to learn. <em>I</em> only had the cat to whine to.) I remembered learning PCCTS (the old C/C++ version of ANTLR) a few years ago using the &quot;Advanced Tutorial&quot; but things have changed significantly since then. Back then, I used PCCTS for a compiler course. I loved it and have loved it ever since. I figured, &quot;Hey, I've got a simple compiler written in PCCTS, so why not revise it and write it as a tutorial?&quot; So here it is.</p>
<p>I want this tutorial to really help people, so I'm asking for input. Email me at  <a href="mailto:scott@javadude.com">scott@javadude.com</a> with any suggestions or comments you may have, and I just might do some more work on this.</p>
<h2 id="a-simple-language">A Simple Language</h2>
<p>The compiler course I took at Johns Hopkins featured a small language called &quot;XL.&quot; I'm not sure who came up with this language, but the course was taught by Dr. John Moore, and he presented XL to us. I wanted to at least give him some credit for getting me really interested in compilers and such. If anyone knows a reason why I shouldn't be presenting this language, please let me know and I'll remove this from the net. I'll be presenting the language almost verbatim from Dr. Moore's writeup of the language.</p>
<p>Note that in this tutorial I will not be implementing the entire XL language. I will only be implementing the features I selected when writing the compiler for the class. Eventually I will try to implement all the features in this document, if I have lots of extra time between reading to the kids and changing their diapers. I will try to mention when features are not implemented.</p>
<p>XL is a small but complete programming language based primarily on Ada and, to a lesser extent on C, C++ and Pascal. XL was designed to be suitable for use as a project language in a course on compiler design and construction. Its features illustrate many of the techniques and problems associated with language translation.</p>
<hr>
<h3 id="general">General</h3>
<p>XL is case sensitive. Upper-case letters and lower-case letters are considered to be distinct in all tokens, including reserved words.</p>
<p>White space (space character, tab character and end-of-line) serves to separate tokens; otherwise, it is ignored. No token can extend past end-of-line. Spaces may not appear inside any token except character and string literals.</p>
<p>A comment begins with two forward slashes and extends to end of line, as in C++.</p>
<hr>
<h3 id="identifiers">Identifiers</h3>
<p>Identifiers start with a letter and contain letters and digits. An identifier must fit on a single line and its first 100 characters are significant.</p>
<hr>
<h3 id="reserved-words">Reserved Words</h3>
<p>The following keywords are reserved in XL:</p>
<table>
  <thead>
      <tr>
          <th>keyword</th>
          <th>keyword</th>
          <th>keyword</th>
          <th>keyword</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>and</td>
          <td>array</td>
          <td>Boolean</td>
          <td>begin</td>
      </tr>
      <tr>
          <td>Char</td>
          <td>constant</td>
          <td>else</td>
          <td>elsif</td>
      </tr>
      <tr>
          <td>and</td>
          <td>exit</td>
          <td>function</td>
          <td>if</td>
      </tr>
      <tr>
          <td>Integer</td>
          <td>loop</td>
          <td>mod</td>
          <td>not</td>
      </tr>
      <tr>
          <td>of</td>
          <td>or</td>
          <td>out</td>
          <td>procedure</td>
      </tr>
      <tr>
          <td>program</td>
          <td>record</td>
          <td>return</td>
          <td>String</td>
      </tr>
      <tr>
          <td>then</td>
          <td>type</td>
          <td>var</td>
          <td>when</td>
      </tr>
      <tr>
          <td>while</td>
          <td></td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="literals">Literals</h3>
<p>An integer literal consists of a sequence of one or more digits</p>
<p>A character literal is a single character enclosed by a pair of apostrophes (sometimes called &quot;single quotes&quot;.) Examples include <code>'A'</code>, <code>'x'</code>, and <code>'''</code>. A character literal is distinct from a string literal of length one.</p>
<p>A string literal is a sequence of zero or more printable characters enclosed by a pair of quotation marks (&quot;double quotes.&quot;) The double quote character itself can be represented in a string as two adjacent double quotes. In XL, string literals are only used as arguments to the predefined I/O procedure &quot;put&quot; (see below)</p>
<hr>
<h3 id="other-tokens-delimiters-and-operators">Other Tokens (delimiters and operators)</h3>
<table>
  <thead>
      <tr>
          <th>operators</th>
          <th>note</th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>
<p>: ; , . ( ) [ ] | one character
+ - * / &lt; = &gt; ' | one character
.. := /= &gt;= &lt;=    | two characters
(end-of-file)         | actual EOF, not words</p>
<hr>
<h3 id="standard-predefined-scalar-types">Standard (Predefined) Scalar Types</h3>
<p>The type <code>Boolean</code> is treated as a predefined enumeration type with elements <code>FALSE</code> and <code>TRUE</code></p>
<p>The type <code>Integer</code> is a predefined type as in Pascal and FORTRAN (equivalent to type <code>int</code> in C)</p>
<p>The type <code>Char</code> is a predefined type which is equivalent to Pascal's <code>CHAR</code>. The predecessor and successor functions are invoked as attributes <code>Char'pred</code> and <code>Char'succ</code>. Thus, <code>Char'pred('D')</code> is 'C' and <code>Char'succ('A')</code> is 'B'. (At this point, these attributes are not implemented. I may add them later.)</p>
<hr>
<h3 id="type-generators">Type Generators</h3>
<p>An enumeration type is defined by listing the identifiers which are the actual values of the type. As with type <code>Char</code>, the predecessor and successor functions of an enumeration type <code>T</code> as invoked as attributes <code>T'pred</code> and <code>T'succ</code>. For example:</p>
<pre><code>type CardSuit = &lt;CLUB, DIAMOND, HEART, SPADE&gt;;       
</code></pre>
<p>Then <code>CardSuit'pred(HEART)</code> is DIAMOND and <code>CardSuit'succ(HEART)</code> is SPADE.</p>
<p>An array type (one dimensional only) is defined by giving a range of indices and the component type. Only integer indices are allowed in XL. For example</p>
<pre><code>type Table = array[1..10] of Integer;       
</code></pre>
<p>A record type is defined by listing the individual component names (fields) and their types. For example:</p>
<pre><code>type Date =
	record
		day : Integer;
		month: Integer;
		year: Integer;
	end record;
</code></pre>
<hr>
<h3 id="named-constants">Named Constants</h3>
<p>Named constants are introduced by declarations of the form</p>
<pre><code>constant ID, ID, . . ., ID: typeName := expression;       
</code></pre>
<p><code>typeName</code> must be an identifier representing a scalar type (<code>Integer</code>, <code>Boolean</code>, <code>Char</code> or a user-defined enumeration type.) The phrase &quot;<code>:=</code> expression&quot; is required. For example:</p>
<pre><code>constant maxIndex : Integer := 100;       
</code></pre>
<hr>
<h3 id="variables">Variables</h3>
<p>Variables are introduced by declarations of the form</p>
<pre><code>var ID, ID, ..., ID : typeName := expression;       
</code></pre>
<p><code>typeName</code> must be an identifier, not a type constructor such as an <code>array</code> or <code>record</code>. The phrase &quot;<code>:= expression</code>&quot; is optional and can only involve literals and named constants. For example:</p>
<pre><code>var I : Integer := 1;
var b1, b2 : Boolean;       
</code></pre>
<hr>
<h3 id="operators-and-expressions">Operators and Expressions</h3>
<h4 id="operators">Operators</h4>
<p>The operators, in order of precedence, are</p>
<table>
  <thead>
      <tr>
          <th>category</th>
          <th>operators</th>
          <th>precedence</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Boolean negation</td>
          <td>not</td>
          <td>highest</td>
      </tr>
      <tr>
          <td>Unary adding operators</td>
          <td>+   -</td>
          <td></td>
      </tr>
      <tr>
          <td>Multiplying operators</td>
          <td>*   /   mod</td>
          <td></td>
      </tr>
      <tr>
          <td>Binary adding operators</td>
          <td>+ -</td>
          <td></td>
      </tr>
      <tr>
          <td>Relational operators</td>
          <td>=  /=  &lt;  &lt;=  &gt;  &gt;=</td>
          <td></td>
      </tr>
      <tr>
          <td>Logical operators</td>
          <td>and or</td>
          <td>lowest</td>
      </tr>
  </tbody>
</table>
<h4 id="expressions">Expressions</h4>
<p>For binary operators, both operands must be the same type. Similarly, for assignment compatibility, both the left and right sides must have the same type. Objects are considered to have the same type only if they both have the same type name. Thus, two distinct type definitions are considered different even if they may be structurally identical. This is known as &quot;name equivalence&quot; of types.</p>
<h4 id="short-circuiting">Short Circuiting</h4>
<p>Logical operators <code>and</code> and <code>or</code> use short-circuit evaluation.</p>
<p>(If you are not familiar with short-circuiting, this means that as soon as the truth value can be determined, evaluation stops. For example, if the first operand of an <code>and</code> evaluates <code>false</code>, the expression will evaluate <code>false</code> no matter what the second operand is, so the second operand is not even evaluated. If the first operand of an <code>or</code> evaluates <code>true</code>, the second isn't evaluated either.)</p>
<hr>
<h3 id="statements">Statements</h3>
<p>All statements are terminated with a semicolon.</p>
<h4 id="assignment-statement">Assignment statement</h4>
<p>(&quot;:=&quot; is the assignment operator). For example</p>
<pre><code>i := 2*I + 5;     
</code></pre>
<h4 id="if-statement">If statement</h4>
<pre><code>if x &gt; MAX then 			if x &lt; 10 then
	MAX := x; 					x := x + 1;
elsif x &lt; MIN then 				y := 2*x;
	MIN := x; 				end if;
end if;
</code></pre>
<h4 id="loop-and-exit-statements">Loop and exit statements</h4>
<pre><code>loop 						while I &lt; n loop
	get(x);						sum := sum + a[I];
	exit when x = SIGNAL;		i := i + 1;
	process(x);				end loop;
end loop;
</code></pre>
<h4 id="io-statements-for-text-io-only">I/O Statements (for text I/O only)</h4>
<p>XL defines only sequential I/O for two basic character streams, standard input and standard output. All I/O is provided by the following procedures:</p>
<pre><code>procedure put(item : String); // for string literals
procedure put(item : Char);
procedure put(item : Integer);
procedure newLine;
procedure get(var item : Char);
procedure get(var item : Integer);
procedure skipLine;       
</code></pre>
<hr>
<h3 id="subprograms">Subprograms</h3>
<h4 id="procedures">Procedures</h4>
<p>Procedures are similar to those in Pascal except that an explicit return is allowed. The program is essentially the outermost procedure (with no parameters) and serves as a starting point for the program.</p>
<h4 id="functions">Functions</h4>
<p>Functions can return scalar types only, not arrays or records. Only value parameters are allowed. A function returns a value by executing a statement of the form</p>
<pre><code>return expression;       
</code></pre>
<h4 id="parameters">Parameters</h4>
<p>There are two parameter modes in XL: value parameters and variable parameters. Value parameters (passed by copy) are the default. Variable parameters (passed by reference) must be explicitly declared as in</p>
<pre><code>procedure p(var x : Integer) ...       
</code></pre>
<h4 id="subprogram-end">Subprogram end</h4>
<p>The name of the procedure must be repeated at the end of its declaration. For example</p>
<pre><code>procedure proc1;
	...
end proc1;
</code></pre>
<hr>
<h3 id="specification-conclusion">Specification Conclusion</h3>
<p>OK, so it's sketchy. I know, I know. But that's what I got. Maybe I'll improve it someday, but I think if you're a programmer you'll probably understand it pretty well anyway...</p>
<p>Next we'll discuss... </p>
<h2 id="our-strategy">Our Strategy</h2>
<h3 id="structure-of-our-compiler">Structure of Our Compiler</h3>
<p>So, now that we have a so-so idea of the language we are compiling, let's design our compiler and think about how we want to implement it.</p>
<p>A basic compiler consists of several pieces. These pieces can be very independent, or very intertwined. I'll try an independent approach here...</p>
<p>The compiler will take an input source file, and output some sort of executable. Let's break it down into tasks:</p>
<ul>
<li>Lexical Analysis (scanning)</li>
<li>Semantic Analysis (parsing)</li>
<li>Tree Generation</li>
<li>Code Generation</li>
<li>Interpretation</li>
</ul>
<p>The approach I'll take is to generate a pseudo-machine code, and we'll write a simple interpreter at the end. This approach is similar to the Pascal P-Code machines and the current Java Virtual Machine approach...</p>
<h4 id="lexical-analysis">Lexical Analysis</h4>
<p>First, the compiler will read the input file and lump the characters together into tokens. Using ANTLR 2.x, this job is done using a scanner definition.  One of the big differences between ANTLR 2.x and PCCTS 1.33 is how you specify your scanner.  ANTLR 2.x uses a syntax that is nearly identical to the <em>parser</em> syntax.  You create a recursive-descent scanner as well as a recursive-descent parser.</p>
<h4 id="semantic-analysis">Semantic Analysis</h4>
<p>Next, we write grammar rules to pump into ANTLR. These rules will have action code (Java code) attached to them to specify what to do when we see certain patterns of tokens in the input file.</p>
<h4 id="tree-generation">Tree Generation</h4>
<p>This actually occurs along with the semantic analysis. We'll generate an Abstract Syntax Tree (AST) using ANTLR's built-in tree generation routines. This tree will act as the communication device between the parser and the code generator.</p>
<h4 id="code-generation">Code Generation</h4>
<p>Once we have a tree, we'll walk it and write out code.  More on this if I ever finish this tutorial...</p>
<h4 id="interpretation">Interpretation</h4>
<p>The interpreter for XL is really simple, and will allow us to test our compiled output without needing to learn specific machine code.</p>
<hr>
<h3 id="structure-of-this-tutorial">Structure of this Tutorial</h3>
<p>Now how will we build this compiler? Should we try to do everything at once so you get good and confused? Of course not!</p>
<p>We'll break the work up into steps:</p>
<ol>
<li>Build a Recognizer</li>
<li>Add a symbol table</li>
<li>Add type checking</li>
<li>Build an AST</li>
<li>Write a Tree Walker to generate code</li>
<li>Write an Interpreter</li>
<li>Test the output code</li>
</ol>
<p>Let's start our recognizer!</p>
<h2 id="the-scanner">The Scanner</h2>
<h3 id="introduction-1">Introduction</h3>
<p>We'll look at each language element and put together some scanner rules for it. In some cases, I may look at how the same construct would be implemented for other languages, showing some difficulties and how to overcome them. At least that's my plan. We'll see where I end up...</p>
<p>You can download the code for the tutorial or type along. I recommend typing along as it seems to help folks &quot;get&quot; what's going on...</p>
<p>Source code: <a href="/post/20000304-antlrtut/antlrtut.zip">antlrtut.zip</a></p>
<p>This zip file is also an Eclipse project. If you have the ANTLR-Eclipse plugin installed, you can edit and test the code within eclipse. Simply unzip the antlrtut.zip and use <strong>Import-&gt;Existing Project Into Workspace</strong> from within Eclipse.</p>
<h3 id="lexical-elements-of-xl">Lexical Elements of XL</h3>
<h4 id="whitespace">Whitespace</h4>
<p>XL declares that blank spaces, tabs, and end-of-line constitute whitespace. Oh, and don't forget the ever (un)popular carriage-return/line-feeds that DOS is so fond of. You should always handle this, especially if you will be running on UNIX and there is even a <em>chance</em> that someone will run a file that has been touched by DOS through your parser. And <em>just</em> to make things more interesting, let's consider the Macintosh as well; it uses a lonely carriage-return to specify a new line.</p>
<p>Most scanner-generation tools force you to specify regular expressions for scanner rules.  ANTLR 2.x simplifies this significantly.  Not only is the ANTLR tool itself significantly simpler, but it makes the job of a grammar writer much easier as well: you only need to learn one format of specification.</p>
<p>In ANTLR 2.x, you specify the scanner grammar in the same manner in which you specify the parser grammar.  We'll discuss some minor differences a bit later, but overall, they are virtually identical.</p>
<p>For our whitespace rule, we specify the following:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="nl">WS</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="o">(</span><span class="w">	</span><span class="s">&#39; &#39;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="w">		</span><span class="o">|</span><span class="w">	</span><span class="s">&#39;\t&#39;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="w">		</span><span class="o">|</span><span class="w">	</span><span class="s">&#39;\f&#39;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="w">		</span><span class="c">// handle newlines</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="w">		</span><span class="o">|</span><span class="w">	</span><span class="o">(</span><span class="w">	</span><span class="s">&#34;\r\n&#34;</span><span class="w">  </span><span class="c">// DOS/Windows</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="w">			</span><span class="o">|</span><span class="w">	</span><span class="s">&#39;\r&#39;</span><span class="w">    </span><span class="c">// Macintosh</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="w">			</span><span class="o">|</span><span class="w">	</span><span class="s">&#39;\n&#39;</span><span class="w">    </span><span class="c">// Unix</span><span class="w">
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="w">			</span><span class="o">)</span><span class="w">
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="w">			</span><span class="c">// increment the line count in the scanner</span><span class="w">
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="w">			</span><span class="p">{</span><span class="x"> newline(); </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="w">		</span><span class="o">)</span><span class="w">
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="w">		</span><span class="p">{</span><span class="x"> </span><span class="nv">$setType</span><span class="x">(Token.SKIP); </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="w"></span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>The <code>WS</code> rule defines what will happen when the scanner sees space (<code>' '</code>), tab (<code>'\t'</code>), formfeed (<code>'\f'</code>) or one of the platform-specific manners of indicating &quot;end of line.&quot;  First, we match the character(s) that we see.  If those characters represent &quot;end of line&quot;, we call the built-in <code>newline()</code> method, which tells the parser to increase its current line number.  (The line number will be used in error messages, so it's very important that you call the <code>newline()</code> method.)</p>
<p>After we match the whitepace (whatever it ends up being) we set the token type to Token.SKIP.  <code>$setType</code> is a special syntax for setting the type and will be translated by ANTLR into a Java statement.  This is a special token indicator that tells the scanner <em>not</em> to return a token, but to proceed on to the next token it might encounter.</p>
<p>Rules in an ANTLR 2.x scanner may be prefixed by the keyword <code>protected</code>, or by no keyword at all.  If a rule is prefixed by <code>protected</code>, it means that the rule will <em>only</em> be used as a <em>helper</em> rule.  Perhaps it is the definition of a &quot;decimal digit&quot; which could be used in other rules to help build a number.</p>
<p>Any scanner rules that are <em>not</em> prefixed with the <code>protected</code> keyword will be candidates for being called to match &quot;the next token.&quot;   ANTLR will create a <code>nextToken()</code> method that will pick the appropriate non-<code>protected</code> scanner rule to match the next token.  <code>nextToken()</code>, in turn, is called by a <em>parser</em> to fetch the next token it will try to match.</p>
<p>Note that ANTLR's syntax allows you to specify <em>subrules</em>. You can nest decisions within other decisions by enclosing the lower-level decision in another set of parenthesis.  Think of it as follows:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">someRuleName</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#39;A&#39;</span><span class="w"> </span><span class="s">&#39;B&#39;</span><span class="w"> </span><span class="s">&#39;C&#39;</span><span class="w">		</span><span class="c">// a top-level alternative</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="s">&#39;D&#39;</span><span class="w"> </span><span class="s">&#39;E&#39;</span><span class="w"> </span><span class="s">&#39;F&#39;</span><span class="w">		</span><span class="c">// a top-level alternative</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="s">&#39;Q&#39;</span><span class="w"> </span><span class="o">(</span><span class="w">			</span><span class="c">// starting a subrule!</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w">				</span><span class="s">&#39;R&#39;</span><span class="w"> </span><span class="s">&#39;S&#39;</span><span class="w"> </span><span class="c">// a subrule alternative</span><span class="w">
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="w">			</span><span class="o">|</span><span class="w">	</span><span class="s">&#39;W&#39;</span><span class="w"> </span><span class="s">&#39;X&#39;</span><span class="w">	</span><span class="c">// a subrule alternative</span><span class="w">
</span></span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="w">			</span><span class="o">)</span><span class="w">			</span><span class="c">// end the subrule</span><span class="w">
</span></span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">					</span><span class="c">// end the rule   </span><span class="w">
</span></span></span></code></pre></div><p>The above rule could match the following &quot;words&quot;</p>
<ul>
<li>ABC</li>
<li>DEF</li>
<li>QRS</li>
<li>QWX</li>
</ul>
<hr>
<h4 id="comments">Comments</h4>
<p>We got lucky in XL (it uses C++-style comments), but I'll bore you with C-style comments in a minute...</p>
<p>XL defines comments as &quot;all text from // to the end of the current line.&quot; So, we get a rule like</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">COMMENT</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;//&#34;</span><span class="w"> </span><span class="o">(~(</span><span class="s">&#39;\n&#39;</span><span class="o">|</span><span class="s">&#39;\r&#39;</span><span class="o">))*</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">		</span><span class="p">{</span><span class="x"> </span><span class="nv">$setType</span><span class="x">(Token.SKIP); </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>A few things to notice about this rule:</p>
<ul>
<li>Note that we <em>didn't</em> match the end-of-line character.  This will be matched by our <code>WS</code> rule that we have already defined.  What we <em>do</em> need to do is specify which characters are <em>ok</em> to keep in the comment.  As soon as we see <code>'\n'</code> or <code>'\r'</code>, both of which start an end-of-line sequence, we stop.</li>
<li>Those of you familiar with lex will notice that we can't just say &quot;.*&quot; to represent all non-newline characters. <code>(~('\n'|'\r'))*</code> is needed to explicitly state &quot;any character except end-of-line&quot;.</li>
</ul>
<p>I threatened to do C-style comments, so I will.</p>
<p>Let's assume we are using a C compiler that does not keep track of nested comments -- &quot;/*&quot; starts a comment, and &quot;*/&quot; ends a comment. It doesn't matter if it supports the C++ style comments or not -- they'll get gobbled just as well as the rest of a comment.</p>
<p>One of the advantages to the new scanner definition in ANTLR 2.x is that a full EBNF grammar is much stronger at representing a language description than regular expressions.   If you take a look at the old PCCTS tutorial, you can see what a mess defining C-style comments can be.  In contrast, a C-style comment in ANTLR 2.0 is a bit simpler:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c">// multiple-line comments</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="w"></span><span class="nl">ML_COMMENT</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;/*&#34;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="w">		</span><span class="o">(</span><span class="w">	</span><span class="c">/*	&#39;\r&#39; &#39;\n&#39; can be matched in one alternative or by matching
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c">				&#39;\r&#39; in one iteration and &#39;\n&#39; in another. I am trying to
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c">				handle any flavor of newline that comes in, but the language
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c">				that allows both &#34;\r\n&#34; and &#34;\r&#34; and &#34;\n&#34; to all be valid
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c">				newline is ambiguous. Consequently, the resulting grammar
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c">				must be ambiguous. I am shutting this warning off.
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c">			*/</span><span class="w">
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="w">			</span><span class="k">options</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="w">				</span><span class="nv">generateAmbigWarnings</span><span class="p">=</span>false<span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="w">			</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="w">			</span><span class="p">:</span><span class="w">	</span><span class="p">{</span><span class="x"> LA(2)!=&#39;/&#39; </span><span class="p">}</span><span class="o">?</span><span class="w"> </span><span class="s">&#39;*&#39;</span><span class="w">
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="w">			</span><span class="o">|</span><span class="w">	</span><span class="s">&#39;\r&#39;</span><span class="w"> </span><span class="s">&#39;\n&#39;</span><span class="w"> </span><span class="p">{</span><span class="x">newline();</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="w">			</span><span class="o">|</span><span class="w">	</span><span class="s">&#39;\r&#39;</span><span class="w"> </span><span class="p">{</span><span class="x">newline();</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="w">			</span><span class="o">|</span><span class="w">	</span><span class="s">&#39;\n&#39;</span><span class="w"> </span><span class="p">{</span><span class="x">newline();</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="w">			</span><span class="o">|</span><span class="w">	</span><span class="o">~(</span><span class="s">&#39;*&#39;</span><span class="o">|</span><span class="s">&#39;\n&#39;</span><span class="o">|</span><span class="s">&#39;\r&#39;</span><span class="o">)</span><span class="w">
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="w">		</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="w">		</span><span class="s">&#34;*/&#34;</span><span class="w">
</span></span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="w">		</span><span class="p">{</span><span class="nv">$setType</span><span class="x">(Token.SKIP);</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>This rule says the following:</p>
<ul>
<li>Match <code>/*</code> to start a comment</li>
<li>Keep looping through stuff inside a comment:
<ul>
<li>
<p>match <code>'*'</code> as long as it's not followed by <code>'/'</code></p>
<p>NOTE: This subrule uses a <em>semantic predicate.</em> We'll talk about these more later on, so don't worry too much about what the <code>{LA(2) != '/'}?</code> means.  For now, just read it as &quot;if the <em>second</em> character down the input stream is <em>not</em> a <code>'/'</code>, the following alternative (<code>'*'</code>) is eligible to match.)</p>
</li>
<li>
<p>match any of the end-of-line indicators.  Note that we must perform the <em>same</em> action we would when we see end-of-line in any other context.  In our recognizer, that action is to simply call the <code>newline()</code> method.</p>
</li>
<li>
<p>match <em>anything</em> other than a newline() or <code>\*</code>.  This may <em>seem</em> redundant, but if you <em>don't</em> specify this explicitly, ANTLR will compare it to the previous two rules and report an ambiguity.  This is necessary because based on looking at the next character in the input stream, the scanner wouldn't be able to decide whether to match an end-of-line sequence in the second or third alternative.</p>
</li>
</ul>
</li>
<li>Match <code>*/</code> to end the comment</li>
</ul>
<p>Note the use of the <code>( )*</code> construct.  This is called a <em>star closure</em>, and is used to perform looping in a grammar rule.  The <em>star closure</em> will match <em>zero or more</em> of whatever is contained within its parenthesis.</p>
<hr>
<h4 id="literals-1">Literals</h4>
<p>In XL, there are three types of literals: <code>Integer</code>, <code>Character</code> and <code>String</code>.</p>
<p><strong>Integer literals</strong> are simple -- they are just a series of digits.  Just so we can demonstrate a <code>protected</code> scanner rule, we'll start out by defining what a <code>DIGIT</code> is:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">protected</span><span class="w"> </span><span class="nl">DIGIT</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#39;0&#39;</span><span class="o">..</span><span class="s">&#39;9&#39;</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>Because this rule is marked <code>protected</code>, we will not get a <code>DIGIT</code> token returned to the parser;  <code>DIGIT</code> is never directly called from the <code>nextToken()</code> method.</p>
<p>Now that we have a helper method that defines what an integer digit is, we'll define an <code>INTLIT</code> (integer literal):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">INTLIT</span><span class="w"> 
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="o">(</span><span class="no">DIGIT</span><span class="o">)+</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>This rule means &quot;an <code>INTLIT</code> is composed of one or more <code>DIGIT</code>s&quot;.   Note that we do not set the token type to <code>Token.SKIP</code> this time. This means that is an <code>INTLIT</code> scanner rule is matched while looking at the characters in the input, an <code>INTLIT</code> token will be returned to the parser, via the <code>nextToken()</code> method.</p>
<p>Note that this will result in the generated INTLIT scanner rule <em>calling</em> the generated DIGIT scanner rule.  A slightly more efficient approach would be to define the INTLIT rule as follows:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">INTLIT</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="err">0</span><span class="s">&#39;..&#39;</span><span class="err">9&#39;</span><span class="o">)+</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">   
</span></span></span></code></pre></div><p>Our final code will use the first, less-efficient method, just to show use of the <code>protected</code> keyword.</p>
<p><strong>Character literals</strong> as fairly simple as well:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">CHARLIT</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#39;\&#39;&#39;</span><span class="o">!</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="s">&#39;\&#39;&#39;</span><span class="o">!</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>Basically, an apostrophe followed by any character, followed by another apostrophe. In the grammar, we will use <code>CHARLIT</code> to refer to a character literal.  The &quot;any character&quot; is represented by an unquoted period/dot in the rule.</p>
<p>But notice the exclamation marks (<code>!</code>) after the single quotes?  This means, toss these characters away when building the token's string value.  When a CHARLIT token is returned to the parser, its text will <em>only</em> be the single character that was contained within the single-quotes.</p>
<p><strong>String literals</strong> are very similar.  The trick is to decide what ends a string literal.  We defined string literals as being all text within double-quotes, <em>but</em> the entire literal must be on one line in the source file.  This results in the following scanner rule:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="nl">STRING_LITERAL</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#39;&#34;&#39;</span><span class="o">!</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="w">		</span><span class="o">(</span><span class="w">	</span><span class="s">&#39;&#34;&#39;</span><span class="w"> </span><span class="s">&#39;&#34;&#39;</span><span class="o">!</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="w">		</span><span class="o">|</span><span class="w">	</span><span class="o">~(</span><span class="s">&#39;&#34;&#39;</span><span class="o">|</span><span class="s">&#39;\n&#39;</span><span class="o">|</span><span class="s">&#39;\r&#39;</span><span class="o">)</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="w">		</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="w">		</span><span class="o">(</span><span class="w">	</span><span class="s">&#39;&#34;&#39;</span><span class="o">!</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="w">		</span><span class="o">|</span><span class="w">	</span><span class="c">// nothing -- write error message</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="w">		</span><span class="o">)</span><span class="w">
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>First, we enter a string when we see a double quote.</p>
<p>What can we see inside a string? Remember, from the spec, two double-quotes is a literal double quote. So we match them.  However, we only want <em>one</em> of them in the resulting string literal.  So we suffix on of the two double-quote characters with another exclamation mark (<code>!</code>). This says &quot;match, but toss out the second double-quote&quot;.)</p>
<p>But what if we see an end-of-line inside a string? This is illegal, so we'll assume it ends the string.  It will <em>not</em> be matched as part of the contained characters, and will cause an exit of the <code>( )*</code> subrule.</p>
<p>After we get out of the <code>( )*</code> string body, we have a subrule that checks to see if we can match a closing double-quote or not.  If we match it, we have a value string.  If we don't match it, it can only be because we found end-of-line within the string.  We'll allow this (the empty alternative commented &quot;nothing&quot;) but we'll probably want to write an error message saying &quot;String termninated by end-of-line&quot;.</p>
<p>Finally, note that we use exclamation marks after the opening and closing quotes of the string.  This removes them from the string literal text represented by the token.</p>
<hr>
<h4 id="keywords">Keywords</h4>
<p>XL reserves all keywords -- I may add later what to do with unreserved keywords (for evil languages like PL/1 -- hey! I <em>like</em> to program in PL/1, but I'd hate to write that compiler!)</p>
<p>There are several ways to implement keywords. The simplest is to just directly specify them in the parser grammar.  ANTLR 2.x provides better support for string literals in a grammar than PCCTS 1.33 did.  If you specified a string literal in a PCCTS 1.33 grammar, there was no way to refer to that token when walking through a generated AST (Abstract Syntax Tree).  ANTLR 2.x solves that problem by defining a special token name for each literal in the parser grammar.  For example, a string literal <code>&quot;end&quot;</code> specified in the grammar will be represented by a token named <code>LITERAL_end</code>.   You can use the name <code>LITERAL_end</code> in a tree-walker grammar to refer to that matched literal <code>&quot;end&quot;</code>.</p>
<p>Any literals you specify in the parser will be inserted into a nifty little hash table.   You'll need to make the scanner aware that the hash table is being used so it can perform lookups in that table for keyword matches.  We'll discuss this when we talk about indentifiers.</p>
<hr>
<h4 id="operators-1">Operators</h4>
<p>XL defines several operators, and we'll define them as well... These definitions are <em>very</em> straightforward.  Just assign a scanner rule name to match the text.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="nl">DOT</span><span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;.&#39;</span><span class="w">   </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="w"></span><span class="nl">BECOMES</span><span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="s">&#34;:=&#34;</span><span class="w">  </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="w"></span><span class="nl">COLON</span><span class="w">      </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;:&#39;</span><span class="w">   </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="w"></span><span class="nl">SEMI</span><span class="w">       </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;;&#39;</span><span class="w">   </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="w"></span><span class="nl">COMMA</span><span class="w">      </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;,&#39;</span><span class="w">   </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="w"></span><span class="nl">EQUALS</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;=&#39;</span><span class="w">   </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="w"></span><span class="nl">LBRACKET</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;[&#39;</span><span class="w">   </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="w"></span><span class="nl">RBRACKET</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;]&#39;</span><span class="w">   </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="w"></span><span class="nl">DOTDOT</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class="s">&#34;..&#34;</span><span class="w">  </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="w"></span><span class="nl">LPAREN</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;(&#39;</span><span class="w">   </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="w"></span><span class="nl">RPAREN</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;)&#39;</span><span class="w">   </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="w"></span><span class="nl">NOT</span><span class="err">\_EQUALS</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">&#34;/=&#34;</span><span class="w"> </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="w"></span><span class="nl">LT</span><span class="w">         </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;&lt;&#39;</span><span class="w">   </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="w"></span><span class="nl">LTE</span><span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="s">&#34;&lt;=&#34;</span><span class="w">  </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="w"></span><span class="nl">GT</span><span class="w">         </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;&gt;&#39;</span><span class="w">   </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="w"></span><span class="nl">GTE</span><span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="s">&#34;&gt;=&#34;</span><span class="w">  </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="w"></span><span class="nl">PLUS</span><span class="w">       </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;+&#39;</span><span class="w">   </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="w"></span><span class="nl">MINUS</span><span class="w">      </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;-&#39;</span><span class="w">   </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="w"></span><span class="nl">TIMES</span><span class="w">      </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;*&#39;</span><span class="w">   </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="w"></span><span class="nl">DIV</span><span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;/&#39;</span><span class="w">   </span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>Note that some of these tokens have common prefixes.  For example, <code>GT</code> and <code>GTE</code> both start with character <code>'&gt;'</code>.  In a Deterministic Finite Automata (DFA)-based scanner, this would not be an issue, as it would try to match the longest possible token.</p>
<p>In a recursive-descent scanner, this is a big issue.  There are two ways to handle this situation:</p>
<ul>
<li>Left-factor the rules in question.</li>
<li>Increase the lookahead characters.</li>
</ul>
<p>Taking the first approach, left factoring, would require that we define a rule to deal with <code>GT</code> and <code>GTE</code> as follows:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">GT</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#39;&gt;&#39;</span><span class="w">  </span><span class="o">(</span><span class="s">&#39;=&#39;</span><span class="w"> </span><span class="p">{</span><span class="nv">$setType</span><span class="x">(GTE);</span><span class="p">}</span><span class="o">)?</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">   
</span></span></span></code></pre></div><p>This rule says &quot;match the <code>'&gt;'</code> character.  Then, if I see <code>'='</code> as the next character. match it.&quot;  The &quot;trick&quot; here is that the &quot;normal&quot; completion of the rule defines the resulting token as the <em>name of the rule</em>, which is <code>GT</code> in this case.  If we match the <em>optional subrule</em> <code>('=')?</code>, where the <code>( )?</code> defines its contents as optional, we execute the <code>$setType(GTE);</code> statement, which <em>changes</em> the type of the token to <code>GTE</code>.</p>
<p>Taking the second approach only involves setting the lookahead amount to a higher number.  This means that we can have the scanner check the next two characters to make a decision, instead of just the first character.  Checking the next two characters in the input stream allows the scanner to correct decide if it should choose to match the <code>GT</code> rule or the <code>GTE</code> rule.  You can specify a higher lookahead value in the scanner as follows:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">options</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="nv">k</span><span class="p">=</span>2<span class="p">;</span><span class="w"> </span><span class="c">// two characters of lookahead</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">   
</span></span></span></code></pre></div><p>immediately after defining the scanner.  We'll see how the scanner is defined in a moment.  It is important to think carefully whether you want to increase the lookahead amount.  While it may make the grammar simpler, it could also slow it down.   In addition, if you do not carefully study the conflicts and understand them, and simply raise the lookahead amount, you may be masking a real problem.  Try to keep lookahead as low as possible, and <em>always</em> try generating your compiler with <code>k=1</code> first.  Make sure you understand what is causing the conflicts, and if you feel certain, and the conflicts are all similar to the <code>GT</code>/<code>GTE</code> conflict above, raise the lookahead value.</p>
<hr>
<h4 id="identifiers-1">Identifiers</h4>
<p>Finally, we talk about identifiers. Basically, they are any sequence of letters and digits that's left. So we get a regular expression like:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">IDENT</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="o">(</span><span class="s">&#39;a&#39;</span><span class="o">..</span><span class="s">&#39;z&#39;</span><span class="o">|</span><span class="s">&#39;A&#39;</span><span class="o">..</span><span class="s">&#39;Z&#39;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="s">&#39;a&#39;</span><span class="o">..</span><span class="s">&#39;z&#39;</span><span class="o">|</span><span class="s">&#39;A&#39;</span><span class="o">..</span><span class="s">&#39;Z&#39;</span><span class="o">|</span><span class="s">&#39;0&#39;</span><span class="o">..</span><span class="s">&#39;9&#39;</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">   
</span></span></span></code></pre></div><p>Very simple. Note that there is no action code here, especially not any that would perform symbol table lookup. I'm very adamant in pushing my view that scanner to parser communication should be a one-way street. This is especially important in multiple-lookahead parsers. If your parser decides when to push and pop scope (a likely scenario), and your scanner is reading two or more tokens ahead, you may be looking at a token in the scanner before its proper scope was pushed or popped. In addition, things like semantic predicates let you make more pointed decisions about how to parse identifiers in the grammar, rather than changing the token type in the scanner.</p>
<p>Think about the set of tokens that can be returned by the scanner we've defined.   Where would keywords like <code>begin</code> and <code>end</code> be matched?   In our IDENT rule!</p>
<p>We will be defining keywords within our parser, which will end up generating tokens called <code>LITERAL_begin</code> and <code>LITERAL_end</code>, for example.  Recall that these literals will be inserted in a special hash table.  To utililize this hash table, modify the IDENT rule as follows:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">IDENT</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="k">options</span><span class="w"> </span><span class="p">{</span><span class="nv">testLiterals</span><span class="p">=</span>true<span class="p">;}</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="o">(</span><span class="s">&#39;a&#39;</span><span class="o">..</span><span class="s">&#39;z&#39;</span><span class="o">|</span><span class="s">&#39;A&#39;</span><span class="o">..</span><span class="s">&#39;Z&#39;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="s">&#39;a&#39;</span><span class="o">..</span><span class="s">&#39;z&#39;</span><span class="o">|</span><span class="s">&#39;A&#39;</span><span class="o">..</span><span class="s">&#39;Z&#39;</span><span class="o">|</span><span class="s">&#39;0&#39;</span><span class="o">..</span><span class="s">&#39;9&#39;</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>Note the <code>testLiterals=true</code> option.  This generates code that will lookup a name in the literals hash table <em>if</em> the IDENT rule matches a word.   This implies that every literal you specify in the parser grammar <em>must</em> be matchable by the IDENT rule.</p>
<p>If a word such as <code>&quot;end&quot;</code> is found in the literals table, the token type will be changed to be something like <code>LITERAL_end</code> before being returned to the parser.</p>
<hr>
<h4 id="putting-the-lexical-elements-together">Putting the Lexical Elements Together</h4>
<p>What do we have so far? Let's look at it in one lump, shall we?</p>
<p>But first, we need to tell ANTLR that we're creating a scanner and specify a new options (such as lookahead):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c">//---------------</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="w"></span><span class="c">// The XL scanner</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="w"></span><span class="c">//---------------</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="w"></span><span class="nl">class</span><span class="w"> </span><span class="err">XLLexer</span><span class="w"> </span><span class="err">extends</span><span class="w"> </span><span class="err">Lexer;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="w"></span><span class="k">options</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="w">	</span><span class="err">charVocabulary</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">&#39;\0&#39;..&#39;\377&#39;;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="w">	</span><span class="nv">testLiterals</span><span class="p">=</span>false<span class="p">;</span><span class="w">    </span><span class="c">// don&#39;t automatically test for literals</span><span class="w">
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="w">	</span><span class="nv">k</span><span class="p">=</span>2<span class="p">;</span><span class="w">                   </span><span class="c">// two characters of lookahead</span><span class="w">
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">   
</span></span></span></code></pre></div><p>First, we specify that we are creating a scanner called <code>XLLexer</code>, subclassing the <code>Lexer</code> class.  <code>Lexer</code> is an abstract class that defines the basis for an ANTLR-generated scanner.  (You can define scanners that subclass other scanners that you have defined, but that is outside the scope of this tutorial.  Please see the ANTLR documentation at <a href="http://www.antlr.org/">http://www.antlr.org/</a> for details.)</p>
<p>Next we specify four options.  These are:</p>
<ul>
<li>
<p><code>charVocabulary = '\0'..'\377';</code><br>
This defines the valid set of characters than can be recognized by the ANTLR scanner.   This is necessary to match expresions like <code>~'a'</code> in a scanner rule.   We need to know what the other possible characters are...<br>
Also - the characters mentioned in the charVocabulary are the <em>only</em> characters that will be allowed in the source input.  Any character encountered that is not in the charVocabulary will be flagged as invalid.  The range we specify above is the entire UNICODE character set.</p>
</li>
<li>
<p><code>testLiterals=false;</code><br>
Specifies that by default we do not want all rules to check the literals table for possible matches.  Only rules that have their own testLiterals option will perform that lookup.</p>
</li>
<li>
<p><code>k=2;</code><br>
This specifies that the scanner will look at the next two characters of the input stream to determine which alternative to choose.  The extra lookahead is only used when actually necessary to disambiguate.</p>
</li>
</ul>
<p>After specifying the name and options for the scanner, we specify the rules.  The following is our entire scanner:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c">//----------------------------------------------------------------------------</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="w"></span><span class="c">// The XL scanner</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="w"></span><span class="c">//----------------------------------------------------------------------------</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="w"></span><span class="nl">class</span><span class="w"> </span><span class="err">XLLexer</span><span class="w"> </span><span class="err">extends</span><span class="w"> </span><span class="err">Lexer;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="w"></span><span class="k">options</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="w">	</span><span class="err">charVocabulary</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">&#39;\0&#39;..&#39;\377&#39;;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="w">	</span><span class="nv">testLiterals</span><span class="p">=</span>false<span class="p">;</span><span class="w">    </span><span class="c">// don&#39;t automatically test for literals</span><span class="w">
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="w">	</span><span class="nv">k</span><span class="p">=</span>2<span class="p">;</span><span class="w">                   </span><span class="c">// two characters of lookahead</span><span class="w">
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="w"></span><span class="c">// Single-line comments</span><span class="w">
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="w"></span><span class="err">COMMENT</span><span class="w">
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;//&#34;</span><span class="w"> </span><span class="o">(~(</span><span class="s">&#39;\n&#39;</span><span class="o">|</span><span class="s">&#39;\r&#39;</span><span class="o">))*</span><span class="w">
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="w">		</span><span class="p">{</span><span class="x"> </span><span class="nv">$setType</span><span class="x">(Token.SKIP); </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="w"></span><span class="c">// Literals</span><span class="w">
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="w"></span><span class="k">protected</span><span class="w"> </span><span class="nl">DIGIT</span><span class="w">
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#39;0&#39;</span><span class="o">..</span><span class="s">&#39;9&#39;</span><span class="w">
</span></span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="w"></span><span class="nl">INTLIT</span><span class="w"> 
</span></span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="o">(</span><span class="no">DIGIT</span><span class="o">)+</span><span class="w">
</span></span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="w"></span><span class="nl">CHARLIT</span><span class="w">
</span></span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#39;\&#39;&#39;</span><span class="o">!</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="s">&#39;\&#39;&#39;</span><span class="o">!</span><span class="w">
</span></span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">31</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">32</span><span class="cl"><span class="w"></span><span class="c">// string literals</span><span class="w">
</span></span></span><span class="line"><span class="ln">33</span><span class="cl"><span class="w"></span><span class="nl">STRING_LITERAL</span><span class="w">
</span></span></span><span class="line"><span class="ln">34</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#39;&#34;&#39;</span><span class="o">!</span><span class="w">
</span></span></span><span class="line"><span class="ln">35</span><span class="cl"><span class="w">		</span><span class="o">(</span><span class="w">	</span><span class="s">&#39;&#34;&#39;</span><span class="w"> </span><span class="s">&#39;&#34;&#39;</span><span class="o">!</span><span class="w">
</span></span></span><span class="line"><span class="ln">36</span><span class="cl"><span class="w">		</span><span class="o">|</span><span class="w">	</span><span class="o">~(</span><span class="s">&#39;&#34;&#39;</span><span class="o">|</span><span class="s">&#39;\n&#39;</span><span class="o">|</span><span class="s">&#39;\r&#39;</span><span class="o">)</span><span class="w">
</span></span></span><span class="line"><span class="ln">37</span><span class="cl"><span class="w">		</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">38</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">39</span><span class="cl"><span class="w">		</span><span class="o">(</span><span class="w">	</span><span class="s">&#39;&#34;&#39;</span><span class="o">!</span><span class="w">
</span></span></span><span class="line"><span class="ln">40</span><span class="cl"><span class="w">		</span><span class="o">|</span><span class="w">	</span><span class="c">// nothing -- write error message</span><span class="w">
</span></span></span><span class="line"><span class="ln">41</span><span class="cl"><span class="w">		</span><span class="o">)</span><span class="w">
</span></span></span><span class="line"><span class="ln">42</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">43</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">44</span><span class="cl"><span class="w"></span><span class="c">// Whitespace -- ignored</span><span class="w">
</span></span></span><span class="line"><span class="ln">45</span><span class="cl"><span class="w"></span><span class="nl">WS</span><span class="w">
</span></span></span><span class="line"><span class="ln">46</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="o">(</span><span class="w">	</span><span class="s">&#39; &#39;</span><span class="w">
</span></span></span><span class="line"><span class="ln">47</span><span class="cl"><span class="w">		</span><span class="o">|</span><span class="w">	</span><span class="s">&#39;\t&#39;</span><span class="w">
</span></span></span><span class="line"><span class="ln">48</span><span class="cl"><span class="w">		</span><span class="o">|</span><span class="w">	</span><span class="s">&#39;\f&#39;</span><span class="w">
</span></span></span><span class="line"><span class="ln">49</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">50</span><span class="cl"><span class="w">		</span><span class="c">// handle newlines</span><span class="w">
</span></span></span><span class="line"><span class="ln">51</span><span class="cl"><span class="w">		</span><span class="o">|</span><span class="w">	</span><span class="o">(</span><span class="w">	</span><span class="s">&#34;\r\n&#34;</span><span class="w">  </span><span class="c">// DOS/Windows</span><span class="w">
</span></span></span><span class="line"><span class="ln">52</span><span class="cl"><span class="w">			</span><span class="o">|</span><span class="w">	</span><span class="s">&#39;\r&#39;</span><span class="w">    </span><span class="c">// Macintosh</span><span class="w">
</span></span></span><span class="line"><span class="ln">53</span><span class="cl"><span class="w">			</span><span class="o">|</span><span class="w">	</span><span class="s">&#39;\n&#39;</span><span class="w">    </span><span class="c">// Unix</span><span class="w">
</span></span></span><span class="line"><span class="ln">54</span><span class="cl"><span class="w">			</span><span class="o">)</span><span class="w">
</span></span></span><span class="line"><span class="ln">55</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">56</span><span class="cl"><span class="w">			</span><span class="c">// increment the line count in the scanner</span><span class="w">
</span></span></span><span class="line"><span class="ln">57</span><span class="cl"><span class="w">			</span><span class="p">{</span><span class="x"> newline(); </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">58</span><span class="cl"><span class="w">		</span><span class="o">)</span><span class="w">
</span></span></span><span class="line"><span class="ln">59</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">60</span><span class="cl"><span class="w">		</span><span class="p">{</span><span class="x"> </span><span class="nv">$setType</span><span class="x">(Token.SKIP); </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">61</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">62</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">63</span><span class="cl"><span class="w"></span><span class="c">// an identifier.  Note that testLiterals is set to true!  This means</span><span class="w">
</span></span></span><span class="line"><span class="ln">64</span><span class="cl"><span class="w"></span><span class="c">// that after we match the rule, we look in the literals table to see</span><span class="w">
</span></span></span><span class="line"><span class="ln">65</span><span class="cl"><span class="w"></span><span class="c">// if it&#39;s a literal or really an identifer</span><span class="w">
</span></span></span><span class="line"><span class="ln">66</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">67</span><span class="cl"><span class="w"></span><span class="nl">IDENT</span><span class="w">
</span></span></span><span class="line"><span class="ln">68</span><span class="cl"><span class="w">	</span><span class="k">options</span><span class="w"> </span><span class="p">{</span><span class="nv">testLiterals</span><span class="p">=</span>true<span class="p">;}</span><span class="w">
</span></span></span><span class="line"><span class="ln">69</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="o">(</span><span class="s">&#39;a&#39;</span><span class="o">..</span><span class="s">&#39;z&#39;</span><span class="o">|</span><span class="s">&#39;A&#39;</span><span class="o">..</span><span class="s">&#39;Z&#39;</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="s">&#39;a&#39;</span><span class="o">..</span><span class="s">&#39;z&#39;</span><span class="o">|</span><span class="s">&#39;A&#39;</span><span class="o">..</span><span class="s">&#39;Z&#39;</span><span class="o">|</span><span class="s">&#39;0&#39;</span><span class="o">..</span><span class="s">&#39;9&#39;</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">70</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">71</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">72</span><span class="cl"><span class="w"></span><span class="c">// Operators</span><span class="w">
</span></span></span><span class="line"><span class="ln">73</span><span class="cl"><span class="w"></span><span class="nl">DOT</span><span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;.&#39;</span><span class="w">   </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">74</span><span class="cl"><span class="w"></span><span class="nl">BECOMES</span><span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="s">&#34;:=&#34;</span><span class="w">  </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">75</span><span class="cl"><span class="w"></span><span class="nl">COLON</span><span class="w">      </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;:&#39;</span><span class="w">   </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">76</span><span class="cl"><span class="w"></span><span class="nl">SEMI</span><span class="w">       </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;;&#39;</span><span class="w">   </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">77</span><span class="cl"><span class="w"></span><span class="nl">COMMA</span><span class="w">      </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;,&#39;</span><span class="w">   </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">78</span><span class="cl"><span class="w"></span><span class="nl">EQUALS</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;=&#39;</span><span class="w">   </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">79</span><span class="cl"><span class="w"></span><span class="nl">LBRACKET</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;[&#39;</span><span class="w">   </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">80</span><span class="cl"><span class="w"></span><span class="nl">RBRACKET</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;]&#39;</span><span class="w">   </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">81</span><span class="cl"><span class="w"></span><span class="nl">DOTDOT</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class="s">&#34;..&#34;</span><span class="w">  </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">82</span><span class="cl"><span class="w"></span><span class="nl">LPAREN</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;(&#39;</span><span class="w">   </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">83</span><span class="cl"><span class="w"></span><span class="nl">RPAREN</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;)&#39;</span><span class="w">   </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">84</span><span class="cl"><span class="w"></span><span class="nl">NOT_EQUALS</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">&#34;/=&#34;</span><span class="w">  </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">85</span><span class="cl"><span class="w"></span><span class="nl">LT</span><span class="w">         </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;&lt;&#39;</span><span class="w">   </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">86</span><span class="cl"><span class="w"></span><span class="nl">LTE</span><span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="s">&#34;&lt;=&#34;</span><span class="w">  </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">87</span><span class="cl"><span class="w"></span><span class="nl">GT</span><span class="w">         </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;&gt;&#39;</span><span class="w">   </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">88</span><span class="cl"><span class="w"></span><span class="nl">GTE</span><span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="s">&#34;&gt;=&#34;</span><span class="w">  </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">89</span><span class="cl"><span class="w"></span><span class="nl">PLUS</span><span class="w">       </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;+&#39;</span><span class="w">   </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">90</span><span class="cl"><span class="w"></span><span class="nl">MINUS</span><span class="w">      </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;-&#39;</span><span class="w">   </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">91</span><span class="cl"><span class="w"></span><span class="nl">TIMES</span><span class="w">      </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;*&#39;</span><span class="w">   </span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">92</span><span class="cl"><span class="w"></span><span class="nl">DIV</span><span class="w">        </span><span class="p">:</span><span class="w"> </span><span class="s">&#39;/&#39;</span><span class="w">   </span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>Let's move on to the parser grammar.</p>
<h2 id="the-parser">The Parser</h2>
<p>Now we'll look at a parser grammar for XL. Note that we are building just a recognizer at this state, and the grammar may (and will!) change.</p>
<p>Let's start at the top, shall we?</p>
<h3 id="program-specification">Program Specification</h3>
<p>XL has one program per file, so this is really our starting rule.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">program</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;program&#34;</span><span class="w"> </span><span class="no">IDENT</span><span class="w"> </span><span class="no">EQUALS</span><span class="w"> 
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">			</span><span class="nv">subprogramBody</span><span class="w"> 
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">		</span><span class="no">DOT</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w">		</span><span class="c">// end-of-file</span><span class="w">
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>Pretty straightforward. Note that so far, we don't care that we are <strong>definitely</strong> declaring that <code>IDENT</code> here. We will later, though...</p>
<hr>
<h3 id="subprogram-bodies">Subprogram Bodies</h3>
<p>A subprogram body is a little (or big) block of code that makes up the &quot;what I do&quot; part of a program, procedure, or function. It's not bad to define, but it will get a bit tricker later. Well, not too much so.</p>
<pre><code>subprogramBody
	:	(basicDecl)*
		(procedureDecl)*
		&quot;begin&quot;
			(statement)*
		&quot;end&quot; IDENT
	;
</code></pre>
<p>So what is it? Basically, define your local variables, types and constants (<code>basicDecls</code>). There can be zero or more of these, hence the use of the <code>( )*</code> closure. Then, define any nested procedures or functions. Again, zero or more of these. Finally, we get to the definition of what the current program/procedure/function does. This starts with a &quot;begin&quot;, has zero or more statements in it, and is ended by &quot;end&quot; <code>IDENT</code>. Note that the XL spec stated that the identifer that ends a subroutine must match the beginning one. Right now, we have no way of doing that, as the name for the subroutine is outside the scope of this rule. We'll handle this later, though, and in a pretty neat way I must say. Yacc can't hold a candle to it, you'll see!</p>
<p>Note that the XL spec said nothing about &quot;procedures must be declared after vars, consts and types.&quot; This was one of the many things that the language designer told us during midnight interrogation... Similar to Pascal's definition order (<code>CONST</code> <code>TYPE</code> <code>VAR</code> <code>FUNCTION</code>/<code>PROCEDURE</code>) but not quite that rigid.</p>
<hr>
<h3 id="basic-declarations">Basic Declarations</h3>
<p>XL has three main declarations: variables, constants, and types:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">basicDecl</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">varDecl</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">constDecl</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">typeDecl</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>Just so this section isn't so short, I'll define <code>varDecl</code> and <code>constDecl</code> here.</p>
<p>A variable declaration looks like:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">varDecl</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;var&#34;</span><span class="w"> </span><span class="nv">identList</span><span class="w"> </span><span class="no">COLON</span><span class="w"> </span><span class="nv">typeName</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">		</span><span class="o">(</span><span class="no">BECOMES</span><span class="w"> </span><span class="nv">constantValue</span><span class="o">)?</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">		</span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>Unlike Pascal, each declaration must start with &quot;var&quot;; there is no &quot;VAR section&quot; that starts with the keyword VAR. The <code>varDecl</code> states that you can defined any number of idents at once, and you can optionally initialize the variable(s).</p>
<p>A constant declaration is similar to a variable declaration, except that you use the keyword &quot;constant&quot; and must assign a value:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">constDecl</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;constant&#34;</span><span class="w"> </span><span class="nv">identList</span><span class="w"> </span><span class="no">COLON</span><span class="w"> </span><span class="nv">typeName</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">		</span><span class="no">BECOMES</span><span class="w"> </span><span class="nv">constantValue</span><span class="w"> </span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>In the above rules, subrules <code>identList</code> and <code>constantValue</code> are mentioned. These are:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">identList</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="no">IDENT</span><span class="w"> </span><span class="o">(</span><span class="no">COMMA</span><span class="w"> </span><span class="no">IDENT</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>which says &quot;one or more <code>IDENT</code>s separated by <code>COMMA</code>s&quot;, and</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">constantValue</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="no">INTLIT</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="no">STRING_LITERAL</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="no">IDENT</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>which is pretty self-explanatory. One thing to note, though, there there is nothing right now that prevents us from using a variable <code>IDENT</code> instead of a constant <code>IDENT</code>. That's handled later...</p>
<hr>
<h3 id="type-declarations">Type Declarations</h3>
<p>XL defines three user-defined types: arrays, records and enumeration types. In my project, I only defined arrays and records, so for now, I'll skip enumeration types. I may add them at another time.</p>
<p>A type declaration is either an array declaration or a record declaration:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">typeDecl</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;type&#34;</span><span class="w"> </span><span class="no">IDENT</span><span class="w"> </span><span class="no">EQUALS</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">		</span><span class="o">(</span><span class="w">	</span><span class="nv">arrayDecl</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">		</span><span class="o">|</span><span class="w">	</span><span class="nv">recordDecl</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w">		</span><span class="o">)</span><span class="w">
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="w">		</span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>I got a bit fancier here by using a subrule to say &quot;array or record&quot; instead of defining a new rule for it. This is also a bit more efficient than the extra function call created by another rule there. Basic rule of thumb -- if a subrule is clear, and not deeply nested, feel free to use it. However, watch out for using several nested subrules, as the meaning can get hidden quickly.</p>
<p>Arrays are defined as <code>ARRAY [x..y] OF type</code>. Only one-dimensional, pretty simple:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">arrayDecl</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;array&#34;</span><span class="w"> </span><span class="no">LBRACKET</span><span class="w"> </span><span class="nv">integerConstant</span><span class="w"> </span><span class="no">DOTDOT</span><span class="w"> </span><span class="nv">integerConstant</span><span class="w"> </span><span class="no">RBRACKET</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">		</span><span class="s">&#34;of&#34;</span><span class="w"> </span><span class="nv">typeName</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="w"></span><span class="nl">integerConstant</span><span class="w">
</span></span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="no">INTLIT</span><span class="w">
</span></span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="no">IDENT</span><span class="w"> </span><span class="c">// again, a constant...</span><span class="w">
</span></span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>Records are defined as <code>RECORD x,y,z:typename; END RECORD.</code> Again, simple until we have to know what it means:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">recordDecl</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;record&#34;</span><span class="w"> </span><span class="o">(</span><span class="nv">identList</span><span class="w"> </span><span class="no">COLON</span><span class="w"> </span><span class="nv">typeName</span><span class="w"> </span><span class="no">SEMI</span><span class="o">)+</span><span class="w"> </span><span class="s">&#34;end&#34;</span><span class="w"> </span><span class="s">&#34;record&#34;</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>So what is this <code>typeName</code> I keep bringing up? Well, it's either one of the predefined types, <code>Integer</code> or <code>Boolean</code>, or it's a user-defined type (which means its an <code>IDENT</code>), so:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">typeName</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="no">IDENT</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="s">&#34;Integer&#34;</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="s">&#34;Boolean&#34;</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>Enough about types, now, on to</p>
<hr>
<h3 id="procedure-declarations">Procedure Declarations</h3>
<p>A procedure in XL is similar to a program, so basically, it's a small heading followed by a <code>subprogramBody</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">procedureDecl</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;procedure&#34;</span><span class="w"> </span><span class="no">IDENT</span><span class="w"> </span><span class="o">(</span><span class="nv">formalParameters</span><span class="o">)?</span><span class="w"> </span><span class="no">EQUALS</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">		</span><span class="nv">subprogramBody</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">		</span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>At the time I originally did this project, I only did procedures, not functions. Perhaps I'll add them later... (You may think &quot;boy he left a lot out,&quot; but Dr. Moore made a large subset of the project required, and I did a few extra point things, but not the whole thing. I <em>was</em> working full-time you know...)</p>
<p>Notice that the <code>formalParameters</code> are optional... Let's define what they look like:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">formalParameters</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="no">LPAREN</span><span class="w"> </span><span class="nv">parameterSpec</span><span class="w"> </span><span class="o">(</span><span class="no">SEMI</span><span class="w"> </span><span class="nv">parameterSpec</span><span class="o">)*</span><span class="w"> </span><span class="no">RPAREN</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>Again we see the familiar <code>x (COMMA x)</code> notation -- the ()* closure is very handy and efficient for matching lists of things...</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">parameterSpec</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="o">(</span><span class="s">&#34;var&#34;</span><span class="o">)?</span><span class="w"> </span><span class="nv">identList</span><span class="w"> </span><span class="no">COLON</span><span class="w"> </span><span class="nv">typeName</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>You'll notice that this is quite a bit like a variable declaration, except that <code>VAR</code> is optional, and there's no semicolon after it. We'll handle it a bit differently as well, once we add action code.</p>
<p>Next, we'll look at...</p>
<h2 id="statements-1">Statements</h2>
<p>There are seven statements in XL (I told you it was a small language): assignment, exit, procedure call, return, if-then, loop and I/O.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="nl">statement</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">exitStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">returnStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">ifStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">loopStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">ioStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">procedureCallStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">assignmentStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">endStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><h3 id="assignment-statement-1">Assignment Statement</h3>
<p>The assignment statement is pretty much like Pascal's assignment statement, except that there are no type conversions allowed.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">assignmentStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">variableReference</span><span class="w"> </span><span class="no">BECOMES</span><span class="w"> </span><span class="nv">expression</span><span class="w"> </span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>Very simple, but the pieces (variable and expression) are somewhat complex -- we'll look at them after all the statements are done. We'll look at <code>variableReference</code> later...</p>
<hr>
<h3 id="exit-statement">Exit Statement</h3>
<p>The exit statement tells a loop it's done. It looks like</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">exitStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;exit&#34;</span><span class="w"> </span><span class="s">&#34;when&#34;</span><span class="w"> </span><span class="nv">expression</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><h3 id="procedure-call-statement">Procedure Call Statement</h3>
<p>A procedure call takes the form</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">procedureCallStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="no">IDENT</span><span class="w"> </span><span class="o">(</span><span class="nv">actualParameters</span><span class="o">)?</span><span class="w"> </span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w"></span><span class="nl">actualParameters</span><span class="w">
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="no">LPAREN</span><span class="w"> </span><span class="o">(</span><span class="nv">expression</span><span class="w"> </span><span class="o">(</span><span class="no">COMMA</span><span class="w"> </span><span class="nv">expression</span><span class="o">)*)?</span><span class="w"> </span><span class="no">RPAREN</span><span class="w">
</span></span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>I extended XL just a bit for this. The original XL compiler I wrote had</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">actualParameters</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="no">LPAREN</span><span class="w"> </span><span class="nv">expression</span><span class="w"> </span><span class="o">(</span><span class="no">COMMA</span><span class="w"> </span><span class="nv">expression</span><span class="o">)*</span><span class="w"> </span><span class="no">RPAREN</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>which basically means that if you have parens, you <strong>must</strong> have at least one expression in them. I thought it would be nice to allow <code>myfunc()</code> as a valid procedure call.</p>
<hr>
<h3 id="return-statement">Return Statement</h3>
<p>The XL return statement tells a procedure or function to return immediately. Keeping in mind that I did not implement functions (yet, at least), <code>return</code> cannot take an expression argument. Therefore, it's just</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">returnStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;return&#34;</span><span class="w"> </span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><h3 id="if-statement-1">If Statement</h3>
<p>The XL &quot;if-then-elsif-else-end if&quot; statement is a fairly simple <code>if</code> type statement. This is because it is defined as a closed <code>if</code> statement; that is, there is a definite &quot;I'm done&quot; part to the <code>if</code> statement. Those of you who are familiar with the &quot;dangling <code>else</code>&quot; conflict present in the C language may realize that if you close the <code>if</code> statement, the conflict disappears. First, I'll present the rule for XL, then I'll talk a bit about how to do the <code>if</code> statement for C.</p>
<p>XL's <code>if</code> statement looks like:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">ifStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;if&#34;</span><span class="w"> </span><span class="nv">expression</span><span class="w"> </span><span class="s">&#34;then&#34;</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">		</span><span class="o">(</span><span class="w"> </span><span class="nv">statement</span><span class="w"> </span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">		</span><span class="o">(</span><span class="w">	</span><span class="s">&#34;elsif&#34;</span><span class="w"> </span><span class="nv">expression</span><span class="w"> </span><span class="s">&#34;then&#34;</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w">			</span><span class="o">(</span><span class="w"> </span><span class="nv">statement</span><span class="w"> </span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="w">		</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="w">		</span><span class="o">(</span><span class="w"> </span><span class="s">&#34;else&#34;</span><span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="nv">statement</span><span class="w"> </span><span class="o">)*</span><span class="w"> </span><span class="o">)?</span><span class="w">
</span></span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="w">		</span><span class="s">&#34;end&#34;</span><span class="w"> </span><span class="s">&#34;if&#34;</span><span class="w"> </span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>Which is the most straightforward way to write the rule. However, you may notice some redundancy in the rule -- there are two separate places where we'll need to deal with <code>expression</code> evaluation. Not a big deal now, but we'd need to duplicate code later. After staring at the rule for a bit, we might try splitting out the &quot;<code>expression</code> THEN possible ELSE&quot; stuff into a separate rule, and call it recursively if we get an ELSIF. In other words:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="nl">ifStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;if&#34;</span><span class="w"> </span><span class="nv">ifPart</span><span class="w"> </span><span class="s">&#34;end&#34;</span><span class="w"> </span><span class="s">&#34;if&#34;</span><span class="w"> </span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="w"></span><span class="nl">ifPart</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">expression</span><span class="w"> </span><span class="s">&#34;then&#34;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="w">		</span><span class="o">(</span><span class="nv">statement</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="w">		</span><span class="o">(</span><span class="w">	</span><span class="s">&#34;elsif&#34;</span><span class="w"> </span><span class="nv">ifPart</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="w">		</span><span class="o">|</span><span class="w">	</span><span class="s">&#34;else&#34;</span><span class="w"> </span><span class="o">(</span><span class="nv">statement</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="w">		</span><span class="o">)?</span><span class="w">
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>Which is much less redundant.</p>
<p>Earlier, I threatened to look at the &quot;dangling else&quot; problem. In ANTLR, this is an easy problem to solve. Basically, the problem is that in a statement like</p>
<pre><code>if (x)
	if (y)
		myfunc();
	else
		yourfunc();
</code></pre>
<p>It isn't terribly apparent (to the compiler at least) which <code>if</code>-condition owns the &quot;else&quot; clause. The compiler can't tell if the inner <code>if</code> is an &quot;if-without-an-else&quot; inside an &quot;if-with-an-else,&quot; or vice-versa.</p>
<p>On the other hand, the language designers decided that the else will be owned by its most recent <code>if</code> that can possibly own it. In this case, the <code>else</code> would clearly belong to the <code>(y)</code> condition. However, the compiler doesn't know this.</p>
<p>In a yacc grammar, an if-statement for C might be written</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">ifStatement
</span></span><span class="line"><span class="ln">2</span><span class="cl">	:	IF LPAREN expression RPAREN statementList
</span></span><span class="line"><span class="ln">3</span><span class="cl">	|	IF LPAREN expression RPAREN statementList
</span></span><span class="line"><span class="ln">4</span><span class="cl">		ELSE statementList
</span></span><span class="line"><span class="ln">5</span><span class="cl">	;
</span></span></code></pre></div><p>which causes yacc to report a &quot;shift/reduce&quot; conflict -- yacc can't tell if you intended to have an &quot;if-without-else&quot; (the first alternative) be nested inside an &quot;if-with-else&quot; (the second alternative.) It doesn't know if it should reduce the first alternative when it sees the ELSE, or whether it should keep looking (shift the ELSE.) Fortunately, yacc's default is to shift the else, basically grouping the ELSE with its closest IF, which is exactly what we want.</p>
<p>To get yacc to stop reporting this (and explicitly specify which alternative we intend) requires the use of either some very messy (and hard-to-follow) rules, or explicit precedence assignment. Neither is pretty, or very readable for someone else.</p>
<p>In ANTLR, the C if statement would look like</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">ifStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;if&#34;</span><span class="w"> </span><span class="no">LPAREN</span><span class="w"> </span><span class="nv">expression</span><span class="w"> </span><span class="no">RPAREN</span><span class="w"> </span><span class="o">(</span><span class="nv">statement</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">		</span><span class="o">(</span><span class="w"> </span><span class="s">&#34;else&#34;</span><span class="w"> </span><span class="o">(</span><span class="nv">statement</span><span class="o">)*</span><span class="w"> </span><span class="o">)?</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>which, of course, causes ANTLR to report a conflict. To get rid of this conflict, we can use a syntactic predicate (aka &quot;guess&quot; mode) which basically says &quot;try this -- if it works, use it. Otherwise, try the next alt.&quot;</p>
<p>Applying a nice syntactic predicate to the <code>ifStatement</code> rule above yields</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">ifStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;if&#34;</span><span class="w"> </span><span class="no">LPAREN</span><span class="w"> </span><span class="nv">expression</span><span class="w"> </span><span class="no">RPAREN</span><span class="w"> </span><span class="o">(</span><span class="nv">statement</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">		</span><span class="o">(</span><span class="w">	</span><span class="o">(</span><span class="s">&#34;else&#34;</span><span class="o">)=&gt;</span><span class="w"> </span><span class="s">&#34;else&#34;</span><span class="w"> </span><span class="o">(</span><span class="nv">statement</span><span class="o">)*</span><span class="w"> </span><span class="o">)?</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>which can a bit easier to read if you break the <code>( )?</code> subrule into a &quot;this-or-nothing&quot; subrule.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">ifStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;if&#34;</span><span class="w"> </span><span class="no">LPAREN</span><span class="w"> </span><span class="nv">expression</span><span class="w"> </span><span class="no">RPAREN</span><span class="w"> </span><span class="o">(</span><span class="nv">statement</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">		</span><span class="o">(</span><span class="w">	</span><span class="o">(</span><span class="s">&#34;else&#34;</span><span class="o">)=&gt;</span><span class="w"> </span><span class="s">&#34;else&#34;</span><span class="w"> </span><span class="o">(</span><span class="nv">statement</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">		</span><span class="o">|</span><span class="w">	</span><span class="o">(</span><span class="w"> </span><span class="o">)</span><span class="w"> </span><span class="c">// nothing</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w">		</span><span class="o">)</span><span class="w">
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>The predicate says &quot;try matching an ELSE. If you can, then use the first alt. Otherwise, use the second alt (the &quot;nothing&quot; alternative.) Note that we will be using the more compact <code>( )?</code> form for our compiler.</p>
<hr>
<h3 id="loop-statement">Loop Statement</h3>
<p>The loop statement in XL is pretty simple. (Anyone sick of the word &quot;simple&quot; yet? But it's true, really it is.) It's a set of statements enclosed by <code>loop</code> and <code>end loop</code>, with an optional <code>while</code> clause in front of it. It looks like</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">loopStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="o">(</span><span class="s">&#34;while&#34;</span><span class="w"> </span><span class="nv">expression</span><span class="o">)?</span><span class="w"> </span><span class="s">&#34;loop&#34;</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">		</span><span class="o">(</span><span class="w"> </span><span class="nv">statement</span><span class="w"> </span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">		</span><span class="s">&#34;end&#34;</span><span class="w"> </span><span class="s">&#34;loop&#34;</span><span class="w"> </span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>Not too bad, eh? Well, just to confuse matters a bit, what would happen if XL allowed an <code>END</code> statement, like in BASIC? (BASIC's <code>END</code> statement exits the program immediately.) Come to think of it, what the heck, let's add one!</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">endStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;end&#34;</span><span class="w"> </span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>Now why would I be mentioning this here? Let's look at some XL sample code:</p>
<pre><code>program sponge =
	var x : integer := 1;
	begin
		while x &lt; 10 loop
			x := x + 1;
		end;
	end loop
end sponge.
</code></pre>
<p>Kind of contrived (and useless, I know), and simple, until you look closer...</p>
<p>What happens when the parser sees the <code>end</code> inside the loop? Let's look at the <code>loopStatement</code> rule again (repeated here 'cause you're a programmer which means you're too lazy to turn back a page):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">loopStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="o">(</span><span class="s">&#34;while&#34;</span><span class="w"> </span><span class="nv">expression</span><span class="o">)?</span><span class="w"> </span><span class="s">&#34;loop&#34;</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">		</span><span class="o">(</span><span class="w"> </span><span class="nv">statement</span><span class="w"> </span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">		</span><span class="s">&#34;end&#34;</span><span class="w"> </span><span class="s">&#34;loop&#34;</span><span class="w"> </span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>Assuming k=1 lookahead, we have a problem: how does the parser determine that the <code>end</code> in loop is an <code>endStatement</code> and not the <code>end</code> that is the first part of <code>end loop</code>? The answer is simple: with k=1 lookahead, it can't. It will always try to make it an <code>endStatement</code>, and will get a syntax error on <code>loop</code>. (Try this in the final recognizer, just for kicks.) You'll also get a conflict warning in ANTLR. (Note that you'll have the same conflict with <code>end if</code> in <code>ifStatement</code> -- our solution should, and will, handle both situations.)</p>
<p>So how do we solve this? Two possibilities: use k=2 lookahead, or use a syntactic predicate.</p>
<p>To use k=2 lookahead, you'd just need to specify <code>k=2</code> as a parser option. This will make the ANTLR run take a bit more time, but should only affect checks that require two-token lookahead.</p>
<p>In our grammar, we only have one place (this one) that causes a conflict. (Remember that our <code>ifStatement</code> is closed with an <code>end if</code>, so there's no dangling <code>else</code> conflict.) So let's fix the problem in that spot using syntactic predicates. (I also want to cover syntactic predicates a bit, so I won't go with the easier k=2 fix... In real life, I think it might make a slightly faster parser to use k=2 for this case. Syntactic predicates should probably be reserved for cases when you don't know how much lookahead you'll really need, or the known lookahead is lengthy.)</p>
<p>We can tell ANTLR exactly how to distinguish an <code>endStatement</code> from the end of a loop. How? Simple (for me at least, 'cause I already know...):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">statement</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="o">(</span><span class="s">&#34;end&#34;</span><span class="w"> </span><span class="no">SEMI</span><span class="o">)=&gt;</span><span class="w"> </span><span class="nv">endStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">		</span><span class="nv">assignmentStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">		</span><span class="o">.</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="o">.</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>Now what the heck does that mean? Basically, it says &quot;try to match <code>END</code>, then <code>SEMI</code>.&quot; If it works, then we really want the <code>endStatement</code>. If we didn't get a match, try the next alternative, and so on...</p>
<p>There's one problem that I have with the above statement. I don't like spelling out <code>END SEMI</code> in a rule other than <code>endStatement</code>. It just seems like bad isolation of rules. I'm a bit picky at times, though. What I'd rather do is say to myself, hmmm, <code>END SEMI</code> is an <code>endStatement</code>, so why not put that inside the <code>( )=&gt;</code> -- like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">statement</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="o">(</span><span class="nv">endStatement</span><span class="o">)=&gt;</span><span class="w"> </span><span class="nv">endStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w"> </span><span class="nv">assignmentStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">	</span><span class="o">.</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="o">.</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>(Note: This will be a bit less efficient than spelling it out -- the &quot;guess&quot; that ANTLR will make will need to make a function call to <code>endStatement</code> to check for <code>END SEMI</code> rather than just directly check for <code>END SEMI</code> in the statement rule. However, as long as you don't do this too much, the penalty for a function call is minimal on most machines nowadays. Just keep it to a minimum!)</p>
<p>What if <code>endStatement</code> were a bit more involved, such as</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">endStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;end&#34;</span><span class="w"> </span><span class="no">SEMI</span><span class="w"> </span><span class="nv">expression</span><span class="w"> </span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>(Kinda useless, but so are most examples.) All we need to predict it are the <code>END</code> and <code>SEMI</code>. If we keep the predicate as it is, <code>(endStatement)?</code>, the &quot;guess&quot; would keep going through expression (which could be pretty long) and the next SEMI. That would be mighty wasteful. So, in a case where we want to limit the lookahead, it's probably better to sacrifice readability a bit and limit the lookahead to just END SEMI:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">statement</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="o">(</span><span class="s">&#34;end&#34;</span><span class="w"> </span><span class="no">SEMI</span><span class="o">)=&gt;</span><span class="w"> </span><span class="nv">endStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">assignmentStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">	</span><span class="o">.</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="o">.</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>(Look familiar?) You may ask &quot;why not just put the <code>(END SEMI)?</code> in the <code>endStatement</code> rule itself?&quot; Unfortunately, ANTLR complains about a rule like</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">endStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="o">(</span><span class="s">&#34;end&#34;</span><span class="w"> </span><span class="no">SEMI</span><span class="o">)=&gt;</span><span class="w"> </span><span class="s">&#34;end&#34;</span><span class="w"> </span><span class="no">SEMI</span><span class="w"> </span><span class="nv">expression</span><span class="w"> </span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>basically telling you &quot;why bother with a predicate -- there's only one alternative!&quot; I think I'd prefer to be able to specify it like this, and have ANTLR hoist the predicate up into the statement rule (and possibly optimize it out of the <code>endStatement</code> rule altogether.) But let's work with the great tool we currently have, shall we?</p>
<p>So, we end up with two new rules:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">loopStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="o">(</span><span class="s">&#34;while&#34;</span><span class="w"> </span><span class="nv">expression</span><span class="o">)?</span><span class="w"> </span><span class="s">&#34;loop&#34;</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">		</span><span class="o">(</span><span class="nv">statement</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">		</span><span class="s">&#34;end&#34;</span><span class="w"> </span><span class="s">&#34;loop&#34;</span><span class="w"> </span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="w"></span><span class="nl">endStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;end&#34;</span><span class="w"> </span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">	
</span></span></span></code></pre></div><p>and we modify the <code>statement</code> rule to look like</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="nl">statement</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="o">(</span><span class="nv">endStatement</span><span class="o">)=&gt;</span><span class="w"> </span><span class="nv">endStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">assignmentStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">exitStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">procedureCallStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">returnStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">ifStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">loopStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">ioStatement</span><span class="w"> 
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>But is the order important in the <code>statement</code> rule? Of course, but it's not so obvious until you look at what the generated code will say. The following isn't actual generated code, but pseudocode that will show what happens in the statement rule:</p>
<pre><code>statement {
	if next token is &quot;end&quot; and guess(endStatement) worked
		do endStatement
	else if next token is IDENT
		do assignmentStatement
	else if next token is &quot;exit&quot;
		do exitStatement
	else if next token is IDENT
		do procedureCallStatement
	else if next token is &quot;return&quot;
		do returnStatement
	else if next token is &quot;if&quot;
		do ifStatement
	else if next token is (&quot;while&quot; or &quot;loop&quot;)
		do loopStatement
	else if next token is (&quot;put&quot; or &quot;get&quot;)
		do ioStatement (defined later)
}
</code></pre>
<p>A few things to notice here:</p>
<ul>
<li>Most of the conditions in this code are simple, one-test comparisons</li>
<li>The condition for <code>endStatement</code> is much more complex</li>
<li>Oooops! I see a conflict between <code>assignmentStatement</code> and <code>procedureCallStatement</code> -- hold this thought for a minute...</li>
<li>Notice that <code>loopStatement</code>'s lookup condition had two parts to it: WHILE or LOOP -- this is because the WHILE section is optional, making the FIRST set for <code>loopStatement</code> be {WHILE, LOOP} (<code>ioStatement</code> will be defined in a bit as a GET or PUT call...)</li>
<li>All of the conditions are evaluated in the order that the rules are specified</li>
<li>All of the conditions except <code>assignmentStatement</code> and <code>procedureCallStatement</code> have a unique test condition; their FIRST sets are disjoint</li>
</ul>
<p>Our goal when parsing is to make things as fast as possible. Therefore, based on the above information, we should</p>
<ul>
<li>Order the rules such that the most likely/most used rules come first -- that means less conditions to test</li>
<li>Order the rules such that rules with nasty conditions come later. Note that if the nasty condition is required to disambiguate two alternatives, it needs to be in the first of the two alternatives</li>
</ul>
<p>If possible, determine which statements are more likely to be used. Do some statistical sampling of user code (if possible) and order the rules accordingly. In this case, I think it's less likely that the user would use an END statement, and on top of that, it's more complex, so let's put it at the bottom of the list.</p>
<p>We also need to disambiguate <code>assigmentStatement</code> and <code>procedureCallStatement</code>. Recall that they look like:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">assignmentStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">variableReference</span><span class="w"> </span><span class="no">BECOMES</span><span class="w"> </span><span class="nv">expression</span><span class="w"> </span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w"></span><span class="nl">procedureCallStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="no">IDENT</span><span class="w"> </span><span class="o">(</span><span class="nv">actualParameters</span><span class="o">)?</span><span class="w"> </span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>So, how do we tell them apart? First, let's look at the FIRST sets of each (the sets that contain all tokens that can be the first terminal in a rule.) Impossible until we define <code>variableReference</code>, so let's do that now (sorry about the jumping around here..)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">variableReference</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="no">IDENT</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">		</span><span class="o">(</span><span class="w">	</span><span class="no">LBRACKET</span><span class="w"> </span><span class="nv">expression</span><span class="w"> </span><span class="no">RBRACKET</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">		</span><span class="o">|</span><span class="w">	</span><span class="no">DOT</span><span class="w"> </span><span class="no">IDENT</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w">		</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>which says a variable reference is an IDENT followed by any number of array or field dereferences.</p>
<p>Without going into a long discussion about FIRST sets, what is the FIRST set of <code>assignmentStatement</code>? By inspection, it's whatever the FIRST set is of <code>variableReference</code>, which is {IDENT}. Again, by inspection, the FIRST set of <code>procedureCallStatement</code> is also {IDENT}. There, the conflict becomes very clear. On one token alone, IDENT, the parser cannot determine which rule is proper. Looking at the pseudocode above, it becomes obvious that the parser will, in fact, always choose whichever rule is specified first with a FIRST set of {IDENT}, which is bad. So, we need to add a predicate to one of the rules. But which one? Lets look at what would be needed for each. What makes each unique? <code>assignmentStatement</code> could start out with</p>
<pre><code>IDENT BECOMES . . .      // just ident := expression
IDENT LBRACKET . . .     // starting with array reference
IDENT DOT . . .          // starting with field reference
</code></pre>
<p>and <code>procedureCallStatement</code> could start out with (after looking at <code>actualParameters</code>)</p>
<pre><code>IDENT SEMI         // No parameters (or parens)
IDENT LPAREN . . . // parameters (or just parens)
</code></pre>
<p>Obviously, they are unique with two tokens of lookahead. So, we're back to the decision of &quot;do we bump lookahead to k=2, or use predicates.&quot; k=2 would resolve the conflict, but my gut says we should use a syntactic predicate here. But which one?</p>
<p>The predicates would look like:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">statement</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="o">.</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="o">.</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="o">(</span><span class="no">IDENT</span><span class="w"> </span><span class="o">(</span><span class="no">BECOMES</span><span class="o">|</span><span class="no">LBRACKET</span><span class="o">|</span><span class="no">DOT</span><span class="o">))=&gt;</span><span class="w"> </span><span class="nv">assignmentStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="o">(</span><span class="no">IDENT</span><span class="w"> </span><span class="o">(</span><span class="no">SEMI</span><span class="o">|</span><span class="no">LPAREN</span><span class="o">))=&gt;</span><span class="w"> </span><span class="nv">procedureCallStatement</span><span class="w">
</span></span></span></code></pre></div><p>Well, the predicate for <code>procedureCallStatement</code> is actually a bit simpler. We probably should use it and put its alternative ahead of the one for <code>assignmentStatement</code>.\ If your research proves that <code>assignmentStatements</code> are found in code more often than <code>procedureCallStatements</code>, you may want to reconsider, though.</p>
<p>So what do we end up with? Using our basic rule of &quot;keep the simple stuff near the top&quot; and adding syntactic predicates for <code>endStatement</code> and <code>procedureCallStatement</code>, we get (without taking into account statistical frequency of each statement):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="nl">statement</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">exitStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">returnStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">ifStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">loopStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">ioStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="o">(</span><span class="no">IDENT</span><span class="w"> </span><span class="o">(</span><span class="no">LPAREN</span><span class="o">|</span><span class="no">SEMI</span><span class="o">))=&gt;</span><span class="w"> </span><span class="nv">procedureCallStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">assignmentStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="o">(</span><span class="nv">endStatement</span><span class="o">)=&gt;</span><span class="w"> </span><span class="nv">endStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>Now, on to our final statement...</p>
<hr>
<h3 id="io-statement">I/O Statement</h3>
<p>The I/O statement is really a procedure call to four predefined functions, <code>get</code>, <code>put</code>, <code>skipLine</code> and <code>newLine</code>. These really should be handled just like any other procedure call, but I'm putting them here just because that's how I did it the first time around, and because I don't want to mess with special pre-defined identifiers in the symbol table later...</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">ioStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;put&#34;</span><span class="w"> </span><span class="no">LPAREN</span><span class="w"> </span><span class="nv">expression</span><span class="w"> </span><span class="no">RPAREN</span><span class="w"> </span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="s">&#34;get&#34;</span><span class="w"> </span><span class="no">LPAREN</span><span class="w"> </span><span class="nv">variableReference</span><span class="w"> </span><span class="no">RPAREN</span><span class="w"> </span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="s">&#34;newLine&#34;</span><span class="w"> </span><span class="o">(</span><span class="no">LPAREN</span><span class="w"> </span><span class="no">RPAREN</span><span class="o">)?</span><span class="w"> </span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="s">&#34;skipLine&#34;</span><span class="w"> </span><span class="o">(</span><span class="no">LPAREN</span><span class="w"> </span><span class="no">RPAREN</span><span class="o">)?</span><span class="w"> </span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>Note that I was nice and allow the user to put &quot;()&quot; after <code>skipLine</code> and <code>newLine</code>, just like we did for procedure calls in general.</p>
<p>Easy enough. Now onto the sticky stuff...</p>
<h2 id="expressions-1">Expressions</h2>
<p>XL expressions are pretty similar to any old expressions you'd find in any old language (or in any new language, for that matter.) The stuff we do here will be pretty much the same in any parser or compiler you write in ANTLR, so pay attention! I know you're falling asleep after reading thirty-odd pages of drivel, but hang with me for a little longer!</p>
<p>There are a few things to notice about using ANTLR when you write expressions. The big one is that ANTLR is an LL(k) parser-generator. That means several things, but the biggest (with regard to expressions) is that left recursion is <strong>not</strong> allowed. See some compiler books for the details; in a nutshell</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">a</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="no">PLUS</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="p">;</span><span class="w"> 
</span></span></span></code></pre></div><p>would generate code like</p>
<pre><code>a() {
	a();
	match(PLUS);
	a();
} 
</code></pre>
<p>which would obviously recursively call itself until you run out of stack space. There are several ways around this. You have probably seen the following type of code used to describe parts of expressions:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">a</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">a</span><span class="w"> </span><span class="no">PLUS</span><span class="w"> </span><span class="nv">a</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">t</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w"> 
</span></span></span></code></pre></div><p>To get rid of the left-recursion that renders LL(k) grammars helpless, you can use some wonderfully-mechanical algorithms to turn it into</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="nl">a</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">a1</span><span class="w"> </span><span class="nv">a_tail</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="w"></span><span class="nl">a1</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">t</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="w"></span><span class="nl">a_tail</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="no">PLUS</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="nv">a</span><span class="err">\</span><span class="no">_tail</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="c">// nothing</span><span class="w">
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w"> 
</span></span></span></code></pre></div><p>Yuck! It works, but how long did you have to think about it to understand what it means?</p>
<p>Notice that the mechanically-generated code utilizes tail-recursion (recursion as the last element of a rule, also known as right-recursion) to keep adding (PLUS t) to the end of the &quot;a&quot; thing we are creating. Eventually, it ends with the empty (epsilon) production in place of <code>a_tail</code></p>
<p>Thinking about right-recursion, recall that right recursion can always be replaced very easily by a loop. (From where do you recall this? I dunno. Some programming class.) In ANTLR, we have the advantage of being able to use ()* and ()+ closures using EBNF notation. In other words, we can easily represent loops. So, a rule like</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">a_tail</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="no">PLUS</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="nv">a_tail</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="c">// nothing</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w"> 
</span></span></span></code></pre></div><p>can be re-written as</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">a_tail</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w"> </span><span class="o">(</span><span class="no">PLUS</span><span class="w"> </span><span class="nv">t</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w"> 
</span></span></span></code></pre></div><p>which is much better so far. Now look what we have:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">a</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">a1</span><span class="w"> </span><span class="nv">a_tail</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w"></span><span class="nl">a1</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">t</span><span class="w">
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="w"></span><span class="nl">a_tail</span><span class="w">
</span></span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="o">(</span><span class="no">PLUS</span><span class="w"> </span><span class="nv">t</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w"> 
</span></span></span></code></pre></div><p>Notice something about <code>a_tail</code> now? Without the tail recursion, it's only used in one place, so we can substitute it. And while we're at it, let's substitute <code>a1</code> in place as well, yielding</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">a</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">t</span><span class="w"> </span><span class="o">(</span><span class="no">PLUS</span><span class="w"> </span><span class="nv">t</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w"> 
</span></span></span></code></pre></div><p>When we look at that, we see that that's exactly what we wanted. Basically, PLUS is associative, so the order in which you add things really doesn't matter. You can keep saying &quot;PLUS something else&quot; at the end of our PLUS expression. The above notation is actually very good, because it matches what your brain does as it adds new parts to the expression as it reads left-to-right.</p>
<p>The moral of the above nonsense is that an expression-like rule such as</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">a</span><span class="w"> 
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">a</span><span class="w"> </span><span class="no">OPERATOR</span><span class="w"> </span><span class="nv">a</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">t</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w"> 
</span></span></span></code></pre></div><p>can be re-written</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">a</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">t</span><span class="w"> </span><span class="o">(</span><span class="no">OPERATOR</span><span class="w"> </span><span class="nv">t</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w"> 
</span></span></span></code></pre></div><p>Now that we're armed, lets start organizing for our attack on XL's expression rules!</p>
<hr>
<h3 id="precedence">Precedence</h3>
<p>In the description of XL above, we defined that the operators have the following precedences:</p>
<table>
  <thead>
      <tr>
          <th>category</th>
          <th>operators</th>
          <th>precedence</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Boolean negation</td>
          <td>not</td>
          <td>highest</td>
      </tr>
      <tr>
          <td>Unary adding operators</td>
          <td>+   -</td>
          <td></td>
      </tr>
      <tr>
          <td>Multiplying operators</td>
          <td>*   /   mod</td>
          <td></td>
      </tr>
      <tr>
          <td>Binary adding operators</td>
          <td>+ -</td>
          <td></td>
      </tr>
      <tr>
          <td>Relational operators</td>
          <td>=  /=  &lt;  &lt;=  &gt;  &gt;=</td>
          <td></td>
      </tr>
      <tr>
          <td>Logical operators</td>
          <td>and or</td>
          <td>lowest</td>
      </tr>
  </tbody>
</table>
<p>What exactly does this mean? Well, it means that if we see a <code>not</code> somewhere in an expression, we should resolve it before we resolve any other operators (unless, of course, there are specific precedences specified by using parentheses.) So if we had an expression like</p>
<pre><code>a and x or not y and 2 + -q * s &lt; 10 
</code></pre>
<p>we would first evaluate the &quot;not&quot; (let's use parentheses to specify evaluation grouping)</p>
<pre><code>a and x or (not y) and 2 + -q * s &lt; 10 
</code></pre>
<p>then take care of the unary -</p>
<pre><code>a and x or (not y) and 2 + (-q) * s &lt; 10 
</code></pre>
<p>then the *</p>
<pre><code>a and x or (not y) and 2 + ((-q) * s) &lt; 10 
</code></pre>
<p>then the binary +</p>
<pre><code>a and x or (not y) and (2 + ((-q) * s)) &lt; 10 
</code></pre>
<p>then the relational &lt;</p>
<pre><code>a and x or (not y) and ((2 + ((-q) * s)) &lt; 10) 

then the boolean `and` and `or`

(((a and x) or (not y)) and ((2 + ((-q) * s)) &lt; 10)) 
</code></pre>
<p>Whoa! Is that right? In most languages, <code>and</code> has a higher precedence than <code>or</code>. But in our precedence chart for XL, <code>and</code> and <code>or</code> have the same precedence. So while we might <em>expect</em> to see the evaluation proceed like</p>
<pre><code>((a and x) or ((not y) and ((2 + ((-q) * s)) &lt; 10))) 
</code></pre>
<p>that's not how it goes, because <code>and</code> and <code>or</code> have the same precedence, we have to just read them left to right. (In this situation, XL's design is less intuitive because of the preponderance of other languages that give <code>and</code> a higher precedence than <code>or</code>. But that was the language designer's choice, and we'll live with it.)</p>
<p>So what do we do with these precedences? Basically</p>
<ul>
<li>each level of precedence represents a rule in the grammar</li>
<li>Each operator in that precedence level is one alternative in that rule</li>
<li>The rules will nest with the highest precedence operators being the most-deeply nested rules</li>
<li>Each precedence level will only imbed the next higher precedence level.</li>
<li>The highest precedence level will only use &quot;primitive&quot; expression elements, such as variable references and literals.</li>
</ul>
<p>So lets start at the top of the precedence chart. I'm going to go out on a limb and avoid the terms <code>term</code>, <code>factor</code>, <code>simple expression</code>. I could never remember which was supposed to be which from a mathematics point of view. Instead, I'll follow Sun's lead in their Java grammar, and use more descriptive names.</p>
<p>We need to start with our primitive expression elements. In XL, these are constant values, variable references, and parenthesized expressions. Remember, parenthesizing an expression basically makes it the most important thing that is currently being evaluated.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">primitiveElement</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">constantValue</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">variableReference</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="no">LPAREN</span><span class="w"> </span><span class="nv">expression</span><span class="w"> </span><span class="no">RPAREN</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>So far so good. Now, let's just walk down the precedence chart. First, boolean negation:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">booleanNegationExpression</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="o">(</span><span class="s">&#34;not&#34;</span><span class="o">)*</span><span class="w"> </span><span class="nv">primitiveElement</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>Notice that the <code>NOT</code> is optional here, and you can have as many of them as you like. That is because we want to be able to just pass any expression element through a rule without modifying it, enabling us to have an expression just be a <code>primitiveElement</code> if that's what the user wants. Next, we have unary PLUS and MINUS:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">signExpression</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="o">(</span><span class="no">PLUS</span><span class="o">|</span><span class="no">MINUS</span><span class="o">)*</span><span class="w"> </span><span class="nv">booleanNegationExpression</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>Notice that the <code>( )*</code> can evaluate to &quot;no operators,&quot; meaning that <code>booleanNegationExpression</code> can be passed straight through this precedence level without any modification.</p>
<p>Let us have as many plusses or minuses in front of our expression so far. Next, we have our multiplying operators, *, / and <code>mod</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">multiplyingExpression</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">signExpression</span><span class="w"> </span><span class="o">((</span><span class="no">TIMES</span><span class="o">|</span><span class="no">DIV</span><span class="o">|</span><span class="s">&#34;mod&#34;</span><span class="o">)</span><span class="w"> </span><span class="nv">signExpression</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>Which lets us keep tacking on multiplying operators ad nauseum.</p>
<p>Notice that this precedence rule imbedded the previous rule, and again, can let it just pass <code>signExpression</code> right on through without modifying it. By now, things should be seeming a bit more clear. Next, we move onto the binary adding operations:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">addingExpression</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">multiplyingExpression</span><span class="w"> </span><span class="o">((</span><span class="no">PLUS</span><span class="o">|</span><span class="no">MINUS</span><span class="o">)</span><span class="w"> </span><span class="nv">multiplyingExpression</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>Will we have a conflict between an (PLUS|MINUS) acting as a binary add operator and one acting as a unary operator? No. The reason is that if we see one in between two partial expressions, it must be a binary operator. If we see another right after it (and any number of them after that) they must be working (covertly) as unary operators. Next we have the relational operators:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">relationalExpression</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">addingExpression</span><span class="w"> </span><span class="o">((</span><span class="no">EQUALS</span><span class="o">|</span><span class="no">NOT_EQUALS</span><span class="o">|</span><span class="no">GT</span><span class="o">|</span><span class="no">GTE</span><span class="o">|</span><span class="no">LT</span><span class="o">|</span><span class="no">LTE</span><span class="o">)</span><span class="w"> </span><span class="nv">addingExpression</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>Finally, we get to the operators with the lowest precedence. At this level, we can call the result a full expression. This level encompasses <code>and</code> and <code>or</code> operators:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">expression</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">relationalExpression</span><span class="w"> </span><span class="o">((</span><span class="s">&#34;and&#34;</span><span class="o">|</span><span class="s">&#34;or&#34;</span><span class="o">)</span><span class="w"> </span><span class="nv">relationalExpression</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>Tack on as many and/or partial expressions as you like...</p>
<p>Now that we've gotten through expressions, it really doesn't seem so bad. The precedence table actually made it easier, rather than more confusing.</p>
<p>At this point, we have specified the entire grammar for an XL parser. You've already seen the entire scanner. The following is our parser:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">  1</span><span class="cl"><span class="c">//-----------------------------------------------------------------------------</span><span class="w">
</span></span></span><span class="line"><span class="ln">  2</span><span class="cl"><span class="w"></span><span class="c">// Define a Parser, calling it XLRecognizer</span><span class="w">
</span></span></span><span class="line"><span class="ln">  3</span><span class="cl"><span class="w"></span><span class="c">//-----------------------------------------------------------------------------</span><span class="w">
</span></span></span><span class="line"><span class="ln">  4</span><span class="cl"><span class="w"></span><span class="nl">class</span><span class="w"> </span><span class="err">XLRecognizer</span><span class="w"> </span><span class="err">extends</span><span class="w"> </span><span class="err">Parser;</span><span class="w">
</span></span></span><span class="line"><span class="ln">  5</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">  6</span><span class="cl"><span class="w"></span><span class="k">options</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln">  7</span><span class="cl"><span class="w">	</span><span class="nv">defaultErrorHandler</span><span class="w"> </span><span class="p">=</span><span class="w"> </span>true<span class="p">;</span><span class="w">      </span><span class="c">// Don&#39;t generate parser error handlers</span><span class="w">
</span></span></span><span class="line"><span class="ln">  8</span><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">  9</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln"> 10</span><span class="cl"><span class="w"></span><span class="c">// Define some methods and variables to use in the generated parser.</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 11</span><span class="cl"><span class="w"></span><span class="p">{</span><span class="x">
</span></span></span><span class="line"><span class="ln"> 12</span><span class="cl"><span class="x">	// Define a main
</span></span></span><span class="line"><span class="ln"> 13</span><span class="cl"><span class="x">	public static void main(String[] args) </span><span class="p">{</span><span class="x">
</span></span></span><span class="line"><span class="ln"> 14</span><span class="cl"><span class="x">		// Use a try/catch block for parser exceptions
</span></span></span><span class="line"><span class="ln"> 15</span><span class="cl"><span class="x">		try </span><span class="p">{</span><span class="x">
</span></span></span><span class="line"><span class="ln"> 16</span><span class="cl"><span class="x">			// if we have at least one command-line argument
</span></span></span><span class="line"><span class="ln"> 17</span><span class="cl"><span class="x">			if (args.length &gt; 0 ) </span><span class="p">{</span><span class="x">
</span></span></span><span class="line"><span class="ln"> 18</span><span class="cl"><span class="x">				System.err.println(&#34;Parsing...&#34;);
</span></span></span><span class="line"><span class="ln"> 19</span><span class="cl"><span class="x">
</span></span></span><span class="line"><span class="ln"> 20</span><span class="cl"><span class="x">				// for each directory/file specified on the command line
</span></span></span><span class="line"><span class="ln"> 21</span><span class="cl"><span class="x">				for(int i=0; i&lt; args.length;i++)
</span></span></span><span class="line"><span class="ln"> 22</span><span class="cl"><span class="x">					doFile(new File(args[i])); // parse it
</span></span></span><span class="line"><span class="ln"> 23</span><span class="cl"><span class="x">
</span></span></span><span class="line"><span class="ln"> 24</span><span class="cl"><span class="x">			</span><span class="p">}</span><span class="x"> else </span><span class="p">{</span><span class="x">
</span></span></span><span class="line"><span class="ln"> 25</span><span class="cl"><span class="x">				System.err.println(&#34;Usage: java XLRecogizer &lt;directory name&gt;&#34;);
</span></span></span><span class="line"><span class="ln"> 26</span><span class="cl"><span class="x">			</span><span class="p">}</span><span class="x">
</span></span></span><span class="line"><span class="ln"> 27</span><span class="cl"><span class="x">
</span></span></span><span class="line"><span class="ln"> 28</span><span class="cl"><span class="x">		</span><span class="p">}</span><span class="x"> catch(Exception e) </span><span class="p">{</span><span class="x">
</span></span></span><span class="line"><span class="ln"> 29</span><span class="cl"><span class="x">			System.err.println(&#34;exception: &#34;+e);
</span></span></span><span class="line"><span class="ln"> 30</span><span class="cl"><span class="x">			e.printStackTrace(System.err);   // so we can get stack trace
</span></span></span><span class="line"><span class="ln"> 31</span><span class="cl"><span class="x">		</span><span class="p">}</span><span class="x">
</span></span></span><span class="line"><span class="ln"> 32</span><span class="cl"><span class="x">	</span><span class="p">}</span><span class="x">
</span></span></span><span class="line"><span class="ln"> 33</span><span class="cl"><span class="x">
</span></span></span><span class="line"><span class="ln"> 34</span><span class="cl"><span class="x">	// This method decides what action to take based on the type of
</span></span></span><span class="line"><span class="ln"> 35</span><span class="cl"><span class="x">	//   file we are looking at
</span></span></span><span class="line"><span class="ln"> 36</span><span class="cl"><span class="x">
</span></span></span><span class="line"><span class="ln"> 37</span><span class="cl"><span class="x">	public static void doFile(File f) throws Exception </span><span class="p">{</span><span class="x">
</span></span></span><span class="line"><span class="ln"> 38</span><span class="cl"><span class="x">		// If this is a directory, walk each file/dir in that directory
</span></span></span><span class="line"><span class="ln"> 39</span><span class="cl"><span class="x">		if (f.isDirectory()) </span><span class="p">{</span><span class="x">
</span></span></span><span class="line"><span class="ln"> 40</span><span class="cl"><span class="x">			String files[] = f.list();
</span></span></span><span class="line"><span class="ln"> 41</span><span class="cl"><span class="x">			for(int i=0; i &lt; files.length; i++) </span><span class="p">{</span><span class="x">
</span></span></span><span class="line"><span class="ln"> 42</span><span class="cl"><span class="x">				doFile(new File(f, files[i]));
</span></span></span><span class="line"><span class="ln"> 43</span><span class="cl"><span class="x">			</span><span class="p">}</span><span class="x">
</span></span></span><span class="line"><span class="ln"> 44</span><span class="cl"><span class="x">
</span></span></span><span class="line"><span class="ln"> 45</span><span class="cl"><span class="x">		// otherwise, if this is a java file, parse it!
</span></span></span><span class="line"><span class="ln"> 46</span><span class="cl"><span class="x">		</span><span class="p">}</span><span class="x"> else if ((f.getName().length()&gt;5) &amp;&amp;
</span></span></span><span class="line"><span class="ln"> 47</span><span class="cl"><span class="x">			f.getName().substring(f.getName().length()-3).equals(&#34;.xl&#34;)) </span><span class="p">{</span><span class="x">
</span></span></span><span class="line"><span class="ln"> 48</span><span class="cl"><span class="x">				System.err.println(&#34;-------------------------------------------&#34;);
</span></span></span><span class="line"><span class="ln"> 49</span><span class="cl"><span class="x">				System.err.println(f.getAbsolutePath());
</span></span></span><span class="line"><span class="ln"> 50</span><span class="cl"><span class="x">				parseFile(new FileInputStream(f));
</span></span></span><span class="line"><span class="ln"> 51</span><span class="cl"><span class="x">		</span><span class="p">}</span><span class="x">
</span></span></span><span class="line"><span class="ln"> 52</span><span class="cl"><span class="x">	</span><span class="p">}</span><span class="x">
</span></span></span><span class="line"><span class="ln"> 53</span><span class="cl"><span class="x">
</span></span></span><span class="line"><span class="ln"> 54</span><span class="cl"><span class="x">	// Here&#39;s where we do the real work...
</span></span></span><span class="line"><span class="ln"> 55</span><span class="cl"><span class="x">	public static void parseFile(InputStream s) throws Exception </span><span class="p">{</span><span class="x">
</span></span></span><span class="line"><span class="ln"> 56</span><span class="cl"><span class="x">		try </span><span class="p">{</span><span class="x">
</span></span></span><span class="line"><span class="ln"> 57</span><span class="cl"><span class="x">			// Create a scanner that reads from the input stream passed to us
</span></span></span><span class="line"><span class="ln"> 58</span><span class="cl"><span class="x">			XLLexer lexer = new XLLexer(s);
</span></span></span><span class="line"><span class="ln"> 59</span><span class="cl"><span class="x">
</span></span></span><span class="line"><span class="ln"> 60</span><span class="cl"><span class="x">			// Create a parser that reads from the scanner
</span></span></span><span class="line"><span class="ln"> 61</span><span class="cl"><span class="x">			XLRecognizer parser = new XLRecognizer(lexer);
</span></span></span><span class="line"><span class="ln"> 62</span><span class="cl"><span class="x">
</span></span></span><span class="line"><span class="ln"> 63</span><span class="cl"><span class="x">			// start parsing at the compilationUnit rule
</span></span></span><span class="line"><span class="ln"> 64</span><span class="cl"><span class="x">			parser.program();
</span></span></span><span class="line"><span class="ln"> 65</span><span class="cl"><span class="x">
</span></span></span><span class="line"><span class="ln"> 66</span><span class="cl"><span class="x">		</span><span class="p">}</span><span class="x"> catch (Exception e) </span><span class="p">{</span><span class="x">
</span></span></span><span class="line"><span class="ln"> 67</span><span class="cl"><span class="x">			System.err.println(&#34;parser exception: &#34;+e);
</span></span></span><span class="line"><span class="ln"> 68</span><span class="cl"><span class="x">			e.printStackTrace();   // so we can get stack trace 
</span></span></span><span class="line"><span class="ln"> 69</span><span class="cl"><span class="x">		</span><span class="p">}</span><span class="x">
</span></span></span><span class="line"><span class="ln"> 70</span><span class="cl"><span class="x">	</span><span class="p">}</span><span class="x">
</span></span></span><span class="line"><span class="ln"> 71</span><span class="cl"><span class="x"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 72</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln"> 73</span><span class="cl"><span class="w"></span><span class="c">// the following tag is used to find the start of the rules section for</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 74</span><span class="cl"><span class="w"></span><span class="c">//   automated chunk-grabbing when displaying the page</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 75</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln"> 76</span><span class="cl"><span class="w"></span><span class="err">program</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 77</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;program&#34;</span><span class="w"> </span><span class="no">IDENT</span><span class="w"> </span><span class="no">EQUALS</span><span class="w"> 
</span></span></span><span class="line"><span class="ln"> 78</span><span class="cl"><span class="w">		</span><span class="nv">subprogramBody</span><span class="w"> 
</span></span></span><span class="line"><span class="ln"> 79</span><span class="cl"><span class="w">		</span><span class="no">DOT</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 80</span><span class="cl"><span class="w">		</span><span class="c">// end-of-file</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 81</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 82</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln"> 83</span><span class="cl"><span class="w"></span><span class="nl">subprogramBody</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 84</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="o">(</span><span class="nv">basicDecl</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 85</span><span class="cl"><span class="w">		</span><span class="o">(</span><span class="nv">procedureDecl</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 86</span><span class="cl"><span class="w">		</span><span class="s">&#34;begin&#34;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 87</span><span class="cl"><span class="w">		</span><span class="o">(</span><span class="nv">statement</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 88</span><span class="cl"><span class="w">		</span><span class="s">&#34;end&#34;</span><span class="w"> </span><span class="no">IDENT</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 89</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 90</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln"> 91</span><span class="cl"><span class="w"></span><span class="nl">basicDecl</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 92</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">varDecl</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 93</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">constDecl</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 94</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">typeDecl</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 95</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 96</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln"> 97</span><span class="cl"><span class="w"></span><span class="nl">varDecl</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 98</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;var&#34;</span><span class="w"> </span><span class="nv">identList</span><span class="w"> </span><span class="no">COLON</span><span class="w"> </span><span class="nv">typeName</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 99</span><span class="cl"><span class="w">		</span><span class="o">(</span><span class="no">BECOMES</span><span class="w"> </span><span class="nv">constantValue</span><span class="o">)?</span><span class="w">
</span></span></span><span class="line"><span class="ln">100</span><span class="cl"><span class="w">		</span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">101</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">102</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">103</span><span class="cl"><span class="w"></span><span class="nl">constDecl</span><span class="w">
</span></span></span><span class="line"><span class="ln">104</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="s">&#34;constant&#34;</span><span class="w"> </span><span class="nv">identList</span><span class="w"> </span><span class="no">COLON</span><span class="w"> </span><span class="nv">typeName</span><span class="w">
</span></span></span><span class="line"><span class="ln">105</span><span class="cl"><span class="w">		</span><span class="no">BECOMES</span><span class="w"> </span><span class="nv">constantValue</span><span class="w"> </span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">106</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">107</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">108</span><span class="cl"><span class="w"></span><span class="nl">identList</span><span class="w">
</span></span></span><span class="line"><span class="ln">109</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="no">IDENT</span><span class="w"> </span><span class="o">(</span><span class="no">COMMA</span><span class="w"> </span><span class="no">IDENT</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">110</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">111</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">112</span><span class="cl"><span class="w"></span><span class="nl">constantValue</span><span class="w">
</span></span></span><span class="line"><span class="ln">113</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="no">INTLIT</span><span class="w">
</span></span></span><span class="line"><span class="ln">114</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="no">STRING_LITERAL</span><span class="w">
</span></span></span><span class="line"><span class="ln">115</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="no">IDENT</span><span class="w">
</span></span></span><span class="line"><span class="ln">116</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">117</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">118</span><span class="cl"><span class="w"></span><span class="nl">typeDecl</span><span class="w">
</span></span></span><span class="line"><span class="ln">119</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;type&#34;</span><span class="w"> </span><span class="no">IDENT</span><span class="w"> </span><span class="no">EQUALS</span><span class="w">
</span></span></span><span class="line"><span class="ln">120</span><span class="cl"><span class="w">		</span><span class="o">(</span><span class="w">	</span><span class="nv">arrayDecl</span><span class="w">
</span></span></span><span class="line"><span class="ln">121</span><span class="cl"><span class="w">		</span><span class="o">|</span><span class="w">	</span><span class="nv">recordDecl</span><span class="w">
</span></span></span><span class="line"><span class="ln">122</span><span class="cl"><span class="w">		</span><span class="o">)</span><span class="w">
</span></span></span><span class="line"><span class="ln">123</span><span class="cl"><span class="w">		</span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">124</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">125</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">126</span><span class="cl"><span class="w"></span><span class="nl">arrayDecl</span><span class="w">
</span></span></span><span class="line"><span class="ln">127</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;array&#34;</span><span class="w"> </span><span class="no">LBRACKET</span><span class="w"> </span><span class="nv">integerConstant</span><span class="w"> </span><span class="no">DOTDOT</span><span class="w"> </span><span class="nv">integerConstant</span><span class="w"> </span><span class="no">RBRACKET</span><span class="w">
</span></span></span><span class="line"><span class="ln">128</span><span class="cl"><span class="w">		</span><span class="s">&#34;of&#34;</span><span class="w"> </span><span class="nv">typeName</span><span class="w">
</span></span></span><span class="line"><span class="ln">129</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">130</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">131</span><span class="cl"><span class="w"></span><span class="nl">integerConstant</span><span class="w">
</span></span></span><span class="line"><span class="ln">132</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="no">INTLIT</span><span class="w">
</span></span></span><span class="line"><span class="ln">133</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="no">IDENT</span><span class="w"> </span><span class="c">// again, a constant...</span><span class="w">
</span></span></span><span class="line"><span class="ln">134</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">135</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">136</span><span class="cl"><span class="w"></span><span class="nl">recordDecl</span><span class="w">
</span></span></span><span class="line"><span class="ln">137</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;record&#34;</span><span class="w"> </span><span class="o">(</span><span class="nv">identList</span><span class="w"> </span><span class="no">COLON</span><span class="w"> </span><span class="nv">typeName</span><span class="w"> </span><span class="no">SEMI</span><span class="o">)+</span><span class="w"> </span><span class="s">&#34;end&#34;</span><span class="w"> </span><span class="s">&#34;record&#34;</span><span class="w">
</span></span></span><span class="line"><span class="ln">138</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">139</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">140</span><span class="cl"><span class="w"></span><span class="nl">typeName</span><span class="w">
</span></span></span><span class="line"><span class="ln">141</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="no">IDENT</span><span class="w">
</span></span></span><span class="line"><span class="ln">142</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="s">&#34;Integer&#34;</span><span class="w">
</span></span></span><span class="line"><span class="ln">143</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="s">&#34;Boolean&#34;</span><span class="w">
</span></span></span><span class="line"><span class="ln">144</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">145</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">146</span><span class="cl"><span class="w"></span><span class="nl">procedureDecl</span><span class="w">
</span></span></span><span class="line"><span class="ln">147</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;procedure&#34;</span><span class="w"> </span><span class="no">IDENT</span><span class="w"> </span><span class="o">(</span><span class="nv">formalParameters</span><span class="o">)?</span><span class="w"> </span><span class="no">EQUALS</span><span class="w">
</span></span></span><span class="line"><span class="ln">148</span><span class="cl"><span class="w">		</span><span class="nv">subprogramBody</span><span class="w">
</span></span></span><span class="line"><span class="ln">149</span><span class="cl"><span class="w">		</span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">150</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">151</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">152</span><span class="cl"><span class="w"></span><span class="nl">formalParameters</span><span class="w">
</span></span></span><span class="line"><span class="ln">153</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="no">LPAREN</span><span class="w"> </span><span class="nv">parameterSpec</span><span class="w"> </span><span class="o">(</span><span class="no">SEMI</span><span class="w"> </span><span class="nv">parameterSpec</span><span class="o">)*</span><span class="w"> </span><span class="no">RPAREN</span><span class="w">
</span></span></span><span class="line"><span class="ln">154</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">155</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">156</span><span class="cl"><span class="w"></span><span class="nl">parameterSpec</span><span class="w">
</span></span></span><span class="line"><span class="ln">157</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="o">(</span><span class="s">&#34;var&#34;</span><span class="o">)?</span><span class="w"> </span><span class="nv">identList</span><span class="w"> </span><span class="no">COLON</span><span class="w"> </span><span class="nv">typeName</span><span class="w">
</span></span></span><span class="line"><span class="ln">158</span><span class="cl"><span class="w"></span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">159</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">160</span><span class="cl"><span class="w"></span><span class="nl">statement</span><span class="w">
</span></span></span><span class="line"><span class="ln">161</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">exitStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">162</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">returnStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">163</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">ifStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">164</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">loopStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">165</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">ioStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">166</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="o">(</span><span class="no">IDENT</span><span class="w"> </span><span class="o">(</span><span class="no">LPAREN</span><span class="o">|</span><span class="no">SEMI</span><span class="o">))=&gt;</span><span class="w"> </span><span class="nv">procedureCallStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">167</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">assignmentStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">168</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="o">(</span><span class="nv">endStatement</span><span class="o">)=&gt;</span><span class="w"> </span><span class="nv">endStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">169</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">170</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">171</span><span class="cl"><span class="w"></span><span class="nl">assignmentStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">172</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">variableReference</span><span class="w"> </span><span class="no">BECOMES</span><span class="w"> </span><span class="nv">expression</span><span class="w"> </span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">173</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">174</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">175</span><span class="cl"><span class="w"></span><span class="nl">exitStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">176</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;exit&#34;</span><span class="w"> </span><span class="s">&#34;when&#34;</span><span class="w"> </span><span class="nv">expression</span><span class="w">
</span></span></span><span class="line"><span class="ln">177</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">178</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">179</span><span class="cl"><span class="w"></span><span class="nl">procedureCallStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">180</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="no">IDENT</span><span class="w"> </span><span class="o">(</span><span class="nv">actualParameters</span><span class="o">)?</span><span class="w"> </span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">181</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">182</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">183</span><span class="cl"><span class="w"></span><span class="nl">actualParameters</span><span class="w">
</span></span></span><span class="line"><span class="ln">184</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="no">LPAREN</span><span class="w"> </span><span class="o">(</span><span class="nv">expression</span><span class="w"> </span><span class="o">(</span><span class="no">COMMA</span><span class="w"> </span><span class="nv">expression</span><span class="o">)*)?</span><span class="w"> </span><span class="no">RPAREN</span><span class="w">
</span></span></span><span class="line"><span class="ln">185</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">186</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">187</span><span class="cl"><span class="w"></span><span class="nl">returnStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">188</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;return&#34;</span><span class="w"> </span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">189</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">190</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">191</span><span class="cl"><span class="w"></span><span class="nl">ifStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">192</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;if&#34;</span><span class="w"> </span><span class="nv">ifPart</span><span class="w"> </span><span class="s">&#34;end&#34;</span><span class="w"> </span><span class="s">&#34;if&#34;</span><span class="w"> </span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">193</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">194</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">195</span><span class="cl"><span class="w"></span><span class="nl">ifPart</span><span class="w">
</span></span></span><span class="line"><span class="ln">196</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">expression</span><span class="w"> </span><span class="s">&#34;then&#34;</span><span class="w">
</span></span></span><span class="line"><span class="ln">197</span><span class="cl"><span class="w">		</span><span class="o">(</span><span class="nv">statement</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">198</span><span class="cl"><span class="w">		</span><span class="o">(</span><span class="w">	</span><span class="s">&#34;elsif&#34;</span><span class="w"> </span><span class="nv">ifPart</span><span class="w">
</span></span></span><span class="line"><span class="ln">199</span><span class="cl"><span class="w">		</span><span class="o">|</span><span class="w">	</span><span class="s">&#34;else&#34;</span><span class="w"> </span><span class="o">(</span><span class="nv">statement</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">200</span><span class="cl"><span class="w">		</span><span class="o">)?</span><span class="w">
</span></span></span><span class="line"><span class="ln">201</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">202</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">203</span><span class="cl"><span class="w"></span><span class="nl">loopStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">204</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="o">(</span><span class="s">&#34;while&#34;</span><span class="w"> </span><span class="nv">expression</span><span class="o">)?</span><span class="w"> </span><span class="s">&#34;loop&#34;</span><span class="w">
</span></span></span><span class="line"><span class="ln">205</span><span class="cl"><span class="w">		</span><span class="o">(</span><span class="nv">statement</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">206</span><span class="cl"><span class="w">		</span><span class="s">&#34;end&#34;</span><span class="w"> </span><span class="s">&#34;loop&#34;</span><span class="w"> </span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">207</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">208</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">209</span><span class="cl"><span class="w"></span><span class="nl">endStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">210</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;end&#34;</span><span class="w"> </span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">211</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">212</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">213</span><span class="cl"><span class="w"></span><span class="nl">variableReference</span><span class="w">
</span></span></span><span class="line"><span class="ln">214</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="no">IDENT</span><span class="w">
</span></span></span><span class="line"><span class="ln">215</span><span class="cl"><span class="w">		</span><span class="o">(</span><span class="w">	</span><span class="no">LBRACKET</span><span class="w"> </span><span class="nv">expression</span><span class="w"> </span><span class="no">RBRACKET</span><span class="w">
</span></span></span><span class="line"><span class="ln">216</span><span class="cl"><span class="w">		</span><span class="o">|</span><span class="w">	</span><span class="no">DOT</span><span class="w"> </span><span class="no">IDENT</span><span class="w">
</span></span></span><span class="line"><span class="ln">217</span><span class="cl"><span class="w">		</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">218</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">219</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">220</span><span class="cl"><span class="w"></span><span class="nl">ioStatement</span><span class="w">
</span></span></span><span class="line"><span class="ln">221</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="s">&#34;put&#34;</span><span class="w"> </span><span class="no">LPAREN</span><span class="w"> </span><span class="nv">expression</span><span class="w"> </span><span class="no">RPAREN</span><span class="w"> </span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">222</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="s">&#34;get&#34;</span><span class="w"> </span><span class="no">LPAREN</span><span class="w"> </span><span class="nv">variableReference</span><span class="w"> </span><span class="no">RPAREN</span><span class="w"> </span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">223</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="s">&#34;newLine&#34;</span><span class="w"> </span><span class="o">(</span><span class="no">LPAREN</span><span class="w"> </span><span class="no">RPAREN</span><span class="o">)?</span><span class="w"> </span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">224</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="s">&#34;skipLine&#34;</span><span class="w"> </span><span class="o">(</span><span class="no">LPAREN</span><span class="w"> </span><span class="no">RPAREN</span><span class="o">)?</span><span class="w"> </span><span class="no">SEMI</span><span class="w">
</span></span></span><span class="line"><span class="ln">225</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">226</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">227</span><span class="cl"><span class="w"></span><span class="nl">primitiveElement</span><span class="w">
</span></span></span><span class="line"><span class="ln">228</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">constantValue</span><span class="w">
</span></span></span><span class="line"><span class="ln">229</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="nv">variableReference</span><span class="w">
</span></span></span><span class="line"><span class="ln">230</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="no">LPAREN</span><span class="w"> </span><span class="nv">expression</span><span class="w"> </span><span class="no">RPAREN</span><span class="w">
</span></span></span><span class="line"><span class="ln">231</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">232</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">233</span><span class="cl"><span class="w"></span><span class="nl">booleanNegationExpression</span><span class="w">
</span></span></span><span class="line"><span class="ln">234</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="o">(</span><span class="s">&#34;not&#34;</span><span class="o">)*</span><span class="w"> </span><span class="nv">primitiveElement</span><span class="w">
</span></span></span><span class="line"><span class="ln">235</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">236</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">237</span><span class="cl"><span class="w"></span><span class="nl">signExpression</span><span class="w">
</span></span></span><span class="line"><span class="ln">238</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="o">(</span><span class="no">PLUS</span><span class="o">|</span><span class="no">MINUS</span><span class="o">)*</span><span class="w"> </span><span class="nv">booleanNegationExpression</span><span class="w">
</span></span></span><span class="line"><span class="ln">239</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">240</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">241</span><span class="cl"><span class="w"></span><span class="nl">multiplyingExpression</span><span class="w">
</span></span></span><span class="line"><span class="ln">242</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">signExpression</span><span class="w"> </span><span class="o">((</span><span class="no">TIMES</span><span class="o">|</span><span class="no">DIV</span><span class="o">|</span><span class="s">&#34;mod&#34;</span><span class="o">)</span><span class="w"> </span><span class="nv">signExpression</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">243</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">244</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">245</span><span class="cl"><span class="w"></span><span class="nl">addingExpression</span><span class="w">
</span></span></span><span class="line"><span class="ln">246</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">multiplyingExpression</span><span class="w"> </span><span class="o">((</span><span class="no">PLUS</span><span class="o">|</span><span class="no">MINUS</span><span class="o">)</span><span class="w"> </span><span class="nv">multiplyingExpression</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">247</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">248</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">249</span><span class="cl"><span class="w"></span><span class="nl">relationalExpression</span><span class="w">
</span></span></span><span class="line"><span class="ln">250</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">addingExpression</span><span class="w"> </span><span class="o">((</span><span class="no">EQUALS</span><span class="o">|</span><span class="no">NOT</span><span class="err">\</span><span class="no">_EQUALS</span><span class="o">|</span><span class="no">GT</span><span class="o">|</span><span class="no">GTE</span><span class="o">|</span><span class="no">LT</span><span class="o">|</span><span class="no">LTE</span><span class="o">)</span><span class="w"> </span><span class="nv">addingExpression</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">251</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="ln">252</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">253</span><span class="cl"><span class="w"></span><span class="nl">expression</span><span class="w">
</span></span></span><span class="line"><span class="ln">254</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">relationalExpression</span><span class="w"> </span><span class="o">((</span><span class="s">&#34;and&#34;</span><span class="o">|</span><span class="s">&#34;or&#34;</span><span class="o">)</span><span class="w"> </span><span class="nv">relationalExpression</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">255</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>Now we need to discuss...</p>
<h2 id="antlr-glue">ANTLR Glue</h2>
<p>I like to call the code that wraps the scanner specification and grammar specification together into an ANTLR &quot;grammar&quot; file the &quot;ANTLR glue.&quot; It's a bit messy at first, but if we really think about what it does, step-by-step, at least some of the mystery should disappear.</p>
<p>First, let's look at the overall design of a ANTLR-based parser.</p>
<p>Let's consider what information we already have. We have already defined how we want to group input characters into tokens in our scanner definition. We have defined the syntax of our language in our grammar definition. But what gets generated when these definitions are processed by ANTLR?</p>
<p>We need the startup code (a &quot;main&quot; function), a shell class to hold the parser definition, and references to all the fun definitions that ANTLR needs to create an executable. Without saying much more (I may later), we have the following. Note that we'll be changing some of it later when we add trees, symbols and other compiler goodies...</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="nl">header</span><span class="w"> </span><span class="p">{</span><span class="x">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="x">	...definitions that need to go at top of all generated files...
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="x"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="w"></span><span class="p">{</span><span class="x">
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="x">	...Stuff at the top of generated files based on this file...
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="x">	...Note that stuff in these </span><span class="p">{</span><span class="x"> </span><span class="p">}</span><span class="x"> will appear after anything 
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="x">	...in the header </span><span class="p">{</span><span class="x"> </span><span class="p">}</span><span class="x"> code...
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="x"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="w"></span><span class="err">class</span><span class="w"> </span><span class="err">**_ParserNameGoesHere_**</span><span class="w"> </span><span class="err">extends</span><span class="w"> </span><span class="err">Parser;</span><span class="w">
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="w"></span><span class="k">options</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="w">	</span><span class="err">...parser</span><span class="w"> </span><span class="err">options...</span><span class="w">
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="w"></span><span class="p">{</span><span class="x">
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="x">	...your parser method/variable definitions...
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="x">
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="x">	// a sample main
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="x">
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="x">	public static void main(String[] args) {
</span></span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="x">		// Use a try/catch block for parser exceptions
</span></span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="x">		try </span><span class="p">{</span><span class="x">
</span></span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="x">			InputStream input = new FileInputStream(args[0]);
</span></span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="x">			XLLexer lexer = new XLLexer(s);
</span></span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="x">			XLRecognizer parser = new XLRecognizer(lexer);
</span></span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="x">			parser.program();
</span></span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="x">		
</span></span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="x">		</span><span class="p">}</span><span class="x"> catch (Exception e) </span><span class="p">{</span><span class="x">
</span></span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="x">			System.err.println(&#34;parser exception: &#34;+e);
</span></span></span><span class="line"><span class="ln">31</span><span class="cl"><span class="x">			e.printStackTrace();   // so we can get stack trace		
</span></span></span><span class="line"><span class="ln">32</span><span class="cl"><span class="x">		</span><span class="p">}</span><span class="x">
</span></span></span><span class="line"><span class="ln">33</span><span class="cl"><span class="x">	</span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">34</span><span class="cl"><span class="w"></span><span class="err">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">35</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">36</span><span class="cl"><span class="w"></span><span class="err">...parser</span><span class="w"> </span><span class="err">rules</span><span class="w"> </span><span class="err">go</span><span class="w"> </span><span class="err">here...</span><span class="w">
</span></span></span><span class="line"><span class="ln">37</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">38</span><span class="cl"><span class="w"></span><span class="err">class</span><span class="w"> </span><span class="err">_**ScannerNameGoesHere**_</span><span class="w"> </span><span class="err">extends</span><span class="w"> </span><span class="err">Lexer;</span><span class="w">
</span></span></span><span class="line"><span class="ln">39</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">40</span><span class="cl"><span class="w"></span><span class="k">options</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="ln">41</span><span class="cl"><span class="w">	</span><span class="err">...scanner</span><span class="w"> </span><span class="err">options...</span><span class="w">
</span></span></span><span class="line"><span class="ln">42</span><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">43</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">44</span><span class="cl"><span class="w"></span><span class="p">{</span><span class="x">
</span></span></span><span class="line"><span class="ln">45</span><span class="cl"><span class="x">	...your scanner method/variable definitions...
</span></span></span><span class="line"><span class="ln">46</span><span class="cl"><span class="x"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="ln">47</span><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="ln">48</span><span class="cl"><span class="w"></span><span class="err">...scanner</span><span class="w"> </span><span class="err">rules</span><span class="w"> </span><span class="err">go</span><span class="w"> </span><span class="err">here...</span><span class="w">
</span></span></span></code></pre></div><p>Now we know everything that needs to go into our recognizer.
 </p>
<h2 id="understanding-the-antlr-compilation-process">Understanding the ANTLR Compilation Process</h2>
<h3 id="the-files-involved">The Files Involved</h3>
<p>At some point I will expand on this a bit more to help understand how all the pieces fit together. For now, it may be a bit sketchy...</p>
<p>The following parts are involved when building your ANTLR parser. (Assume that you save your parser as <code>xl.g</code>):</p>
<table>
  <thead>
      <tr>
          <th>file</th>
          <th>description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>xl.g</td>
          <td>Your grammar source file</td>
      </tr>
      <tr>
          <td>XLParser.java</td>
          <td><em>generated by ANTLR</em> -- contains the class definition for the generated parser</td>
      </tr>
      <tr>
          <td>XLLexer.java</td>
          <td><em>generated by ANTLR</em> -- contains the class definition for the generated scanner</td>
      </tr>
      <tr>
          <td>XLTokenTypes.java</td>
          <td><em>generated by ANTLR</em> -- contains an interface definition that lists constant values for the token vocabulary.  Note that the name of this interafce is determined by the name of the tokenVocabulary option.</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="generating-and-compiling-your-parser">Generating and Compiling your Parser</h3>
<p>To build this tutorial, you can use Apache Ant. You can download Ant from <a href="http://ant.apache.org/">http://ant.apache.org/</a>. Ant provides an optional task that runs ANTLR. To build a grammar with this task, you add</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="ln">1</span><span class="cl"><span class="nt">&lt;antlr</span> <span class="na">target=</span><span class="s">&#34;src/com/javadude/xl1/xl1.g&#34;</span><span class="nt">&gt;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">	<span class="nt">&lt;classpath</span> <span class="na">path=</span><span class="s">&#34;lib/antlr.jar&#34;</span> <span class="nt">/&gt;</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="nt">&lt;/antlr&gt;</span>
</span></span></code></pre></div><p>The tutorial download includes an ANTLR.jar in its lib directory. You can choose a different ANTLR.jar by specifying it in the classpath tag.</p>
<p>If you've been editing your own grammar, you can tweak the &quot;xl1&quot; rule in build.xml to specify your grammar name. Otherwise, you can build the provided grammar, xl1.g.</p>
<p>To run the first build, open a command prompt, navigate to the tutorial directory, and enter</p>
<pre><code>ant xl1
</code></pre>
<p>What happened? It looks like we have a few grammar problems. Let's look at them.</p>
<p>Remember our discussion about adding <code>END</code> as a statement. Looks like it came back and bit us on the butt. But why?</p>
<p>The rules that are giving us trouble are rules like</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">subprogramBody</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="o">(</span><span class="nv">basicDecl</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">		</span><span class="o">(</span><span class="nv">procedureDecl</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">		</span><span class="s">&#34;begin&#34;</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w">		</span><span class="o">(</span><span class="nv">statement</span><span class="o">)*</span><span class="w">
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="w">		</span><span class="s">&#34;end&#34;</span><span class="w"> </span><span class="no">IDENT</span><span class="w">
</span></span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>The problem is that the <code>( )*</code> closure needs to determine when to exit. ANTLR checks to see if the &quot;next&quot; thing in the closure is also the first thing <em>after</em> the closure.  This makes the closure ambiguous.  Did you really mean to stay in the loop when it sees &quot;end&quot; as the next token, or jump out of the loop?</p>
<p>Remember that we disambiguated the &quot;end&quot; in the <code>statement</code> rule.   This was intended to force us to use endStatement when we saw an end statement.   However, it is the wrong place to do it.  The conflict is being caused at the level of the <code>(statement)*</code> loop.</p>
<p>If we just move the predicates up to the <code>(statement)*</code> closures, it may work, but now we have extra predicates all over the grammar. Our goal was to fix the lookahead problem in a single place. So let's create a single place. Instead of using <code>(statement)*</code> to represent a statement list, we'll create a rule called statementList:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">statementList</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">statementList</span><span class="w"> </span><span class="nv">statement</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="c">// nothing</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">     
</span></span></span></code></pre></div><p>Some of you may be saying &quot;but...&quot; but I'll cut you off because I've spent too much time in yacc-land recently. Silly me coded the rule this way. Yup, left-recursion, an LL no-no, but I'm not too proud to admit I make these mistakes sometimes. ANTLR is very nice about it and reports</p>
<pre><code>error: line 197: infinite recursion to rule statementList from
                 rule statementList     
</code></pre>
<p>So I shake my head in disbelief that I typed it (10 minutes before writing this) and change it to</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">statementList</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">statement</span><span class="w"> </span><span class="nv">statementList</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="c">// nothing</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">     
</span></span></span></code></pre></div><p>and compile again...</p>
<p>Better; we're still getting the message about the <code>END</code> statement. But now the conflict is isolated to one spot. The conflict is that we can choose statement when we see &quot;END&quot; in the input stream, or say &quot;we're done with the statementList&quot; because it can be followed by &quot;END.&quot; It is in this rule that we need to make the decision. So...</p>
<p>...we <em>could</em> put a syntactic predicate around the call to <code>statement</code>. But that would be incrediby wasteful. A &quot;guess&quot; parse would take place for every statement. Not good. But we still need to make a guess at this point. So what do we do?</p>
<p>We move the <code>endStatement</code> out of the statement rule and into <code>statementList</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-antlr" data-lang="antlr"><span class="line"><span class="ln">1</span><span class="cl"><span class="nl">statementList</span><span class="w">
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="w">	</span><span class="p">:</span><span class="w">	</span><span class="nv">statement</span><span class="w">  </span><span class="nv">statementList</span><span class="w">
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="o">(</span><span class="nv">endStatement</span><span class="o">)=&gt;</span><span class="w"> </span><span class="nv">endStatement</span><span class="w"> </span><span class="nv">statementList</span><span class="w">
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="w">	</span><span class="o">|</span><span class="w">	</span><span class="c">// nothing</span><span class="w">
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="w">	</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>And now, the conflict disappears. We have applied the syntactic predicate to the point of the conflict.</p>
<p>After we compile this, we have one last conflict.</p>
<pre><code>warning: line 265: nondeterminism upon
                   k==1:IDENT
                   between alts 1 and 2 of block     
</code></pre>
<p>In <code>primitiveElement</code> we have a choice between <code>constantValue</code> and <code>variableReference</code> <em>which could both be an <code>IDENT</code></em>! Why do we have <code>IDENT</code> in both places? Because the <em>semantics</em>, (the <em>meanings</em>) of the references are different. This should be a hint that we will need a <em>semantic predicate</em> to properly resolve this (without mangling the grammar.) The semantic predicate we will be using will say &quot;if the IDENT is a constant, match <code>constantValue</code>; if it's not, match <code>variableReference</code>.&quot; That type of check requires a symbol table, which we don't have yet. So, we leave this conflict in the grammar. This will produce code for <code>primitiveElement</code> like</p>
<pre><code>primitiveElement() {
	if next token is IDENT || STRING_LITERAL || INTLIT
		call constantValue
	else if next token is IDENT
		call variableReference
	else if next token is LPAREN
		match LPAREN
	call expression
		match RPAREN
	else
		report error
</code></pre>
<p>which means that an IDENT that could come in a <code>primitiveElement</code> context will be matched through <code>constantValue</code>. This is a bit of a problem, because things like a[4] cannot be matched, as they are handled by <code>variableReference</code>. Since <code>constantValue</code> only uses a single IDENT by itself, we won't lose anything by swapping it with <code>variableReference</code>, so swap 'em!</p>
<p>To compile the new version of the grammar, you can run</p>
<pre><code>ant xl2
</code></pre>
<hr>
<h3 id="building-the-java-code-and-running-tests">Building the java code and running tests.</h3>
<p>If you run ant without any options, it will perform a full build on the new xl2.g file and run some sample tests against it.</p>
<hr>
<h3 id="wrapup">Wrapup</h3>
<p>This wraps up the recognizer section of this tutorial. I hope it's been helpful at some level for you. As always, please let me know your comments (good or bad -- helps the ego ya know) at <a href="mailto:scott@javadude.com">scott@javadude.com</a>.</p>
    </div><div class="post_comments">
  
  
  
  
</div>




  </article>
<aside class="sidebar">
  <section class="sidebar_inner">
    <br>
    
  
  <div class="search">
    <input type="search" class="search_field form_field" placeholder='Search...' id="find" autocomplete="off" data-scope='post'>
    <label for="find" class="search_label"><svg class="icon">
  <title>search</title>
  <use xlink:href="#search"></use>
</svg>

    </label>
    
    <div class="search_results results"></div>
  </div>

        <div class="author_header">
          <img src="https://www.javadude.com/images/yellow.jpeg" alt="Scott Stanchfield photo">
          <h2>Scott Stanchfield</h2>
        </div>
      <div class="author_bio">
        Developer. Teacher. Tinkerer.<br/>Android and Kotlin rock!<br/>
      </div>
      <a href='https://www.javadude.com/about/' class="button mt-1" role="button" title='Read More'>Read More</a>

    
    <h2 class="mt-4">Recent Posts</h2>
    <ul class="flex-column">
      <li>
        <a href="https://www.javadude.com/post/20250323-android-docs/" class="nav-link" title="Official Android Docs (That I&#39;ve Written)">Official Android Docs (That I've Written)</a>
      </li>
      <li>
        <a href="https://www.javadude.com/post/20250322-android-class/" class="nav-link" title="My Android class content for Johns Hopkins University">My Android class content for Johns Hopkins University</a>
      </li>
      <li>
        <a href="https://www.javadude.com/post/20250322-dsl-class/" class="nav-link" title="My Domain-Specific Languages (DSL) class content for Johns Hopkins University">My Domain-Specific Languages (DSL) class content for Johns Hopkins University</a>
      </li>
      <li>
        <a href="https://www.javadude.com/post/20250322-kotlin-class/" class="nav-link" title="My Kotlin class content">My Kotlin class content</a>
      </li>
      <li>
        <a href="https://www.javadude.com/post/20190326-android-studio-deadlocks/" class="nav-link" title="Finding a deadlock in Android Studio">Finding a deadlock in Android Studio</a>
      </li>
      <li>
        <a href="https://www.javadude.com/post/20190203-kotlin01/" class="nav-link" title="From Java to Kotlin - Episode 1 - You&#39;ve Gotta Start Somewhere...">From Java to Kotlin - Episode 1 - You've Gotta Start Somewhere...</a>
      </li>
      <li>
        <a href="https://www.javadude.com/post/20170628-dsls-and-codegen/" class="nav-link" title="Domain-Specific Languages (DSLs) and Code Generation">Domain-Specific Languages (DSLs) and Code Generation</a>
      </li>
      <li>
        <a href="https://www.javadude.com/post/20151119-patterns/" class="nav-link" title="Design Patterns Brown-Bag Lectures">Design Patterns Brown-Bag Lectures</a>
      </li>
    </ul>
    <div>
      <h2 class="mt-4 taxonomy" id="categories-section">Categories</h2>
      <nav class="tags_nav">
        <a href='https://www.javadude.com/categories/articles/' class="post_tag button button_translucent" title="articles">
          ARTICLES
          <span class="button_tally">13</span>
        </a>
        
        <a href='https://www.javadude.com/categories/videos/' class="post_tag button button_translucent" title="videos">
          VIDEOS
          <span class="button_tally">12</span>
        </a>
        
        <a href='https://www.javadude.com/categories/tools/' class="post_tag button button_translucent" title="tools">
          TOOLS
          <span class="button_tally">8</span>
        </a>
        
        <a href='https://www.javadude.com/categories/class/' class="post_tag button button_translucent" title="class">
          CLASS
          <span class="button_tally">3</span>
        </a>
        
        
      </nav>
    </div>
    <div>
      <h2 class="mt-4 taxonomy" id="tags-section">Tags</h2>
      <nav class="tags_nav">
        <a href='https://www.javadude.com/tags/java/' class="post_tag button button_translucent" title="java">
          JAVA
          <span class="button_tally">28</span>
        </a>
        
        <a href='https://www.javadude.com/tags/language/' class="post_tag button button_translucent" title="language">
          LANGUAGE
          <span class="button_tally">12</span>
        </a>
        
        <a href='https://www.javadude.com/tags/design/' class="post_tag button button_translucent" title="design">
          DESIGN
          <span class="button_tally">6</span>
        </a>
        
        <a href='https://www.javadude.com/tags/kotlin/' class="post_tag button button_translucent" title="kotlin">
          KOTLIN
          <span class="button_tally">5</span>
        </a>
        
        <a href='https://www.javadude.com/tags/parsing/' class="post_tag button button_translucent" title="parsing">
          PARSING
          <span class="button_tally">5</span>
        </a>
        
        <a href='https://www.javadude.com/tags/android/' class="post_tag button button_translucent" title="android">
          ANDROID
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://www.javadude.com/tags/dsl/' class="post_tag button button_translucent" title="dsl">
          DSL
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://www.javadude.com/tags/antlr/' class="post_tag button button_translucent" title="antlr">
          ANTLR
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://www.javadude.com/tags/class/' class="post_tag button button_translucent" title="class">
          CLASS
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://www.javadude.com/tags/eclipse/' class="post_tag button button_translucent" title="eclipse">
          ECLIPSE
          <span class="button_tally">3</span>
        </a>
        
        <a href='https://www.javadude.com/tags/beans/' class="post_tag button button_translucent" title="beans">
          BEANS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://www.javadude.com/tags/patterns/' class="post_tag button button_translucent" title="patterns">
          PATTERNS
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://www.javadude.com/tags/xtext/' class="post_tag button button_translucent" title="xtext">
          XTEXT
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://www.javadude.com/tags/android-studio/' class="post_tag button button_translucent" title="android studio">
          ANDROID STUDIO
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://www.javadude.com/tags/code-generation/' class="post_tag button button_translucent" title="code generation">
          CODE GENERATION
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://www.javadude.com/tags/gradle/' class="post_tag button button_translucent" title="gradle">
          GRADLE
          <span class="button_tally">1</span>
        </a>
        
        <a href='https://www.javadude.com/tags/index/' class="post_tag button button_translucent" title="index">
          INDEX
          <span class="button_tally">1</span>
        </a>
        
        
      </nav>
    </div>
  </section>
</aside>

  
</div>
    </main><svg width="0" height="0" class="hidden">
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="facebook">
    <path d="M437 0H75C33.648 0 0 33.648 0 75v362c0 41.352 33.648 75 75 75h151V331h-60v-90h60v-61c0-49.629 40.371-90 90-90h91v90h-91v61h91l-15 90h-76v181h121c41.352 0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zm0 0"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18.001 18.001" id="twitter">
    <path d="M15.891 4.013c.808-.496 1.343-1.173 1.605-2.034a8.68 8.68 0 0 1-2.351.861c-.703-.756-1.593-1.14-2.66-1.14-1.043 0-1.924.366-2.643 1.078a3.56 3.56 0 0 0-1.076 2.605c0 .309.039.585.117.819-3.076-.105-5.622-1.381-7.628-3.837-.34.601-.51 1.213-.51 1.846 0 1.301.549 2.332 1.645 3.089-.625-.053-1.176-.211-1.645-.47 0 .929.273 1.705.82 2.388a3.623 3.623 0 0 0 2.115 1.291c-.312.08-.641.118-.979.118-.312 0-.533-.026-.664-.083.23.757.664 1.371 1.291 1.841a3.652 3.652 0 0 0 2.152.743C4.148 14.173 2.625 14.69.902 14.69c-.422 0-.721-.006-.902-.038 1.697 1.102 3.586 1.649 5.676 1.649 2.139 0 4.029-.542 5.674-1.626 1.645-1.078 2.859-2.408 3.639-3.974a10.77 10.77 0 0 0 1.172-4.892v-.468a7.788 7.788 0 0 0 1.84-1.921 8.142 8.142 0 0 1-2.11.593z"
      ></path>
  </symbol>
  <symbol aria-hidden="true" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="mail">
    <path  d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="calendar">
    <path d="M452 40h-24V0h-40v40H124V0H84v40H60C26.916 40 0 66.916 0 100v352c0 33.084 26.916 60 60 60h392c33.084 0 60-26.916 60-60V100c0-33.084-26.916-60-60-60zm20 412c0 11.028-8.972 20-20 20H60c-11.028 0-20-8.972-20-20V188h432v264zm0-304H40v-48c0-11.028 8.972-20 20-20h24v40h40V80h264v40h40V80h24c11.028 0 20 8.972 20 20v48z"></path>
    <path d="M76 230h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 310h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 390h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80-80h40v40h-40z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="github">
    <path d="M255.968 5.329C114.624 5.329 0 120.401 0 262.353c0 113.536 73.344 209.856 175.104 243.872 12.8 2.368 17.472-5.568 17.472-12.384 0-6.112-.224-22.272-.352-43.712-71.2 15.52-86.24-34.464-86.24-34.464-11.616-29.696-28.416-37.6-28.416-37.6-23.264-15.936 1.728-15.616 1.728-15.616 25.696 1.824 39.2 26.496 39.2 26.496 22.848 39.264 59.936 27.936 74.528 21.344 2.304-16.608 8.928-27.936 16.256-34.368-56.832-6.496-116.608-28.544-116.608-127.008 0-28.064 9.984-51.008 26.368-68.992-2.656-6.496-11.424-32.64 2.496-68 0 0 21.504-6.912 70.4 26.336 20.416-5.696 42.304-8.544 64.096-8.64 21.728.128 43.648 2.944 64.096 8.672 48.864-33.248 70.336-26.336 70.336-26.336 13.952 35.392 5.184 61.504 2.56 68 16.416 17.984 26.304 40.928 26.304 68.992 0 98.72-59.84 120.448-116.864 126.816 9.184 7.936 17.376 23.616 17.376 47.584 0 34.368-.32 62.08-.32 70.496 0 6.88 4.608 14.88 17.6 12.352C438.72 472.145 512 375.857 512 262.353 512 120.401 397.376 5.329 255.968 5.329z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 212 212" id="gitlab">
    <path d="M12.3 74.7h54L43.3 3c-1-3.6-6.4-3.6-7.6 0L12.3 74.8z" />
    <path d="M12.3 74.7L.5 111c-1 3.2 0 6.8 3 8.8l101.6 74-92.5-119z"/>
    <path d="M105 193.7l-38.6-119h-54l92.7 119z"/>
    <path d="M105 193.7l38.7-119H66.4l38.7 119z"/>
    <path d="M105 193.7l38.7-119H198l-93 119z"/>
    <path d="M198 74.7l11.6 36.2c1 3 0 6.6-3 8.6l-101.5 74 93-119z"/>
    <path d="M198 74.7h-54.3L167 3c1.2-3.6 6.4-3.6 7.6 0L198 74.8z"/>
  </symbol>
  <symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="rss">
    <circle cx="3.429" cy="20.571" r="3.429"></circle>
    <path d="M11.429 24h4.57C15.999 15.179 8.821 8.001 0 8v4.572c6.302.001 11.429 5.126 11.429 11.428z"></path>
    <path d="M24 24C24 10.766 13.234 0 0 0v4.571c10.714 0 19.43 8.714 19.43 19.429z"></path>
  </symbol>
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="linkedin">
    <path d="M437 0H75C33.648 0 0 33.648 0 75v362c0 41.352 33.648 75 75 75h362c41.352 0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zM181 406h-60V196h60zm0-240h-60v-60h60zm210 240h-60V286c0-16.54-13.46-30-30-30s-30 13.46-30 30v120h-60V196h60v11.309C286.719 202.422 296.93 196 316 196c40.691.043 75 36.547 75 79.688zm0 0"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 612 612" id="to-top">
    <path d="M604.501 440.509L325.398 134.956c-5.331-5.357-12.423-7.627-19.386-7.27-6.989-.357-14.056 1.913-19.387 7.27L7.499 440.509c-9.999 10.024-9.999 26.298 0 36.323s26.223 10.024 36.222 0l262.293-287.164L568.28 476.832c9.999 10.024 26.222 10.024 36.221 0 9.999-10.023 9.999-26.298 0-36.323z"></path>
  </symbol>
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="carly">
    <path d="M504.971 239.029L448 182.059V84c0-46.317-37.682-84-84-84h-44c-13.255 0-24 10.745-24 24s10.745 24 24 24h44c19.851 0 36 16.149 36 36v108c0 6.365 2.529 12.47 7.029 16.971L454.059 256l-47.029 47.029A24.002 24.002 0 0 0 400 320v108c0 19.851-16.149 36-36 36h-44c-13.255 0-24 10.745-24 24s10.745 24 24 24h44c46.318 0 84-37.683 84-84v-98.059l56.971-56.971c9.372-9.372 9.372-24.568 0-33.941zM112 192V84c0-19.851 16.149-36 36-36h44c13.255 0 24-10.745 24-24S205.255 0 192 0h-44c-46.318 0-84 37.683-84 84v98.059l-56.971 56.97c-9.373 9.373-9.373 24.568 0 33.941L64 329.941V428c0 46.317 37.682 84 84 84h44c13.255 0 24-10.745 24-24s-10.745-24-24-24h-44c-19.851 0-36-16.149-36-36V320c0-6.365-2.529-12.47-7.029-16.971L57.941 256l47.029-47.029A24.002 24.002 0 0 0 112 192z"></path>
  </symbol>
  <symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="copy">
    <path d="M23 2.75A2.75 2.75 0 0 0 20.25 0H8.75A2.75 2.75 0 0 0 6 2.75v13.5A2.75 2.75 0 0 0 8.75 19h11.5A2.75 2.75 0 0 0 23 16.25zM18.25 14.5h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5zm0-3h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5zm0-3h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5z"></path>
    <path d="M8.75 20.5a4.255 4.255 0 0 1-4.25-4.25V2.75c0-.086.02-.166.025-.25H3.75A2.752 2.752 0 0 0 1 5.25v16A2.752 2.752 0 0 0 3.75 24h12a2.752 2.752 0 0 0 2.75-2.75v-.75z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512.001 512.001" id="closeme">
    <path d="M284.286 256.002L506.143 34.144c7.811-7.811 7.811-20.475 0-28.285-7.811-7.81-20.475-7.811-28.285 0L256 227.717 34.143 5.859c-7.811-7.811-20.475-7.811-28.285 0-7.81 7.811-7.811 20.475 0 28.285l221.857 221.857L5.858 477.859c-7.811 7.811-7.811 20.475 0 28.285a19.938 19.938 0 0 0 14.143 5.857 19.94 19.94 0 0 0 14.143-5.857L256 284.287l221.857 221.857c3.905 3.905 9.024 5.857 14.143 5.857s10.237-1.952 14.143-5.857c7.811-7.811 7.811-20.475 0-28.285L284.286 256.002z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="open-menu">
    <path d="M492 236H20c-11.046 0-20 8.954-20 20s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20zm0-160H20C8.954 76 0 84.954 0 96s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20zm0 320H20c-11.046 0-20 8.954-20 20s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="instagram">
    <path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id=youtube>
    <path d="M19.615 3.184c-3.604-.246-11.631-.245-15.23 0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23 0 3.897-.266 4.356-2.62 4.385-8.816-.029-6.185-.484-8.549-4.385-8.816zm-10.615 12.816v-8l8 3.993-8 4.007z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="stackoverflow">
    <path d="M21 27v-8h3v11H0V19h3v8h18z"></path><path d="M17.1.2L15 1.8l7.9 10.6 2.1-1.6L17.1.2zm3.7 14.7L10.6 6.4l1.7-2 10.2 8.5-1.7 2zM7.2 12.3l12 5.6 1.1-2.4-12-5.6-1.1 2.4zm-1.8 6.8l13.56 1.96.17-2.38-13.26-2.55-.47 2.97zM19 25H5v-3h14v3z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="xing">
    <path d="M18.188 0c-.517 0-.741.325-.927.66 0 0-7.455 13.224-7.702 13.657.015.024 4.919 9.023 4.919 9.023.17.308.436.66.967.66h3.454c.211 0 .375-.078.463-.22.089-.151.089-.346-.009-.536l-4.879-8.916c-.004-.006-.004-.016 0-.022L22.139.756c.095-.191.097-.387.006-.535C22.056.078 21.894 0 21.686 0h-3.498zM3.648 4.74c-.211 0-.385.074-.473.216-.09.149-.078.339.02.531l2.34 4.05c.004.01.004.016 0 .021L1.86 16.051c-.099.188-.093.381 0 .529.085.142.239.234.45.234h3.461c.518 0 .766-.348.945-.667l3.734-6.609-2.378-4.155c-.172-.315-.434-.659-.962-.659H3.648v.016z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 71 55" id="discord">
    <path d="M60.1045 4.8978C55.5792 2.8214 50.7265 1.2916 45.6527 0.41542C45.5603 0.39851 45.468 0.440769 45.4204 0.525289C44.7963 1.6353 44.105 3.0834 43.6209 4.2216C38.1637 3.4046 32.7345 3.4046 27.3892 4.2216C26.905 3.0581 26.1886 1.6353 25.5617 0.525289C25.5141 0.443589 25.4218 0.40133 25.3294 0.41542C20.2584 1.2888 15.4057 2.8186 10.8776 4.8978C10.8384 4.9147 10.8048 4.9429 10.7825 4.9795C1.57795 18.7309 -0.943561 32.1443 0.293408 45.3914C0.299005 45.4562 0.335386 45.5182 0.385761 45.5576C6.45866 50.0174 12.3413 52.7249 18.1147 54.5195C18.2071 54.5477 18.305 54.5139 18.3638 54.4378C19.7295 52.5728 20.9469 50.6063 21.9907 48.5383C22.0523 48.4172 21.9935 48.2735 21.8676 48.2256C19.9366 47.4931 18.0979 46.6 16.3292 45.5858C16.1893 45.5041 16.1781 45.304 16.3068 45.2082C16.679 44.9293 17.0513 44.6391 17.4067 44.3461C17.471 44.2926 17.5606 44.2813 17.6362 44.3151C29.2558 49.6202 41.8354 49.6202 53.3179 44.3151C53.3935 44.2785 53.4831 44.2898 53.5502 44.3433C53.9057 44.6363 54.2779 44.9293 54.6529 45.2082C54.7816 45.304 54.7732 45.5041 54.6333 45.5858C52.8646 46.6197 51.0259 47.4931 49.0921 48.2228C48.9662 48.2707 48.9102 48.4172 48.9718 48.5383C50.038 50.6034 51.2554 52.5699 52.5959 54.435C52.6519 54.5139 52.7526 54.5477 52.845 54.5195C58.6464 52.7249 64.529 50.0174 70.6019 45.5576C70.6551 45.5182 70.6887 45.459 70.6943 45.3942C72.1747 30.0791 68.2147 16.7757 60.1968 4.9823C60.1772 4.9429 60.1437 4.9147 60.1045 4.8978ZM23.7259 37.3253C20.2276 37.3253 17.3451 34.1136 17.3451 30.1693C17.3451 26.225 20.1717 23.0133 23.7259 23.0133C27.308 23.0133 30.1626 26.2532 30.1066 30.1693C30.1066 34.1136 27.28 37.3253 23.7259 37.3253ZM47.3178 37.3253C43.8196 37.3253 40.9371 34.1136 40.9371 30.1693C40.9371 26.225 43.7636 23.0133 47.3178 23.0133C50.9 23.0133 53.7545 26.2532 53.6986 30.1693C53.6986 34.1136 50.9 37.3253 47.3178 37.3253Z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 17 18" id="mastodon">
    <path
    fill="#ffffff"
    d="m 15.054695,9.8859583 c -0.22611,1.1632697 -2.02517,2.4363497 -4.09138,2.6830797 -1.0774504,0.12856 -2.1382704,0.24673 -3.2694704,0.19484 -1.84996,-0.0848 -3.30971,-0.44157 -3.30971,-0.44157 0,0.1801 0.0111,0.35157 0.0333,0.51194 0.24051,1.82571 1.81034,1.93508 3.29737,1.98607 1.50088,0.0514 2.8373104,-0.37004 2.8373104,-0.37004 l 0.0617,1.35686 c 0,0 -1.0498104,0.56374 -2.9199404,0.66742 -1.03124,0.0567 -2.3117,-0.0259 -3.80308,-0.42069 -3.23454998,-0.85613 -3.79081998,-4.304 -3.87592998,-7.8024197 -0.026,-1.03871 -0.01,-2.01815 -0.01,-2.83732 0,-3.57732 2.34385998,-4.62587996 2.34385998,-4.62587996 1.18184,-0.54277 3.20976,-0.77101 5.318,-0.7882499985409 h 0.0518 C 9.8267646,0.01719834 11.856025,0.24547834 13.037775,0.78824834 c 0,0 2.34377,1.04855996 2.34377,4.62587996 0,0 0.0294,2.63937 -0.32687,4.47183"/>
 <path
    fill="#000000"
    d="m 12.616925,5.6916583 v 4.3315297 h -1.71607 V 5.8189683 c 0,-0.88624 -0.37289,-1.33607 -1.1187604,-1.33607 -0.82467,0 -1.23799,0.53361 -1.23799,1.58875 v 2.30122 h -1.70594 v -2.30122 c 0,-1.05514 -0.4134,-1.58875 -1.23808,-1.58875 -0.74587,0 -1.11876,0.44983 -1.11876,1.33607 v 4.2042197 h -1.71607 V 5.6916583 c 0,-0.88527 0.22541,-1.58876 0.67817,-2.10922 0.46689,-0.52047 1.07833,-0.78727 1.83735,-0.78727 0.87816,0 1.54317,0.33752 1.98288,1.01267 l 0.42744,0.71655 0.42753,-0.71655 c 0.43961,-0.67515 1.10463,-1.01267 1.9828704,-1.01267 0.75893,0 1.37037,0.2668 1.83735,0.78727 0.45268,0.52046 0.67808,1.22395 0.67808,2.10922"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 530" id="bluesky" >
    <path d="m135.72 44.03c66.496 49.921 138.02 151.14 164.28 205.46 26.262-54.316 97.782-155.54 164.28-205.46 47.98-36.021 125.72-63.892 125.72 24.795 0 17.712-10.155 148.79-16.111 170.07-20.703 73.984-96.144 92.854-163.25 81.433 117.3 19.964 147.14 86.092 82.697 152.22-122.39 125.59-175.91-31.511-189.63-71.766-2.514-7.3797-3.6904-10.832-3.7077-7.8964-0.0174-2.9357-1.1937 0.51669-3.7077 7.8964-13.714 40.255-67.233 197.36-189.63 71.766-64.444-66.128-34.605-132.26 82.697-152.22-67.108 11.421-142.55-7.4491-163.25-81.433-5.9562-21.282-16.111-152.36-16.111-170.07 0-88.687 77.742-60.816 125.72-24.795z"/>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" id="ko-fi">
    <path fill="#ffffff" d="M4.5,9.8527H32.7947a0,0,0,0,1,0,0v19.225a9.07,9.07,0,0,1-9.07,9.07H13.57a9.07,9.07,0,0,1-9.07-9.07V9.8527A0,0,0,0,1,4.5,9.8527Z"/>
    <path fill="#000000" d="M12.197,25.9493l6.45,6.45,6.45-6.45a8.2,8.2,0,0,0,2.4016-5.798h0a4.5082,4.5082,0,0,0-4.212-4.5459,4.4262,4.4262,0,0,0-4.64,4.4209,4.4261,4.4261,0,0,0-4.64-4.4209,4.5082,4.5082,0,0,0-4.212,4.5459h0A8.2,8.2,0,0,0,12.197,25.9493Z"/>
    <path fill="#ffffff" d="M32.7947,9.8527H35.73a7.77,7.77,0,0,1,0,15.5394H32.7947"/>
  </svg>
  </symbol>
</svg>

<footer class="footer">
  <div class="footer_inner wrap pale">
    <img src='https://www.javadude.com/icons/apple-touch-icon.png' class="icon icon_2 transparent" alt="Scott Stanchfield">
    <p>Copyright&nbsp;1998-&nbsp;<span class="year"></span>&nbsp;SCOTT STANCHFIELD. All Rights Reserved</p><a class="to_top" href="#documentTop">
  <svg class="icon">
  <title>to-top</title>
  <use xlink:href="#to-top"></use>
</svg>

</a>

  </div>
</footer>

<script type="text/javascript" src="https://www.javadude.com/en/js/bundle.91a9d0f0da58c5acdd5ce35d3bad54e076ed9e5bd70e8601c2d68ec9430e043db3691652dfc22e2cbf23188abd51a3c15dd3c3bdaba83991e7c37b71b127c01d.js" integrity="sha512-kanQ8NpYxazdXONdO61U4HbtnlvXDoYBwtaOyUMOBD2zaRZS38IuLL8jGIq9UaPBXdPDvauoOZHnw3txsSfAHQ==" crossorigin="anonymous"></script>

  <script src="https://www.javadude.com/js/search.min.9d5e38dcb73906849f3712f1758a587e9829a568aa586eae69d7684f6829a46c0084632567291f21ea3ee4a6b14ff0d9e1e6b2a4df73f2e419f4b5e0c30a4f04.js"></script>

  </body>
</html>
